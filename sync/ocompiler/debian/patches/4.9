Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-4.9) bionic; urgency=medium
 .
   * value
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2021-12-11

--- ocompiler-1.orig/.ocompiler.txt
+++ ocompiler-1/.ocompiler.txt
@@ -49,7 +49,7 @@ function_name=0
 0 is No,use linux convention if ocompiler was compiled for linux,else use microsoft; 1 is Yes; 2 is No,and cross-compile
 conv_64=0
 
-12. Zeroset reserved CHARS/DATA/STR
+12. Zeroset reserved data section declarations
 0 is No; 1 is Yes
 nul_res_pref=0
 
--- ocompiler-1.orig/make
+++ ocompiler-1/make
@@ -1,4 +1,7 @@
 
+#use Makefile
+exit
+
 ./o "./src/linux/o.s"
 
 mkdir ./build
--- ocompiler-1.orig/make.bat
+++ ocompiler-1/make.bat
@@ -1,4 +1,7 @@
 
+::use make_win32_fromLin_gnu
+exit
+
 md build
 o.exe "src/windows/o.s"
 move src\windows\o.exe build\
--- ocompiler-1.orig/make_win32_fromLin_gnu
+++ ocompiler-1/make_win32_fromLin_gnu
@@ -1,17 +1,17 @@
 
 #this is the new make for windows
 
-o ./src/windows/obj32.s
+o ./src/windows/obj32.s inplace_reloc 0 && \
 #argc argv?, no. gcc want -8 at rels and ld 0
-i686-w64-mingw32-ld -s -entry=_WinMain@16 ./src/windows/obj32.o -lmsvcrt -luser32 -lkernel32 -lcomdlg32 -o ./o.exe
-
-rm ./src/windows/obj32.o
-
-mkdir ocompiler
-mv o.exe ocompiler
-cp .ocompiler.txt ocompiler
-
-zip -r ocompiler.zip ocompiler
-rm -r ./ocompiler
-
+i686-w64-mingw32-ld -s -entry=_WinMain@16 ./src/windows/obj32.o -lmsvcrt -luser32 -lkernel32 -lcomdlg32 -lshell32 -o ./o.exe && \
+\
+rm ./src/windows/obj32.o && \
+\
+mkdir ocompiler && \
+mv o.exe ocompiler && \
+cp .ocompiler.txt ocompiler && \
+\
+zip -r ocompiler.zip ocompiler && \
+rm -r ./ocompiler && \
+\
 unzip -l ocompiler.zip
\ No newline at end of file
--- ocompiler-1.orig/o.html
+++ ocompiler-1/o.html
@@ -73,7 +73,7 @@
 	The commands are from i386 with extension for x86-64 (but with the HEX macro anything can be wrote to code section).
 </p>
 
-<h3><a name="declaringdata">Declaring data</a></h3>
+<h3><a name="declaringdata">II. Declaring data</a></h3>
 <p>
 	The language has 7 names for data declaration (1 for constants and 6 for variables).
 
@@ -106,41 +106,39 @@
 	<br>
 	Is a 32 bit value. It is used for operations, pointer operations.
 	<br>
-	There is also <b>VData</b> for reservation method that will reserve 8 bytes for a unit on 64 bit format file.
-	<br>
 	Example:
 	<br>
 	<a class="code">Data variable=100</a>
 	</p>
 
 	<p>
-	3. Characters
+	3. Strings
 	<br>
-	Language command: <b>Chars</b>
+	Language command: <b>Str</b>
 	<br>
-	Is a 8 bit value. It is used for operations.
+	Is a 32 bit value. It is used for pointer operations.
 	<br>
 	Example:
 	<br>
 	<a class="code">
-    Chars value={1}<br>
-    Chars value=1<br>
-    Chars value="Add text here"</a>
+    Chars charsdata="Text"<br>
+    Str string^charsdata<br>
+    Str text="Text data"</a>
 	</p>
 
 	<p>
-	4. Strings
+	4. Characters
 	<br>
-	Language command: <b>Str</b>
+	Language command: <b>Chars</b>
 	<br>
-	Is a 32 bit value. It is used for pointer operations.
+	Is a 8 bit value. It is used for operations.
 	<br>
 	Example:
 	<br>
 	<a class="code">
-    Chars charsdata="Text"<br>
-    Str string^charsdata<br>
-    Str text="Text data"</a>
+    Chars value={1}<br>
+    Chars value=1<br>
+    Chars value="Add text here"</a>
 	</p>
 
 	<p>
@@ -154,8 +152,9 @@
 	<br>
 	At 64bit code all stack variables are 8 bytes. 4 bytes at 32.
 	<br>
-	Stack Value differentiates at 64bit code. It will point at 8 bytes ('sv#') when sd is pointing at 4 and ss at 1.
+	Stack Value differentiates at 64bit code. It will point at 8 bytes ('sv#').
 	At 32bit code sd and sv are the same.
+	Sd is pointing at 4 and ss at 1.
 	<br>
 	These variables are located on the stack. The methods for declaring SD/SS/SV are the same as for Data/String.
 	<br>
@@ -172,7 +171,27 @@
     sd another_reserve#1</a>
 	</p>
 
+	<p>
+	8 - 10. Value variables
+	<br>
+	Language command: <b>VDATA</b>
+	<br>
+	Language command: <b>VSTR</b>
+	<br>
+	Language command: <b>VALUE</b>
+	<br>
+	Uset at reservation method only. These are not implemented for other methods, will act like DATA/STR there.
+	<br>
+	They will reserve 8 bytes for a unit on 64 bit format file.
+	<br>
+	The pointer is like for stack variables; vdata 4, vstr 1, value 4/8.
+	</p>
+
+	<br>
+
+	<p>
 	Data can be declared using the following methods:
+	</p>
 
 	<p>
 	1. Equal sign ('=')
--- ocompiler-1.orig/src/files/actions/main/index/declare.s
+++ ocompiler-1/src/files/actions/main/index/declare.s
@@ -1,8 +1,12 @@
 
 if subtype==(cVDATA)
-	SetCall errormsg dataassign(pcontent,pcomsize,(integersnumber),(TRUE))
+	SetCall errormsg dataassign(pcontent,pcomsize,(integersnumber),(datapointbit))
+elseif subtype==(cVSTR)
+	SetCall errormsg dataassign(pcontent,pcomsize,(stringsnumber),(datapointbit))
+elseif subtype==(cVALUE)
+	SetCall errormsg dataassign(pcontent,pcomsize,(integersnumber),(datapointbit|pointbit))
 else
 	sd declare_typenumber
 	setcall declare_typenumber commandSubtypeDeclare_to_typenumber(subtype)
-	SetCall errormsg dataassign(pcontent,pcomsize,declare_typenumber,(FALSE))
+	SetCall errormsg dataassign(pcontent,pcomsize,declare_typenumber,0)
 endelse
--- ocompiler-1.orig/src/files/functions/64bit.s
+++ ocompiler-1/src/files/functions/64bit.s
@@ -98,9 +98,10 @@ function rex_w_if64()
 	call rex_w(#err)
 	return err
 endfunction
+#b
 function is_big(sd dataarg,sd sufix)
 #called when lowbyte is false
-	sd b;setcall b stackbit(dataarg)
+	sd b;setcall b bigbits(dataarg)
 	if b!=0
 		setcall b pointbit(dataarg)
 		if b==0
@@ -114,6 +115,15 @@ function is_big(sd dataarg,sd sufix)
 	endif
 	return (FALSE)
 endfunction
+#z
+function bigbits(sd data)
+	sd test
+	setcall test stackbit(data)
+	if test==0
+		setcall test datapointbit(data)
+	endif
+	return test
+endfunction
 
 function stack64_op_set()
 	sd b;setcall b is_for_64()
--- ocompiler-1.orig/src/files/functions/argument/comwrite.s
+++ ocompiler-1/src/files/functions/argument/comwrite.s
@@ -131,13 +131,13 @@ Function writeoperation_take(sd p_errnr,
 	EndIf
 
 
-	sd take64stack=FALSE;sd v_64=val64_no
-	sd stacktest;setcall stacktest stackbit(location)
-	if stacktest!=0
+	sd take64=FALSE;sd v_64=val64_no
+	sd bittest;setcall bittest bigbits(location)
+	if bittest!=0
 		#p test
 		sd for_64;setcall for_64 is_for_64()
 		if for_64==(TRUE)
-			set take64stack (TRUE)
+			set take64 (TRUE)
 			set v_64 (val64_willbe)
 			#rex if p
 		endif
@@ -145,7 +145,7 @@ Function writeoperation_take(sd p_errnr,
 	endif
 	Data true=TRUE
 	If sufix==true
-		if take64stack==(TRUE)
+		if take64==(TRUE)
 			call rex_w(#errnr);If errnr!=noerr
 				set p_errnr# errnr;return (void);EndIf
 			if is_low==(TRUE)
--- ocompiler-1.orig/src/files/functions/commons/getcommand.s
+++ ocompiler-1/src/files/functions/commons/getcommand.s
@@ -5,7 +5,7 @@ Const spacenotreq=0
 
 Chars cDATA_c="DATA";Chars cSTR_c="STR";Chars cCHARS_c="CHARS";Chars cSD_c="SD";Chars cSS_c="SS";Chars cSV_c="SV"
 	Chars cCONST_c="CONST"
-	Chars cVDATA_c="VDATA"
+	Chars cVDATA_c="VDATA";Chars cVSTR_c="VSTR";Chars cVALUE_c="VALUE"
 Chars cAFTERCALL_c="AFTERCALL";Chars cIMPORTAFTERCALL_c="IMPORTAFTERCALL"
 Chars cFORMAT_c="FORMAT"
 Chars cRETURN_c="RETURN";Chars cNOT_c="NOT";Chars cINC_c="INC";Chars cDEC_c="DEC";Chars cINCST_c="INCST";Chars cDECST_c="DECST";Chars cEXIT_c="EXIT";Chars cNEG_c="NEG";Chars cSHL_c="SHL";Chars cSHR_c="SHR";Chars cSAR_c="SAR"
@@ -72,6 +72,16 @@ Const numberofcommandsvars=(!-commandsva
 			Data *=cDECLARE
 			Data *=cVDATA
 			Data *=spacereq
+		Const cVSTR=!-cDECLARE_top
+			data *^cVSTR_c
+			Data *=cDECLARE
+			Data *=cVSTR
+			Data *=spacereq
+		Const cVALUE=!-cDECLARE_top
+			data *^cVALUE_c
+			Data *=cDECLARE
+			Data *=cVALUE
+			Data *=spacereq
 #aftercall can be at function parameters but the get_img_vdata_dataReg() is set inside and codding must be done for not a big deal
 	Const cDECLAREAFTERCALL=!-coms_start
 	Const cDECLAREAFTERCALL_top=!
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ ocompiler-1/src/files/functions/dataassign.s
@@ -3,7 +3,7 @@
 
 
 #err
-Function dataassign(sd ptrcontent,sd ptrsize,sd typenumber,sd long_bool)
+Function dataassign(sd ptrcontent,sd ptrsize,sd typenumber,sd long_mask)
 	Data false=FALSE
 	Data true=TRUE
 	data stack#1
@@ -55,18 +55,23 @@ Function dataassign(sd ptrcontent,sd ptr
 		Return noerr
 	endif
 
+	Data size#1
+	Set size ptrsize#
+	If size==0
+		Chars rightsideerr="Right side of the assignment expected."
+		Str ptrrightsideerr^rightsideerr
+		Return ptrrightsideerr
+	endIf
+
 	data rightstackpointer#1
-	set rightstackpointer false
 
 	Data relocindx#1
 	Data dataind=dataind
-	Set relocindx dataind
 
 	Data value#1
 	Data ptrvalue^value
 
 	Str content#1
-	Data size#1
 	Data ptrdatasec%ptrdatasec
 	Data ptrcodesec%ptrcodesec
 	Data ptrfunctions%ptrfunctions
@@ -76,23 +81,21 @@ Function dataassign(sd ptrcontent,sd ptr
 	Data dwSz=dwsz
 	data bsz=bsz
 	data valuewritesize#1
-	set valuewritesize dwSz
 	#is for chars name="value" or str name="value"
 	data stringtodata#1
-	set stringtodata false
 	#is for chars name="value"
 	data skipNumberValue#1
-	set skipNumberValue false
 	Data importbittest#1
+
+	set rightstackpointer false
+	Set relocindx dataind
+	set valuewritesize dwSz
+	set stringtodata false
+	set skipNumberValue false
 	set importbittest -1
 
-	Set size ptrsize#
-	If size==zero
-		Chars rightsideerr="Right side of the assignment expected."
-		Str ptrrightsideerr^rightsideerr
-		Return ptrrightsideerr
 	Chars equal="="
-	ElseIf sign==equal
+	If sign==equal
 		Chars byte#1
 		Set content ptrcontent#
 		Set byte content#
@@ -181,7 +184,7 @@ Function dataassign(sd ptrcontent,sd ptr
 					Return err
 				EndIf
 				Mult value dsz
-				call enlarge_value(#value,long_bool)
+				call enlarge_value(#value,long_mask,pointer_structure,offset)
 			EndIf
 			If value<zero
 				return ptrnegreserve
@@ -195,12 +198,11 @@ Function dataassign(sd ptrcontent,sd ptr
 			if p_nul_res_pref#==(TRUE)
 				call memset(datacont,0,value)
 			endif
-			Return (noerror)
 		else
 			Mult value dsz
 			call growramp(value)
-			return noerr
 		endelse
+		Return (noerror)
 	Else
 	#^ pointer
 		Set content ptrcontent#
@@ -384,11 +386,16 @@ function add_string_to_data(sd ptrconten
 endfunction
 
 #v
-function enlarge_value(sd p_value,sd bool)
-	if bool==(TRUE)
+function enlarge_value(sd p_value,sd mask,sd structure,sd oldoffset)
+	if mask!=0
 		sd is64;setcall is64 is_for_64()
 		if is64==(TRUE)
 			mult p_value# (qwsz/dwsz)
+			sd c
+			Call getcont(structure,#c)
+			Add c oldoffset
+			add c (maskoffset)
+			or c# mask
 		endif
 	endif
 endfunction
--- ocompiler-1.orig/src/files/functions/stack/stack_inits.s
+++ ocompiler-1/src/files/functions/stack/stack_inits.s
@@ -17,6 +17,11 @@ function pointbit(sd pointer)
 	setcall bit data_get_maskbit(pointer,(pointbit))
 	return bit
 endfunction
+function datapointbit(sd pointer)
+	sd bit
+	setcall bit data_get_maskbit(pointer,(datapointbit))
+	return bit
+endfunction
 
 function stack_get_relative(sd location)
 	sd mask
--- ocompiler-1.orig/src/files/headers/header.h
+++ ocompiler-1/src/files/headers/header.h
@@ -7,9 +7,14 @@ Const referencebit=0x01
 Const idatabitfunction=0x02
 #bit offset 2: 1 means stack variable
 Const stackbit=0x04
-#bit offset 3,4,5: stack ebx/ebp
-#0x8,0x10,0x20
-Const tostack_relative=0x08
+	#stackbit
+	#bit offset 3,4,5: stack ebx/ebp
+	#0x8,0x10,0x20
+	Const tostack_relative=0x08
+	#
+	#nostackbit
+	#bit offset 3: datapointbit
+	Const datapointbit=0x08
 #bit offset 6: is functionX/importX
 const x86_64bit=0x40
 #bit offset 7; pointer bit (sv# with rex, sd# without rex)
