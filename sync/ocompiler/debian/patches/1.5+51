Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+51) xenial; urgency=medium
 .
   * ostrip
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2022-10-19

--- ocompiler-1.orig/.github/workflows/appimage.yml
+++ ocompiler-1/.github/workflows/appimage.yml
@@ -45,7 +45,7 @@ jobs:
        chmod a+x ${file}
       fi
       if [ ! -e "${name}.deb" ]; then
-       arh=i386
+       arh=amd64
        version=`cat debian/changelog | head -1 | grep -Poe "[^\(]*(?=\))"`
        if [ ! -e "lp2.py" ]; then
         wget -q https://raw.githubusercontent.com/colin-i/test/master/lp2.py
@@ -102,14 +102,16 @@ jobs:
        cd usr/bin
        cat > ${name} <<EOF
       #!/bin/bash
-      if [ "\${1}" != "0" ] && [ "\${1}" != "1" ] ; then
-       echo first argument: 0 for ocompiler, 1 for ounused
+      if [ "\${1}" != "0" ] && [ "\${1}" != "1" ] && [ "\${1}" != "2" ] ; then
+       echo first argument: 0 for ocompiler, 1 for ounused, 2 for ostrip
        exit 1
       fi
       if [ "\${1}" = "0" ]; then
        cmd=o
-      else
+      elif [ "\${1}" = "1" ]; then
        cmd=ounused
+      else
+       cmd=ostrip
       fi
       shift
       cd "\$(dirname "\$0")"
--- ocompiler-1.orig/Makefile
+++ ocompiler-1/Makefile
@@ -1,6 +1,10 @@
 TOPTARGETS := all install clean distclean uninstall test
 
+ifeq ($(shell dpkg-architecture -qDEB_HOST_ARCH), amd64)
+SUBDIRS := src ounused ostrip
+else
 SUBDIRS := src ounused
+endif
 
 $(TOPTARGETS): $(SUBDIRS)
 $(SUBDIRS):
@@ -10,6 +14,11 @@ $(SUBDIRS):
 
 all:
 	cd ./ounused; ./ounused ./ounused.s.log
+	@echo
 	if ! [ -f ./src/obj.o ];then cd ./src; ../ounused/ounused ./linux/obj.s.log; fi
+	@echo
+	if [ "$(shell dpkg-architecture -qDEB_HOST_ARCH)" = "amd64" ]; then \
+		cd ./ostrip; ./ostrip ostrip.s.log ostrip.o; pip3 install leaf; python3 leaf.py ./ostrip ./ostrip; \
+	fi
 
 .NOTPARALLEL:
--- ocompiler-1.orig/arh/pub
+++ ocompiler-1/arh/pub
@@ -27,6 +27,7 @@ last=`curl https://api.github.com/repos/
 
 #plans:
 
+#SHT_NOBITS at virtual
 #simple and or
 #={"a","b"}
 #~(page_sectionalignment-1)
--- ocompiler-1.orig/ostrip/Makefile
+++ ocompiler-1/ostrip/Makefile
@@ -8,7 +8,7 @@ FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 
 %.o: ${FULLOBJS}
-	../src/o $< exit_end 1
+	../src/o $< exit_end 1 ${OFLAGS}
 
 syms =-s
 ATLDCOM = $(LD) ${syms} --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o $@ -lc -entry main
--- /dev/null
+++ ocompiler-1/ostrip/after.s
@@ -0,0 +1,111 @@
+
+#aftercall pointer (string)
+function aftercall_find(sv objects,sv poffset)
+	sd doffset=0
+	while objects#!=(NULL)
+		sv obj=to_symtab
+		add obj objects#
+		ss sym;set sym obj#
+		incst obj
+		sd end;set end obj#
+		add end sym
+		while sym!=end
+#Data elf64_sym_st_name#1
+#Chars elf64_sym_st_info#1
+#Chars *elf64_sym_st_other={0}
+#Chars elf64_sym_st_shndx#2
+#Data elf64_sym_st_value#1;data *=0
+#Data elf64_sym_st_size#1;data *=0
+const sym__to_value=datasize+charsize+charsize+(2*charsize)
+const sym_size=sym__to_value+:+:
+const sym__to_shndx=datasize+charsize+charsize
+			add sym (sym__to_shndx)
+			chars d={dataind,0}
+			sd cmp;setcall cmp memcmp(sym,#d,2)
+			if cmp==0
+				sub sym (charsize+charsize)
+				chars info=STB_GLOBAL*0x10|STT_NOTYPE   ;#global seems to always be here but there is too much code to separate
+				if info==sym#
+				#this is the aftercall,get string pointer from strtab
+					sub sym (datasize)
+					incst obj
+					sd mem;set mem obj#
+					add mem sym#d^
+
+					#and get offset in data
+					add sym (sym__to_value)
+					add doffset sym#v^
+					add poffset# doffset
+
+					return mem
+				else
+					add sym (sym_size-datasize)
+				endelse
+			else
+				add sym (sym_size-sym__to_shndx)
+			endelse
+		endwhile
+		add obj (from_symsize_to_voffset)
+		add doffset obj#d^
+		incst objects
+	endwhile
+	return (NULL)
+endfunction
+
+function aftercall_replace(sv psym,sv pstr,ss astr,sv aoffset)
+	sd pos;setcall pos shnames_find_sec(pstr,astr)
+	if pos!=-1
+		sd sec;set sec psym#
+		incst psym
+		sd end;set end psym#
+		add end sec
+		while sec!=end
+			#name pos is first
+			if sec#==pos
+				add sec (sym__to_value)
+				set sec#v^ aoffset
+				call verbose((verbose_count))
+				call verbose((verbose_flush))
+				ret
+			endif
+			add sec (sym_size)
+		endwhile
+	endif
+endfunction
+
+function aftercall_in_objects(sv objects,ss astr,sv aoffset)
+	sv tphisic%pexetext
+	set tphisic tphisic#
+	while objects#!=(NULL)
+		sv object;set object objects#
+		sv pointer=to_strtab;add pointer object
+		sd pos;setcall pos shnames_find_sec(pointer,astr)
+		if pos!=-1
+			sub pointer (from_strtab_to_symtab)
+
+			sd sympos;set sympos pointer#
+			sv end;set end pointer
+			incst end
+			set end end#
+			add end sympos
+			while sympos!=end
+				if sympos#==pos
+					break
+				endif
+				add sympos (sym_size)
+			endwhile
+			sub sympos pointer#
+			div sympos (sym_size)
+			#if not exists there is a problem, but who cares (since objects are our own scripts)
+
+			#in data is with dataind (and only in one object)
+			#sub pointer (to_symtab)
+			#call aftercall_object_section(pointer,sympos,aoffset)
+			sub pointer (from_symtab_to_text)
+			call reloc_item(pointer,sympos,aoffset,tphisic)
+		endif
+		add object (to_text_extra)
+		add tphisic object#
+		incst objects
+	endwhile
+endfunction
--- ocompiler-1.orig/ostrip/file.s
+++ ocompiler-1/ostrip/file.s
@@ -1,12 +1,27 @@
 
 include "mem.s"
 
-function get_file(sd name,sv p_file,sd sec1,sv p_sec1,sd sec2,sv p_sec2,sd type)
+#Data sh64_name#1
+#Data sh64_type#1
+#Data sh64_flags#1;data *=0
+#Data sh64_addr#1;data *=0
+#Data sh64_offset#1;data *=0
+#Data sh64_size#1;data *=0
+#Data sh64_link#1
+#Data sh64_info#1
+#Data sh64_addralign#1;data *=0
+#Data sh64_entsize#1;data *=0
+const sh64_to_addr=4+4+:	   ;#flags :?on 32 is ok
+const sh64_addr_to_offset=:
+const sh64_addr_to_size=sh64_addr_to_offset+:
+
+#data size
+function get_file(sd name,sv p_file,sd type,sv secN,sv p_secN,sd pnrsec,sd psecond_sec,sd only_at_exec)
 	setcall p_file# fopen(name,"rb")
 	sd file;set file p_file#
 	if file!=(NULL)
 		#at frees will check next
-		set p_sec1# (NULL)
+		#set p_secN# (NULL)
 
 		chars elf64_ehd_e_ident_sign={asciiDEL,asciiE,asciiL,asciiF}
 #chars *elf64_ehd_e_ident_class={ELFCLASS64}
@@ -54,20 +69,38 @@ function get_file(sd name,sv p_file,sd s
 					call read(file,#shnum,wsz)
 					call read(file,#shstrndx,wsz)
 
-					#alloc for section names table
-					sd nrsec1;sd nrsec2;setcall nrsec1 shnames(file,offset,shentsize,shstrndx,sec1,sec2,#nrsec2)
+					sd return_value
+					#get sec indexes from section names table
+					setcall return_value shnames(file,offset,shentsize,shstrndx,secN,pnrsec,psecond_sec)
 
-					#get sections
+					#end for iterations
 					sd end;set end shnum;mult end shentsize;add end offset
-					call get_section_many(file,offset,end,shentsize,nrsec1,p_sec1)
-					if p_sec1#!=(NULL)
-						#next at frees
-						set p_sec2# (NULL)
-						#get second section
-						call get_section_many(file,offset,end,shentsize,nrsec2,p_sec2)
-					endif
 
-					ret
+					if psecond_sec!=(NULL)
+						#get data size
+						#set return_value 0    #0 can go right now(it is blank section at our objects), but that can be stripped, favorizing
+						call get_section_item(file,offset,end,#return_value,(sh64_addr_to_size),shentsize)
+						call get_section_item(file,offset,end,psecond_sec,(sh64_addr_to_size),shentsize)
+					else
+						call get_section_item(file,offset,end,#return_value,0,shentsize)
+						call write_symtab_offset(file,offset,end,shentsize,only_at_exec)
+					endelse
+
+					#get sections
+					while secN#!=(NULL)
+						#next at frees
+						set p_secN# (NULL)  #this is extra only at first
+						sd size;setcall size get_section_many(file,offset,end,shentsize,pnrsec#,p_secN)
+						if p_secN#==(NULL)
+							return return_value
+						endif
+						add secN :
+						add pnrsec (datasize)
+						add p_secN :
+						set p_secN# size
+						add p_secN :
+					endwhile
+					return return_value
 				endif
 				call erMessages("wrong machine",name)
 			endif
@@ -82,6 +115,7 @@ function fError(ss name)
 endfunction
 
 function rError()
+	#pin that readed=size*1
 	call erMessage("fread error")
 endfunction
 function read(sd file,sd buf,sd size)
@@ -107,51 +141,65 @@ function seek(sd file,sd offset,sd whenc
 	endif
 endfunction
 
-#nrsec1
-function shnames(sd file,sd offset,sd shentsize,sd shstrndx,ss sec1,ss sec2,sd pnrsec2)  #nrsec is int
+#datasec
+function shnames(sd file,sd offset,sd shentsize,sd shstrndx,sv secN,sd pnrsec,sd psecond_sec)  #nrsec is int
 	mult shstrndx shentsize
 	add offset shstrndx
 
 	sd mem;sd end;setcall end get_section(file,offset,#mem)
 	add end mem
 	#old remark:   count strings? safer than say it is the number of sections
-	sd nrsec1
-	setcall nrsec1 shnames_find(mem,end,sec1)
-	setcall pnrsec2# shnames_find(mem,end,sec2)
+
+	while secN#!=(NULL)
+		setcall pnrsec# shnames_find(mem,end,secN#)
+		add secN :
+		add pnrsec (datasize)
+	endwhile
+
+	sd datasec;setcall datasec shnames_find(mem,end,".data")
+	if psecond_sec!=(NULL)
+		setcall psecond_sec# shnames_find(mem,end,".text")
+	endif
+	#else set datasec firstnrsec
+
 	call free(mem)
-	return nrsec1
+
+	return datasec
 endfunction
 
+#sz
 function get_section_many(sd file,sd offset,sd end,sd shentsize,sd nrsec,sv p_sec)
+	call seeks(file,offset)
+	sd rest=-datasize
+	add rest shentsize
 	while offset!=end
 		#the sh64_name is first
-		if offset#==nrsec
-			call get_section(file,offset,p_sec)
-			ret
+		datax offs#1;call read(file,#offs,(datasize))
+		if offs==nrsec
+			sd sz;setcall sz get_section(file,offset,p_sec)
+			return sz   #it's in use at rels,syms and can verify errors at data/text . and also at data/text
 		endif
+		call seekc(file,rest)
 		add offset shentsize
 	endwhile
 endfunction
 
+function get_section_loc(sd file,sd offset,sv prequired_value_offset)
+	sd off=sh64_to_addr
+	add off prequired_value_offset#
+	add off offset
+	call seeks(file,off)
+	call read(file,prequired_value_offset,:)
+endfunction
 #fread
 function get_section(sd file,sd offset,sv pmem)
-#Data sh64_name#1
-#Data sh64_type#1
-#Data sh64_flags#1;data *=0
-#Data sh64_addr#1;data *=0
-#Data sh64_offset#1;data *=0
-#Data sh64_size#1;data *=0
-#Data sh64_link#1
-#Data sh64_info#1
-#Data sh64_addralign#1;data *=0
-#Data sh64_entsize#1;data *=0
-	add offset (4+4+:+:)  #flags :?on 32 is ok
-	call seeks(file,offset)
-	call read(file,#offset,:)
-	sd size;call read(file,#size,:)
-	call seeks(file,offset)
+	sd off=sh64_addr_to_offset
+	call get_section_loc(file,offset,#off)
+	sd size=sh64_addr_to_size
+	call get_section_loc(file,offset,#size)
+	call seeks(file,off)
 	sd mem;setcall mem alloc(size)
-	sd readed;setcall readed fread(file,mem,size)
+	sd readed;setcall readed fread(mem,1,size,file)
 	if readed==size
 		set pmem# mem
 		return size
@@ -159,3 +207,19 @@ function get_section(sd file,sd offset,s
 	call free(mem)
 	call rError()
 endfunction
+function get_section_item(sd file,sd offset,sd end,sv p_in_out,sd itemoff,sd shentsize)
+	call seeks(file,offset)
+	sd rest=-datasize
+	add rest shentsize
+	while offset!=end
+		#the sh64_name is first
+		datax offs#1;call read(file,#offs,(datasize))
+		if offs==p_in_out#d^
+			set p_in_out# itemoff
+			call get_section_loc(file,offset,p_in_out)
+			ret
+		endif
+		call seekc(file,rest)
+		add offset shentsize
+	endwhile
+endfunction
--- ocompiler-1.orig/ostrip/header.h
+++ ocompiler-1/ostrip/header.h
@@ -1,21 +1,23 @@
 
+include "../src/files/headers/strip.h"
+
 const EXIT_SUCCESS=0
 const EXIT_FAILURE=1
 const NULL=0
 
-const asciiE=0x45
-const asciiF=0x46
-const asciiL=0x4C
-const asciiDEL=0x7F
-
 Const SEEK_SET=0
 Const SEEK_CUR=1
 Const SEEK_END=2
 
+const ET_REL=1
 const ET_EXEC=2
 const EM_X86_64=62
 
+const F_OK=0
+
+
 Importx "stderr" stderr
+Importx "stdout" stdout
 
 Importx "fprintf" fprintf
 Importx "fopen" fopen
@@ -23,11 +25,27 @@ Importx "fread" fread
 importx "fclose" fclose
 Importx "fseek" fseek
 Importx "ftell" ftell
+Importx "fwrite" fwrite
 
 Importx "memcmp" memcmp
 importx "malloc" malloc
 importx "free" free
+importx "access" access
 
 importx "strcmp" strcmp
 importx "strlen" strlen
 importx "sscanf" sscanf
+importx "sprintf" sprintf
+
+
+const asciiE=0x45
+const asciiF=0x46
+const asciiL=0x4C
+const asciiDEL=0x7F
+
+const section_nr_of_values=2    ;#*2 for size
+
+const charsize=1
+
+const verbose_count=0
+const verbose_flush=-1
--- ocompiler-1.orig/ostrip/leaf.py
+++ ocompiler-1/ostrip/leaf.py
@@ -6,6 +6,7 @@ import subprocess
 import sys
 
 inputfile=sys.argv[1]
+outputfile=sys.argv[2]
 
 txt=subprocess.check_output(['/bin/bash','-c',"printf '%s' $(objdump -h "+inputfile+" | grep ' .data ' | tr -s ' ' | cut -d ' ' -f 4)"])
 unstripped_size=int(txt,base=16)
@@ -15,26 +16,45 @@ unstripped_size=int(txt,base=16)
 
 #this is not better than objcopy file --update-section .data=data.bin
 #data.content=bytearray(b"text")
+#ld...-Tdata to put data at trail
+
+import shutil
+
+shutil.copyfile(inputfile,outputfile)
+#after objcopy symtab changes offset -> .symtab_offset before objcopy
 
 import os
 
-r="rela.bin"
-if (not os.path.exists(r)):
-	subprocess.run(["objcopy",inputfile,"--update-section",".text=text.bin","--update-section",".data=data.bin"])
-else:
-	subprocess.run(["objcopy",inputfile,"--update-section",".text=text.bin","--update-section",".data=data.bin","--update-section",".rela.dyn="+r])
+s1=".data"
+s2=".text"
+s3=".symtab"
+if (os.path.exists(s3)):
+	#objcopy is not updating symtab
+	with open(s3+"_offset",'rb') as f:
+		value=f.read()
+		x=len(value)
+		y=b""
+		#need to reverse to big
+		for a in range(x,0,-1):
+			y+=(value[a-1]).to_bytes(1,'big')
+		value=y.hex()
+		offset=int(value,base=16)
+		with open(outputfile,'r+b') as f:
+			f.seek(offset)
+			with open(s3,'rb') as s:
+				f.write(s.read())
+subprocess.run(["objcopy",outputfile,"--update-section",s2+"="+s2,"--update-section",s1+"="+s1])
 
 import lief
 
-elffile = lief.parse(inputfile)
-
-c=".data"
+elffile = lief.parse(outputfile)
 
-s=elffile.get_section(c)
+s=elffile.get_section(s1)
 
 h=elffile.segments
 
 found=-1
+dif=0
 
 for x in h:
 	a=x.sections
@@ -42,14 +62,14 @@ for x in h:
 	for i in range(0,n):
 		b=a[i]
 		if found==-1:
-			if c==b.name:
+			if b.name==s1:
 				#only with .bss: it looks like objcopy is shrinking file size accordingly and is not touching on mem size in section and segment
 				#so this file was about to go
 				#but when it's at the edge is shrinking mem size
 				#then x.virtual_size+= is a must and a[i].virtual_address+= stays like a guardian
-				if (b.virtual_address+unstripped_size)<=(x.virtual_address+x.virtual_size):
-					exit(0)
 				found=i+1
+				if (b.virtual_address+unstripped_size)<=(x.virtual_address+x.virtual_size):
+					break
 				size=b.size
 				dif=unstripped_size-size
 		else:
@@ -61,11 +81,15 @@ for x in h:
 			if bittest!=0:
 				dif+=b.alignment-bittest
 	if found!=-1:
-		#must first increase segment size if not want to lose the section
-		x.virtual_size+=dif
-		for i in range(found,n):
-			a[i].virtual_address+=dif
-		elffile.write(sys.argv[1])
+		if dif!=0:
+			#must first increase segment size if not want to lose the section
+			x.virtual_size+=dif
+			for i in range(found,n):
+				a[i].virtual_address+=dif
+			elffile.write(outputfile)
+		st = os.stat(outputfile)
+		import stat
+		os.chmod(outputfile, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
 		#
 		#point that this script is not checking the existent virtual trail of .data
 		#remove(fn)
--- /dev/null
+++ ocompiler-1/ostrip/obj.s
@@ -0,0 +1,137 @@
+
+const object_nr_of_main_sections=2
+const object_nr_of_secondary_sections=2
+const object_nr_of_sections=object_nr_of_main_sections+object_nr_of_secondary_sections
+const section_alloc=:*section_nr_of_values
+const object_alloc_secs=object_nr_of_sections*section_alloc
+const to_text_extra=object_alloc_secs+datasize+:
+const object_alloc=to_text_extra+:
+#const to_text=section_alloc
+const to_symtab=object_nr_of_main_sections*section_alloc
+const to_strtab=to_symtab+section_alloc
+const from_symsize_to_voffset=:+section_alloc
+const from_strtab_to_symtab=section_alloc
+const from_symtab_to_text=section_alloc
+const from_text_to_extra=section_alloc+(object_nr_of_secondary_sections*section_alloc)
+
+##stripped size
+function get_objs(sv pargs,sd end)
+	#find the number of objects to prepare the field
+	sd pointers;set pointers end
+	sub pointers pargs
+	div pointers 2
+	add pointers :  #for null end
+
+	#make a container
+	sv pobjects%pobjects
+	setcall pobjects# alloc(pointers)
+
+	#set end
+	sv objects;set objects pobjects#
+	set objects# (NULL)
+
+	while pargs!=end
+		#alloc
+		setcall objects# alloc((object_alloc))
+
+		sv object;set object objects#
+		set object# (NULL)  #this is not like the first file, there is 1 more like this extra in get_file
+		add objects :
+		set objects# (NULL)
+
+		chars o1=".rela.data";chars o2=".rela.text";chars o3=".symtab";chars o4=".strtab"
+		const o1c^o1;const o2c^o2;const o3c^o3;const o4c^o4
+		value oN%{o1c,o2c,o3c,o4c}
+		value *=NULL
+		datax nrs#object_nr_of_sections   #same as previous call
+		#blank sections at ocomp?
+
+		sv p=object_alloc_secs
+		add p object
+
+		setcall p#d^ get_offset(pargs#)  #the ocomp with these sections from that creation time are still respected (32 bits)
+
+		add p (datasize)
+		incst pargs
+
+		sd file
+		sv t=:
+		add t p
+		setcall p# get_file(pargs#,#file,(ET_REL),#oN,object,#nrs,t)
+		call fclose(file)
+		setcall t# objs_align(t#)  #will be in two places used (same value)
+		incst pargs
+	endwhile
+endfunction
+
+#stripped size
+function get_offset(sd fname)
+	sd file;setcall file fopen(fname,"rb")
+	if file!=(NULL)
+		#at the first 3 documentations there is no info about errno errors for fseek ftell
+		#it is implementation specific, many judgements can be made
+		call seek(file,0,(SEEK_END))
+		sd off;setcall off ftell(file)
+		if off!=-1
+			sub off (2+8)  #knowing \r\n same as ounused that is not headering with src. and 8 is copy-paste
+			call seeks(file,off)
+			chars buf={0,0,0,0, 0,0,0,0, 0}
+			call read(file,#buf,8) #copy-paste
+			datax nr#1
+			call sscanf(#buf,"%08x",#nr) #copy-paste
+			return nr
+		endif
+		call erMessages("ftell error at",fname)
+	endif
+	call fError(fname)
+endfunction
+
+function write(sv names,sv psections)
+	while names#!=(NULL)
+		sd sec;set sec psections#
+		add psections :
+		sd size;set size psections#
+		add psections :
+		if sec!=(NULL)   #is ok only to execute the prog with no data or text
+			sd file;setcall file fopen(names#,"wb")
+			if file!=(NULL)
+				call writeclose(file,sec,size)
+			else
+				call fError(names#)
+			endelse
+		endif
+		incst names
+	endwhile
+endfunction
+function writeclose(sd file,sd buf,sd size)
+	sd written;setcall written fwrite(buf,1,size,file)
+	call fclose(file)
+	#pin that written=size*1
+	if written!=size
+		call erMessages("fwrite error")
+	endif
+endfunction
+function write_symtab_offset(sd file,sd offset,sd end,sd shentsize,sd pnr)
+	datax nr#1;set nr pnr#
+	if nr!=-1
+		call seeks(file,offset)
+		sd rest=-datasize
+		add rest shentsize
+		while offset!=end
+			#the sh64_name is first
+			datax offs#1;call read(file,#offs,(datasize))
+			if offs==nr
+				sd off=sh64_addr_to_offset
+				call get_section_loc(file,offset,#off)
+				sd fout;setcall fout fopen(#main.s3o,"wb")
+				if fout!=(NULL)
+					call writeclose(fout,#off,:)
+					ret
+				endif
+				call fError(#main.s3o)
+			endif
+			call seekc(file,rest)
+			add offset shentsize
+		endwhile
+	endif
+endfunction
--- ocompiler-1.orig/ostrip/ostrip.s
+++ ocompiler-1/ostrip/ostrip.s
@@ -1,7 +1,7 @@
 
-#must do a stripped data.bin and resolved text.bin
+#must do a stripped .data and resolved .text (and .symtab with offset (more at leaf.py))
 
-#input: exec o1 log1 ... oN logN
+#input: exec log1 o1 ... logN oN
 
 format elfobj64
 #modify debian/control exec depends,appimage.yml,debian/control arh order
@@ -24,49 +24,111 @@ format elfobj64
 #	aftercall value at .dynsym
 
 #pin about .data align at objects that ld respects when concatenating
+#aftercall is retrieved in .symtab in an entry with Type=NOTYPE and Ndx=dataind, then .strtab for name, then in another objects an import with that name
+#at exec instead of .strtab can be value is inside data(there are outside data values as well), but that's extra code
+#aftercall can be resolved not from the first iteration
 
 include "header.h"
 
 include "throwless.s"
+include "rel.s"
 
-function messagedelim()
-	sv st^stderr
+function messagedelim(sv st)
 	Chars visiblemessage={0x0a,0}
 	Call fprintf(st#,#visiblemessage)
 endfunction
 Function Message(ss text)
+	sv st^stdout
+	Call fprintf(st#,text)
+	call messagedelim(st)
+EndFunction
+Function eMessage(ss text)
 	sv st^stderr
 	Call fprintf(st#,text)
-	call messagedelim()
+	call messagedelim(st)
 EndFunction
 function erMessage(ss text)
-	call Message(text)
+	call eMessage(text)
 	call erEnd()
 endfunction
 function erMessages(ss m1,ss m2)
-	call Message(m1)
-	call Message(m2)
+	call eMessage(m1)
+	call eMessage(m2)
 	call erEnd()
 endfunction
 function erEnd()
 	call frees()
 	aftercall er
-	set er (~0)
+	set er ~0
 	return (EXIT_FAILURE)
 endfunction
 
+chars s1=".data";chars s2=".text";chars s3=".symtab";chars s3o=".symtab_offset";chars s4=".strtab"
+
 include "file.s"
-include "size.s"
+include "obj.s"
+include "after.s"
 
-entrylinux main(sd argc,ss *argv0,ss exec,ss obj1,ss *log1)   #... objN logN
+entrylinux main(sd argc,ss argv0,ss exec,ss log1,ss *obj1)   #... logN objN
+
+if argc>=(1+3)  #0 is all the time
+	sd verb%ptrverbose
+	setcall verb# access(".debug",(F_OK))
 
-if argc>(1+3)  #0 is all the time
 	sv pfile%pexefile
-	sv pexedata%pexedata
-	sv pexetext%pexetext
-	call get_file(exec,pfile,".data",pexedata,".text",pexetext,(ET_EXEC))
-	sub argc 2
-	sd stripped_data_size;setcall stripped_data_size get_offset(#obj1,argc)
+	const s1c^s1;const s2c^s2;const s3c^s3;const s4c^s4
+	value sN%{s1c,s2c}
+	value s3c%s3c
+	value s4c%s4c
+	value *=NULL
+	sv pexe%pexedata
+	datax nrs#2   #this is required inside but is better than passing the number of sections
+	datax symtabnr#1
+	datax *#1
+
+	#text/data can go null later, with access error if rela points there, but to not set here null is probably same access error
+	#sv pt%pexetext
+	#set pt# (NULL)
+	sv ps%pexesym
+	set ps# (NULL)
+	#and set data null here, it is useless there for objects call
+	set pexe# (NULL)   #data
+
+	sv pobjects%pobjects
+	set pobjects# (NULL) #this is on the main plan, is after ss exec at frees
+
+	sd datavaddr;setcall datavaddr get_file(exec,pfile,(ET_EXEC),#sN,pexe,#nrs,(NULL),#symtabnr)
+
+	mult argc :
+	add argc #argv0
+	call get_objs(#log1,argc) #aftercall can be in any object, need to keep memory
+
+	call objs_concat(pobjects#,pexe)
+
+	call reloc(pobjects#,datavaddr)
+
+	sd acall;setcall acall aftercall_find(pobjects#,#datavaddr)
+	if acall!=(NULL)
+		if ps#!=(NULL)
+			#replace if exe symtab
+			sv pexestr%pexestr
+			call aftercall_replace(ps,pexestr,acall,datavaddr)
+
+			set s4c (NULL)  #for write skip
+		else
+			#the symbols have been stripped (-s)
+			set s3c (NULL)
+		endelse
+
+		#replace on the field
+		call aftercall_in_objects(pobjects#,acall,datavaddr)
+	else
+		#skip symtab if no aftercall
+		set s3c (NULL)  #write will stop there
+	endelse
+
+	call write(#sN,pexe)
+
 	call frees()
 	return (EXIT_SUCCESS)
 endif
--- /dev/null
+++ ocompiler-1/ostrip/rel.s
@@ -0,0 +1,92 @@
+
+
+function reloc(sv objects,sd daddr)
+	sd doffset;set doffset daddr
+	sv voffset%pexedatasize;   #this is after the new size was set
+	set voffset voffset#
+	add voffset daddr
+	sv dphisic%pexedata
+	set dphisic dphisic#
+	sv tphisic%pexetext
+	set tphisic tphisic#
+	while objects#!=(NULL)
+		sv object;set object objects#
+		sd d;set d object
+		add object (section_alloc)
+
+		sd t;set t object
+		add object (from_text_to_extra)
+
+		sd voffset_obj;set voffset_obj object#d^
+		add object (datasize)
+
+		sv vsize_obj;set vsize_obj object#
+		sub vsize_obj voffset_obj
+		incst object
+
+		call reloc_sec(d,doffset,voffset,voffset_obj,dphisic)
+		call reloc_sec(t,doffset,voffset,voffset_obj,tphisic)
+
+		add doffset voffset_obj
+		add voffset vsize_obj
+		add dphisic voffset_obj
+		add tphisic object#
+
+		incst objects
+	endwhile
+endfunction
+
+function reloc_sec(sv object,sd doffset,sd voffset,sd voffset_obj,sd soffset)
+	sv pointer;set pointer object#
+	incst object
+	sd end;set end object#
+	add end pointer
+	while pointer!=end
+#		Data elf64_r_offset#1;data *=0
+#		data elf64_r_info_type#1
+#		data elf64_r_info_symbolindex#1
+#		data elf64_r_addend#1;data *=0
+		const rel_size=:+datasize+datasize+:
+		sv cursor;set cursor pointer
+		incst cursor
+		if cursor#d^==(R_X86_64_64)
+			add cursor (datasize)
+			if cursor#d^==(dataind)
+				add cursor (datasize)
+				sv addend;set addend cursor#
+				if addend>=voffset_obj
+					add addend voffset
+				else
+					add addend doffset
+				endelse
+				sv rel_offset;set rel_offset pointer#
+				add rel_offset soffset
+				set rel_offset# addend
+				call verbose((verbose_count))
+			endif
+		endif
+		add pointer (rel_size)
+	endwhile
+	call verbose((verbose_flush))
+endfunction
+function reloc_item(sv object,sd index,sv replacement,sd soffset)
+	sv pointer;set pointer object#
+	incst object
+	sd end;set end object#
+	add end pointer
+	while pointer!=end
+		sv cursor;set cursor pointer
+		incst cursor
+		if cursor#d^==(R_X86_64_64)
+			add cursor (datasize)
+			if cursor#d^==index
+				sv rel_offset;set rel_offset pointer#
+				add rel_offset soffset
+				set rel_offset# replacement
+				call verbose((verbose_count))
+			endif
+		endif
+		add pointer (rel_size)
+	endwhile
+	call verbose((verbose_flush))
+endfunction
--- ocompiler-1.orig/ostrip/size.s
+++ /dev/null
@@ -1,33 +0,0 @@
-
-function get_offset(sd args,sd end)
-	mult end :
-	add end args
-	sd offset=0
-	while args!=end
-		add args :
-		addcall offset get_offset_item(args)
-		add args :
-	endwhile
-	return offset
-endfunction
-
-function get_offset_item(sd fname)
-	sd file;setcall file fopen(fname,"rb")
-	if file!=(NULL)
-		#at the first 3 documentations there is no info about errno errors for fseek ftell
-		#it is implementation specific, many judgements can be made
-		call seek(file,0,(SEEK_END))
-		sd off;setcall off ftell(file)
-		if off!=-1
-			sub off (2+8)  #knowing \r\n same as ounused that is not headering with src. and 8 is copy-paste
-			call seeks(file,off)
-			chars buf={0,0,0,0, 0,0,0,0, 0}
-			call read(file,#buf,8) #copy-paste
-			datax nr#1
-			call sscanf(#buf,"%08x",#nr) #copy-paste
-			return nr
-		endif
-		call erMessages("ftell error at",fname)
-	endif
-	call fError(fname)
-endfunction
--- ocompiler-1.orig/ostrip/throwless.s
+++ ocompiler-1/ostrip/throwless.s
@@ -4,33 +4,159 @@ function frees()
 	const pexefile^exefile
 	if exefile!=(NULL)
 		call fclose(exefile)
-		valuex exedata#1
-		const pexedata^exedata
+	valuex exedata#1;valuex exedatasize#1
+	valuex exetext#section_nr_of_values
+	valuex exesym#section_nr_of_values
+	valuex exestr#section_nr_of_values
+	const pexedata^exedata;const pexedatasize^exedatasize
+	const pexetext^exetext
+	const pexesym^exesym
+	const pexestr^exestr
 		if exedata!=(NULL)
 			call free(exedata)
-			valuex exetext#1
-			const pexetext^exetext
 			if exetext!=(NULL)
 				call free(exetext)
+				if exesym!=(NULL)
+					call free(exesym)
+					if exestr!=(NULL)
+						call free(exestr)
+					endif
+				endif
 			endif
 		endif
+		valuex objects#1
+		const pobjects^objects
+		if objects!=(NULL)
+			call freeobjects(objects)
+			call free(objects)
+		endif
 	endif
 endfunction
+function freeobjects(sv objects)
+	while objects#!=(NULL)
+		call freeobject(objects#)
+		call free(objects#)
+		add objects :
+	endwhile
+endfunction
+function freeobject(sv object)
+	sd end=object_alloc_secs
+	add end object
+	while object!=end
+		if object#!=(NULL)
+			call free(object#)
+		else
+			ret
+		endelse
+		add object (section_alloc)
+	endwhile
+endfunction
 
+function verbose(sd action)
+	datax a#1
+	const ptrverbose^a
+	data n=0     ;#only in one ocomp section
+	if a==0
+		if action==(verbose_count)
+			inc n
+		else
+		#if action==(verbose_flush)
+			chars out#10+1   ;#max 32
+			call sprintf(#out,"%u",n)
+			call Message(#out)
+			set n 0
+		endelse
+	endif
+endfunction
 
 #file
 
 #pos/-1
 function shnames_find(ss mem,sd end,sd str)
-	sd pos=0
+	sd start;set start mem
 	while mem!=end
 		sd cmp;setcall cmp strcmp(mem,str)
 		if cmp==0
-			return pos
+			sub mem start
+			return mem
 		endif
 		addcall mem strlen(mem)
 		inc mem
-		inc pos
 	endwhile
 	return -1
 endfunction
+function shnames_find_sec(sv sec,sd str)
+	sd mem;set mem sec#
+	incst sec
+	sd end;set end mem
+	add end sec#
+	sd pos;setcall pos shnames_find(mem,end,str)
+	return pos
+endfunction
+
+#obj
+
+function objs_concat(sv objects,sv pdata)
+	sd initial;set initial pdata#
+	#sd pdatabin%pdatabin;setcall pdatabin# alloc(sz)
+	sd dest;set dest initial
+	sd src;set src dest
+
+	#skip first memtomem
+	sv object=object_alloc_secs;add object objects#
+	add dest object#d^
+	add object (datasize)
+	addcall src objs_align(object#)
+	incst objects
+
+	while objects#!=(NULL)
+		set object (object_alloc_secs);add object objects#
+		sd stripped;set stripped object#d^
+		#we implement own memcpy here because right to left can break all
+		call memtomem(dest,src,stripped)
+		add dest stripped
+		add object (datasize)
+		addcall src objs_align(object#)
+		incst objects
+	endwhile
+
+	add pdata :
+	#exe data size can have last object aligned/unaligned this way (don't count on initial size)
+	sub dest initial
+	#rewrite size from unstripped to stripped
+	sd size;set size pdata#
+	set pdata# dest
+
+	sub size dest
+	sv out^stdout
+	call fprintf(out#,"Stripped size: %llu bytes",size)
+	call messagedelim(out)
+endfunction
+
+function memtomem(sv dest,sv src,sd size)
+	#optimized?
+	const stack_size_trail=:-1
+	sd opt=~stack_size_trail
+	and opt size
+	sub size opt
+	add opt dest
+	while dest!=opt
+		set dest# src#
+		incst dest
+		incst src
+	endwhile
+	add size dest
+	while dest!=size
+		set dest#s^ src#s^
+		inc dest
+		inc src
+	endwhile
+endfunction
+
+function objs_align(sd sz)
+#must import the align from ocomp
+	const elf_sec_obj_align_trail=elf_sec_obj_align-1
+	add sz (elf_sec_obj_align_trail)
+	and sz (~elf_sec_obj_align_trail)
+	return sz
+endfunction
--- ocompiler-1.orig/src/files/actions/fileformat/elf_resolve.s
+++ ocompiler-1/src/files/actions/fileformat/elf_resolve.s
@@ -312,14 +312,14 @@ Else
 
 	Data elf_sec_flags_data=SHF_WRITE|SHF_ALLOC
 	Set elf_sec_fileoff elf32_phdr_p_offset_data
-	SetCall errormsg elfaddsec(datastrtab,SHT_PROGBITS,elf_sec_flags_data,elf_sec_fileoff,ptrdatasec,null,null,dwordsize,null)
+	SetCall errormsg elfaddsec(datastrtab,SHT_PROGBITS,elf_sec_flags_data,elf_sec_fileoff,ptrdatasec,null,null,(elf_sec_obj_align),null)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
 
 	Data elf_sec_flags_text=SHF_ALLOC|SHF_EXECINSTR
 	Add elf_sec_fileoff datasecReg
-	SetCall errormsg elfaddsec(codestrtab,SHT_PROGBITS,elf_sec_flags_text,elf_sec_fileoff,ptrcodesec,null,null,dwordsize,null)
+	SetCall errormsg elfaddsec(codestrtab,SHT_PROGBITS,elf_sec_flags_text,elf_sec_fileoff,ptrcodesec,null,null,(elf_sec_obj_align),null)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
--- ocompiler-1.orig/src/files/actions/main/index.s
+++ ocompiler-1/src/files/actions/main/index.s
@@ -89,7 +89,7 @@ if loop==1
 						ElseIf commandset==(cPRIMSEC)
 						ElseIf commandset==(cONEARG)
 						Elseif commandset==(cCALL)
-						#at object is difficult, there is no virtual, ostrip will use: ld...-Tdata calculated, objcopy --update-section, write memsize
+						#at object is difficult, there is no virtual, ostrip is in the project
 						elseIf commandset==(cIMPORTLINK) #needing importx here
 						elseif commandset==(cSTARTFUNCTION);elseif commandset==(cENDFUNCTION)
 						ElseIf commandset==(cLIBRARY)
@@ -100,7 +100,8 @@ if loop==1
 						else;set commandset (cCOMMENT);endelse
 					else
 					#pass_calls
-						if commandset==(cCALL);elseif commandset==(cENDFUNCTION);elseif commandset==(cINCLUDE)
+						If commandset==(cPRIMSEC);elseif commandset==(cCALL)
+						elseif commandset==(cENDFUNCTION);elseif commandset==(cINCLUDE)
 						else;set commandset (cCOMMENT);endelse
 					endelse
 				endif
@@ -179,7 +180,8 @@ if loop==1
 							Call advancecursors(pcontent,pcomsize,comsize)
 						endelse
 					elseIf was_whitespaces==(TRUE)
-						if parses==(pass_write)
+						if dot_comma_end==0
+						#parses (pass_write)
 							setcall errormsg warn_hidden_whitespaces(includes,nameofstoffile)
 						endif
 					endelseIf
--- ocompiler-1.orig/src/files/actions/main/index/primsec.s
+++ ocompiler-1/src/files/actions/main/index/primsec.s
@@ -1,7 +1,7 @@
 
 
-if parses==(pass_init)
-	SetCall errormsg twoargs_ex(pcontent,pcomsize,subtype,null,(allow_later_sec))
+if parses!=(pass_write)
+	SetCall errormsg twoargs_ex(pcontent,pcomsize,subtype,null,(allow_later_sec),parses)
 else
 	call entryscope_verify_code()
 	SetCall errormsg twoargs(pcontent,pcomsize,subtype,null)
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ ocompiler-1/src/files/functions/actions/argstwo.s
@@ -1,12 +1,12 @@
 
 #err
 Function twoargs(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition)
-	sd err;setcall err twoargs_ex(ptrcontent,ptrsize,subtype,ptrcondition,(allow_no))
+	sd err;setcall err twoargs_ex(ptrcontent,ptrsize,subtype,ptrcondition,(allow_no)) #there is 1 more argument but is not used
 	return err
 endfunction
 
 #err
-Function twoargs_ex(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition,sd allowdata)
+Function twoargs_ex(sv ptrcontent,sd ptrsize,sd subtype,sd ptrcondition,sd allowdata,sd parses)
 	Data lowprim#1
 	Data ptrlowprim^lowprim
 	Data lowsec#1
@@ -46,10 +46,16 @@ Function twoargs_ex(sv ptrcontent,sd ptr
 	sd subtype_test
 
 	if allowdata==(allow_later_sec)
+		#pass_init or pass_calls
 		set subtype_test subtype;and subtype_test (x_call_flag)
 		if subtype_test==0
-			setcall errnr getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 4 more arguments but are not used
-			return errnr
+			if parses==(pass_init)
+				setcall errnr getarg(ptrcontent,ptrsize,ptrsize#,(allow_later),(FORWARD)) #there are 4 more arguments but are not used
+				return errnr
+			else
+			#skip this at pass_calls
+				Call advancecursors(ptrcontent,ptrsize,ptrsize#)
+			endelse
 		else
 			SetCall errnr parsefunction(ptrcontent,ptrsize,callfn) #there are 2 more arguments but are not used
 			return errnr
--- ocompiler-1.orig/src/files/functions/argument/arg.s
+++ ocompiler-1/src/files/functions/argument/arg.s
@@ -123,6 +123,7 @@ Function getarg(sv ptrcontent,sd ptrsize
 				#sufix is not used at imm value
 			else
 				sd argsize_filter
+				sd container_sz
 				if content#==(pointerascii)
 					#prefix
 					setcall prefix prefix_bool()
@@ -130,39 +131,25 @@ Function getarg(sv ptrcontent,sd ptrsize
 					inc content
 					set argsize_filter argsize
 					dec argsize_filter
-					SetCall errnr varsufix(content,argsize_filter,ptrdata,ptrlow,ptrsufix)
+
+					setcall container_sz valinmem(content,argsize_filter,(asciidot))
+					if container_sz!=argsize_filter
+						setcall errnr getarg_dot(content,argsize_filter,container_sz,ptrdata,ptrlow,ptrsufix)
+					else
+						SetCall errnr varsufix(content,argsize_filter,ptrdata,ptrlow,ptrsufix)
+					endelse
 					if errnr!=(noerror)
 						return errnr
 					endif
 				else
 					data ptrobject%ptrobject
 					data ptrfunctions%ptrfunctions
-					sd container_sz
 					setcall container_sz valinmem(content,argsize,(asciidot))
 					if container_sz!=argsize
-						#if is a dot
-						sd inter
-						#setcall inter vars(content,container_sz,ptrfunctions)
-						sd pos=0
-						setcall inter vars_core_ref_scope(content,container_sz,ptrfunctions,(NULL),(TRUE),#pos)
-						if inter==(NULL)
-							setcall errnr undefinedvar_fn()
-							return errnr
-						endif
-						inc container_sz
-						set argsize_filter argsize
-						call advancecursors(#content,#argsize_filter,container_sz)
-						#
-						sd scope
-						setcall scope scopes_get_scope(pos)
-						SetCall errnr varsufix_ex(content,argsize_filter,ptrdata,ptrlow,ptrsufix,scope)
+						setcall errnr getarg_dot(content,argsize,container_sz,ptrdata,ptrlow,ptrsufix)
 						if errnr!=(noerror)
 							return errnr
 						endif
-						sd test;setcall test stackbit(ptrdata#)
-						if test!=0
-							return "Stack variables are not relevant for scope.variable."
-						endif
 					elseif ptrobject#==1
 						#verify for function
 						setcall ptrdata# vars(content,argsize,ptrfunctions)
@@ -204,6 +191,36 @@ Function getarg(sv ptrcontent,sd ptrsize
 	setcall errnr restore_cursors_onok(ptrcontent,ptrsize,f,argsize)
 	return errnr
 EndFunction
+#err
+function getarg_dot(sd content,sd argsize,sd container_sz,sd ptrdata,sd ptrlow,sd ptrsufix)
+	data ptrfunctions%ptrfunctions
+	#if is a dot
+	sd inter
+	#setcall inter vars(content,container_sz,ptrfunctions)
+	sd errnr
+	sd pos=0
+	setcall inter vars_core_ref_scope(content,container_sz,ptrfunctions,(NULL),(TRUE),#pos)
+	if inter==(NULL)
+		setcall errnr undefinedvar_fn()
+		return errnr
+	endif
+	inc container_sz
+	sd argsize_filter
+	set argsize_filter argsize
+	call advancecursors(#content,#argsize_filter,container_sz)
+	#
+	sd scope
+	setcall scope scopes_get_scope(pos)
+	SetCall errnr varsufix_ex(content,argsize_filter,ptrdata,ptrlow,ptrsufix,scope)
+	if errnr!=(noerror)
+		return errnr
+	endif
+	sd test;setcall test stackbit(ptrdata#)
+	if test==0
+		return (noerror)
+	endif
+	return "Stack variables are not relevant for scope.variable."
+endfunction
 
 function function_in_code()
 	data bool#1
--- ocompiler-1.orig/src/files/functions/commons/vars.s
+++ ocompiler-1/src/files/functions/commons/vars.s
@@ -35,10 +35,11 @@ function vars_core_ref_scope(ss content,
 	Call getcontandcontReg(ptrstructure,ptrcontainer,ptrcontainerReg)
 	Data entrypoint#1
 
-	While containerReg>zero
+	sd end;set end container
+	add end containerReg
+	While container!=end
 		Set entrypoint container
 		Add container dwlen
-		Sub containerReg dwlen
 		If warningssearch!=(NULL)
 			Data ReferenceBit=referencebit
 			Data checkvalue#1
@@ -75,18 +76,17 @@ function vars_core_ref_scope(ss content,
 			#elseIf ptrconstants==ptrstructure 0x72
 		EndIf
 		Add container dwlen
-		Sub containerReg dwlen
 		SetCall varsize strlen(container)
 		If warningssearch==(NULL)
 			If varsize==size
 				Data cmpret#1
 				SetCall cmpret memcmp(container,content,size)
 				If cmpret==zero
-					#go back from string to mask
-					Sub container dwlen
-
 					#if set the reference is true
 					if setref==1
+						#go back from string to mask
+						Sub container dwlen
+
 						#get the value and change the reference bit of the mask to true
 						Data value#1
 						Set value container#
@@ -99,12 +99,19 @@ function vars_core_ref_scope(ss content,
 				EndIf
 			EndIf
 			if position_pointer!=(NULL)
-				inc position_pointer#
+				#are mixed with imports
+				#go back from string to mask
+				sd against=idatabitfunction
+				sd back=-dwsz
+				add back container
+				and against back#
+				if against==0
+					inc position_pointer#
+				endif
 			endif
 		EndIf
 		Add varsize blen
 		Add container varsize
-		Sub containerReg varsize
 	EndWhile
 	Return zero
 endfunction
--- ocompiler-1.orig/src/files/functions/elf/elf.s
+++ ocompiler-1/src/files/functions/elf/elf.s
@@ -58,7 +58,7 @@ function elfaddsec_base(sd stringname,sd
 
 	Const SHT_NULL=0
 	Const SHT_PROGBITS=1
-	Const SHT_NOBITS=8
+	#Const SHT_NOBITS=8
 
 	const SHF_WRITE=1
 		#Occupies memory during execution,1 << 1
@@ -68,14 +68,16 @@ function elfaddsec_base(sd stringname,sd
 		#`sh_info' contains SHT index,1 << 6
 	#Const SHF_INFO_LINK=2*6
 
-	Data SHT_PROGBITS=SHT_PROGBITS
-	Data SHT_NOBITS=SHT_NOBITS
-	Data zero=0
-	If type==SHT_PROGBITS
-		If bsize==zero
-			Set type SHT_NOBITS
-		EndIf
-	EndIf
+	#A section of SHT_NOBITS may have a non-zero size, but it occupies no space in the file
+	#and ld is warning it, so why was here in the first place?
+	#Data SHT_PROGBITS=SHT_PROGBITS
+	#Data SHT_NOBITS=SHT_NOBITS
+	#Data zero=0
+	#If type==SHT_PROGBITS
+	#	If bsize==zero
+	#		Set type SHT_NOBITS
+	#	EndIf
+	#EndIf
 
 	Data err#1
 	#is false at inits, no worry about only at object
@@ -120,9 +122,9 @@ Function elfaddstrsec(data stringofname,
 EndFunction
 
 #err
-Function elfaddsym(data stringoff,data value,data size,chars type,chars bind,data index,data struct)
-	sd st_info
-	Set st_info type
+Function elfaddsym(data stringoff,data value,data size,chars st_info,chars bind,data index,data struct)
+#	sd st_info
+#	Set st_info type
 const elf_sym_st_info_tohibyte=16
 	Mult bind (elf_sym_st_info_tohibyte)
 	Or st_info bind
@@ -159,9 +161,7 @@ const elf_sym_st_info_tohibyte=16
 		Data elf32_sym_st_size#1
 		#Symbol type and binding
 		Const STB_LOCAL=0
-		Const STB_GLOBAL=1
 		Const STB_WEAK=2
-		Const STT_NOTYPE=0
 		Const STT_FUNC=2
 		Const STT_SECTION=3
 	#const elf32_sym_st_info_offset=3*dwsz
@@ -208,7 +208,6 @@ Data STT_NOTYPE=STT_NOTYPE
 Data STT_FUNC=STT_FUNC
 Data STT_SECTION=STT_SECTION
 
-Const dataind=1
 Const codeind=2
 Const symind=3
 Data datastrtab#1
@@ -229,7 +228,6 @@ Data codestrtab#1
 Function addrel_base(sd offset,sd symbolindex,sd addend,sd struct)
 	#Direct 32 bit
 	Const R_386_32=1
-	const R_X86_64_64=1
 	const R_X86_64_32=10
 	#PC relative 32 bit
 	#const R_386_PC32=2
--- ocompiler-1.orig/src/files/headers.h
+++ ocompiler-1/src/files/headers.h
@@ -4,7 +4,10 @@
 #headers
 Include "./headers/ascii.h"
 Include "./headers/commons.h"
+
 Include "./headers/log.h"
+Include "./headers/strip.h"
+
 Include "./headers/header.h"
 Include "./headers/asm.h"
 Include "./headers/pe_format.h"
--- ocompiler-1.orig/src/files/headers/header.h
+++ ocompiler-1/src/files/headers/header.h
@@ -436,3 +436,6 @@ const getarg_str=asciidoublequote
 
 Data datasecSize#1
 const ptrdataSize^datasecSize
+
+#x
+const log_expand=0x78
--- ocompiler-1.orig/src/files/headers/log.h
+++ ocompiler-1/src/files/headers/log.h
@@ -21,7 +21,5 @@ const log_declare=0x64
 #r
 const log_reusable=0x72
 
-warning off
 #x
-const log_expand=0x78
-warning on
+#ostrip is reading only with fseek, ounused can skip 0-9 instead of x, but in code is log with a char
--- /dev/null
+++ ocompiler-1/src/files/headers/strip.h
@@ -0,0 +1,9 @@
+
+
+const datasize=4
+const elf_sec_obj_align=datasize
+const R_X86_64_64=1
+Const dataind=1
+
+Const STB_GLOBAL=1
+Const STT_NOTYPE=0
