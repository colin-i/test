Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-3.23) bionic; urgency=medium
 .
   * for 64 obj64
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2021-11-09

--- ocompiler-1.orig/Makefile
+++ ocompiler-1/Makefile
@@ -8,9 +8,11 @@ FULLOBJO = $(FULLOBJ).o
 OBT = $(OB).txt
 
 %.o: ${FULLOBJS}
-	-if [ -s $(OBT) ];then base64 -d $(OBT) > $@;else o $<;fi
+	if [ -s $(OBT) ];then base64 -d $(OBT) > $@;else o $<;fi
 
-ATLDCOM = $(LD) -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc
+syms =-s
+ATLDCOM = $(LD) ${syms} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc
+#gcc -Wl,-melf_i386 -nostdlib "./src/linux/obj.o" -o "./buildg/o" -lc
 
 o: $(OBJ)
 	if [ -f ${OBJ} ];then $(ATLDCOM) $^;else $(ATLDCOM) ${FULLOBJO};fi
--- ocompiler-1.orig/ReadMe.old.txt
+++ ocompiler-1/ReadMe.old.txt
@@ -35,10 +35,6 @@ make.bat
 
 - Windows bat file to compile the source for executable; the output file will be in the './build/' folder
 
-make_lin_gnu
-
-- Linux shell file to compile the source and to link it with gcc (mingw binutils tools); the output file will be in the './buildg/' folder
-
 make_win32_fromLin_gnu
 
 - Linux shell file to compile the source and to link it with mingw-w64-i686 for linux; the output file will be 'ocompiler.zip'
--- ocompiler-1.orig/make_win64_fromLin_gnu
+++ ocompiler-1/make_win64_fromLin_gnu
@@ -1,3 +1,7 @@
+
+#is old staying for information
+exit
+
 #########
 #the build is working
 #attention at GetCommandNameA to not return a 64 bit pointer and at realloc
--- ocompiler-1.orig/o.html
+++ ocompiler-1/o.html
@@ -248,7 +248,7 @@
 	</p>
 <br>
 	<p>
-	Operations can be performed at declarations with arithmetic (+,-,*,/) and bitwise (&,|,^) signs.
+	Operations can be performed at declarations with arithmetic (+,-,*,/,$) and bitwise (&,|,^) signs.
 	<br>
 	Example:
 	<br>
@@ -697,7 +697,7 @@
 	</p>
   </div>
   <div>
-	32-bit objects with some 64-bit code commands for Microsoft calling convention can be created by adding <b>64Microsoft</b> at <i>Format ElfObj</i>.<br>
+	64-bit objects with some 64-bit code commands for Microsoft calling convention can be created by adding <b>64Microsoft</b> at <i>Format ElfObj</i>.<br>
 	To call with Microsoft calling convention use <b>ImportX</b>. To set the 64-bit return value use <b>SetX</b>. To prepare 64-bit convention function entry use <b>FunctionX</b>.
 	<p>
 	Example:
--- ocompiler-1.orig/src/files/actions/fileformat/elf_resolve.s
+++ ocompiler-1/src/files/actions/fileformat/elf_resolve.s
@@ -27,23 +27,225 @@ If object==false
 	#######
 	Set elf32_ehd_e_phoff elf_fileheaders_size
 	#######
-	Set elf32_ehd_e_shoff null
-	#######
 	Data elf_sections_start_count=2
 	data ptrelf_sections_start_count^elf_sections_start_count
 	call memtomem(ptrelf32_ehd_e_phnum,ptrelf_sections_start_count,wordsize)
 	#######
-	call memtomem(ptrelf32_ehd_e_shnum,ptrnull,wordsize)
-	#######
-	call memtomem(ptrelf32_ehd_e_shstrndx,ptrnull,wordsize)
-	#######
 
 	#commons#
 	Set virtuallocalsoffset elf32_phdr_p_vaddr_code
+	Set fileheaders elf_fileheaders
+	Set sizefileheaders elf_fileheaders_size
 	#commons#
+
+	if implibsstarted==false
+		call memtomem(ptrelf32_ehd_e_shnum,#one,wordsize)
+		#######
+		call memtomem(ptrelf32_ehd_e_shstrndx,ptrnull,wordsize)
+	else
+		call memtomem(ptrelf32_ehd_e_shnum,#three,wordsize)
+		#######
+		#add here, next will be calculations and these will be above
+		data secstrs_off_atnames#1
+		setcall errormsg addtonames(ptrnull,#secstrs_off_atnames)
+		chars dynstr_c=".dynstr";data dynstr#1
+		#shstrtab
+		setcall errormsg addtonames(#dynstr_c,#dynstr)
+		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+		chars dynsec_c=".dynamic";data dynsec#1
+		setcall errormsg addtonames(#dynsec_c,#dynsec)
+		If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+		#
+		call memtomem(ptrelf32_ehd_e_shstrndx,#one,wordsize)
+
+		#imports
+		#If implibsstarted==true
+		#interpreter
+		Inc elf32_ehd_e_phnum
+	
+		Set elf32_phdr_p_offset_interp elf32_phdr_p_offset_code
+		Add elf32_phdr_p_offset_interp codesecReg
+	
+		Set elf32_phdr_p_vaddr_interp elf32_phdr_p_vaddr_code
+		Add elf32_phdr_p_vaddr_interp codesecReg
+		#SetCall elf32_phdr_p_vaddr_interp congruentmoduloatsegments(elf32_phdr_p_vaddr_interp,elf32_phdr_p_offset_interp,page_sectionalignment,codesecReg)
+	
+		Set elf32_phdr_p_paddr_interp elf32_phdr_p_vaddr_interp
+	
+		SetCall interpretersize strlen(ptrinterpreter)
+		Inc interpretersize
+	
+		Set elf32_phdr_p_filesz_interp interpretersize
+		Set elf32_phdr_p_memsz_interp interpretersize
+	
+		#dynamic
+		Inc elf32_ehd_e_phnum
+		
+		Set elf32_phdr_p_offset_dyn elf32_phdr_p_offset_interp
+		Add elf32_phdr_p_offset_dyn interpretersize
+	
+		Set elf32_phdr_p_vaddr_dyn elf32_phdr_p_vaddr_interp
+		Add elf32_phdr_p_vaddr_dyn interpretersize
+	
+		Set elf32_phdr_p_paddr_dyn elf32_phdr_p_vaddr_dyn
+	
+		Set elf32_phdr_p_filesz_dyn tableReg
+		Add elf32_phdr_p_filesz_dyn elf_dynfix_size
+	
+		Set elf32_phdr_p_memsz_dyn elf32_phdr_p_filesz_dyn
+	
+		#libraries load
+		Inc elf32_ehd_e_phnum
+	
+		Set elf32_phdr_p_offset_lib elf32_phdr_p_offset_dyn
+		Add elf32_phdr_p_offset_lib elf32_phdr_p_filesz_dyn
+	
+		set elf32_phdr_p_vaddr_lib elf32_phdr_p_vaddr_dyn
+		Add elf32_phdr_p_vaddr_lib elf32_phdr_p_filesz_dyn
+	
+		data test1#1
+		data test2#1
+		set test1 elf32_phdr_p_vaddr_interp
+		div test1 page_sectionalignment
+		set test2 elf32_phdr_p_vaddr_lib
+		div test2 page_sectionalignment
+		if test2==test1
+			add elf32_phdr_p_vaddr_lib page_sectionalignment
+		endif
+	
+		Set elf32_phdr_p_paddr_lib elf32_phdr_p_vaddr_lib
+	
+		##resolve libraries
+		###hash
+		Set elf32_dyn_d_ptr_hash elf32_phdr_p_vaddr_lib
+	
+		#
+		Set elf32_phdr_p_filesz_lib elf_hash_minsize
+		#
+	
+		Set sizeofchain addressesReg
+		Div sizeofchain elf32_dyn_d_val_syment
+	
+		## '## '=import command dependent
+		Data loopsymbols#1
+		Data ptrloopsymbols^loopsymbols
+		Set loopsymbols zero
+		While loopsymbols<sizeofchain
+			SetCall errormsg addtosec(ptrloopsymbols,dwordsize,ptrmiscbag)
+			If errormsg!=noerr
+				Call msgerrexit(errormsg)
+			EndIf
+			Inc loopsymbols
+		EndWhile
+		##
+		Set hash_var_size miscbagReg
+	
+		#
+		Add elf32_phdr_p_filesz_lib hash_var_size
+		#
+	
+		###symtab
+		Set elf32_dyn_d_ptr_symtab elf32_dyn_d_ptr_hash
+		Add elf32_dyn_d_ptr_symtab elf_hash_minsize
+		Add elf32_dyn_d_ptr_symtab hash_var_size
+		
+		#
+		Add elf32_phdr_p_filesz_lib addressesReg
+		#
+	
+		###strtab
+		Set elf32_dyn_d_ptr_strtab elf32_dyn_d_ptr_symtab
+		Add elf32_dyn_d_ptr_strtab addressesReg
+	
+		###strsz
+		Set elf32_dyn_d_val_strsz namesReg
+	
+		#stroff
+		data elf_str_offset#1
+		set elf_str_offset elf32_phdr_p_offset_lib
+		add elf_str_offset elf32_phdr_p_filesz_lib
+	
+		#
+		Add elf32_phdr_p_filesz_lib namesReg
+		#
+	
+		###rel
+		Set elf32_dyn_d_ptr_rel elf32_dyn_d_ptr_strtab
+		Add elf32_dyn_d_ptr_rel namesReg
+	
+		###relsz
+		
+		Set elf32_dyn_d_val_relsz sizeofchain
+	
+		Mult elf32_dyn_d_val_relsz elf32_dyn_d_val_relent
+	
+		#
+		Add elf32_phdr_p_filesz_lib elf32_dyn_d_val_relsz
+		#
+	
+		##
+		Data elf_rel_offset#1
+		Chars elf_rel_info_type={R_386_32}
+		Data elf_rel_info_symbolindex#1
+	
+		Set elf_rel_offset elf32_dyn_d_ptr_rel
+		Add elf_rel_offset elf32_dyn_d_val_relsz
+		Set elf_rel_info_symbolindex zero
+	
+		While elf_rel_info_symbolindex<sizeofchain
+			SetCall errormsg addrel(elf_rel_offset,elf_rel_info_type,elf_rel_info_symbolindex,ptrmiscbag)
+			If errormsg!=noerr
+				Call msgerrexit(errormsg)
+			EndIf
+			Inc elf_rel_info_symbolindex
+			Add elf_rel_offset dwordsize
+		EndWhile
+		##
+	
+		Set rel_var_size miscbagReg
+		Sub rel_var_size hash_var_size
+		
+		Set elf_rel_entries_size sizeofchain
+		Mult elf_rel_entries_size dwordsize
+	
+		SetCall errormsg addtosec(null,elf_rel_entries_size,ptrmiscbag)
+		If errormsg!=noerr
+			Call msgerrexit(errormsg)
+		EndIf
+	
+		Data el_rel_entries_loop#1
+		Set el_rel_entries_loop miscbag
+		Add el_rel_entries_loop miscbagReg
+		Set loopsymbols zero
+		While loopsymbols<sizeofchain
+			Sub el_rel_entries_loop dwordsize
+			Set el_rel_entries_loop# zero
+			Inc loopsymbols
+		EndWhile
+	
+		#commons#
+		Set importfileheaders elf_importfileheaders
+		Set sizeimportfileheaders elf_importfileheaders_size
+	
+		Set virtualimportsoffset elf32_phdr_p_vaddr_lib
+		Add virtualimportsoffset elf32_phdr_p_filesz_lib
+		#commons#
+	
+		#
+		Add elf32_phdr_p_filesz_lib elf_rel_entries_size
+		#
+	
+		Set elf32_phdr_p_memsz_lib elf32_phdr_p_filesz_lib
+	endelse
+
+	#######some section/s for readelf
+	sd sections_start=elf32_ehd_e_phentsize
+	mult sections_start elf32_ehd_e_phnum
+	add sections_start elf_fileheaders_size
+	call memtomem(ptrelf32_ehd_e_shoff,#sections_start,wordsize)
 Else
 	#######
-	Data ET_REL=1
+	Data ET_REL=ET_REL
 	Data ptrET_REL^ET_REL
 	Call memtomem(ptrelf32_ehd_e_type,ptrET_REL,wordsize)
 	#######
@@ -51,25 +253,38 @@ Else
 	#######
 	Set elf32_ehd_e_phoff null
 	#######
-	Set elf32_ehd_e_shoff elf_fileheaders_size
-	#######
 	call memtomem(ptrelf32_ehd_e_phnum,ptrnull,wordsize)
 	#######
 	Const elf_sec_nr=7
 	Const elf_sec_strtab_nr=elf_sec_nr-1
 	Data elf_sec_nr=elf_sec_nr
 	data ptrelf_sec_nr^elf_sec_nr
-	call memtomem(ptrelf32_ehd_e_shnum,ptrelf_sec_nr,wordsize)
 	#######
 	Data elf_sec_strtab_nr=elf_sec_strtab_nr
 	data ptrelf_sec_strtab_nr^elf_sec_strtab_nr
-	call memtomem(ptrelf32_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
 	#######
 
+	sd syment;sd relent
+	if p_is_for_64_resp#==(TRUE)
+		Set elf64_ehd_e_shoff (elf64_fileheaders_size)
+		call memtomem(#elf64_ehd_e_shnum,ptrelf_sec_nr,wordsize)
+		call memtomem(#elf64_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
+		Set fileheaders #elf64_ehd_e_ident_sign
+		Set sizefileheaders (elf64_fileheaders_size)
+		set syment (elf64_dyn_d_val_syment);set relent (elf64_dyn_d_val_relent)
+	else
+		Set elf32_ehd_e_shoff elf_fileheaders_size
+		call memtomem(ptrelf32_ehd_e_shnum,ptrelf_sec_nr,wordsize)
+		call memtomem(ptrelf32_ehd_e_shstrndx,ptrelf_sec_strtab_nr,wordsize)
+		Set fileheaders elf_fileheaders
+		Set sizefileheaders elf_fileheaders_size
+		set syment elf32_dyn_d_val_syment;set relent elf32_dyn_d_val_relent
+	endelse
+
 	Data SHT_PROGBITS=SHT_PROGBITS
 	Data elf_sec_fileoff#1
 
-	SetCall errormsg elfaddsec(null,null,null,null,null,null,null,null,null)
+	SetCall errormsg elfaddsecn()
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
@@ -94,230 +309,37 @@ Else
 	Add elf_sec_fileoff codesecReg
 	Data oneGreaterThanLastSTB_LOCAL=oneGreaterThanLastSTB_LOCAL
 
-	SetCall errormsg elfaddstrsec(ptrelfsymtab,SHT_SYMTAB,null,elf_sec_fileoff,ptrtable,elf_sec_strtab_nr,oneGreaterThanLastSTB_LOCAL,dwordsize,elf32_dyn_d_val_syment)
+	SetCall errormsg elfaddstrsec(ptrelfsymtab,SHT_SYMTAB,null,elf_sec_fileoff,ptrtable,elf_sec_strtab_nr,oneGreaterThanLastSTB_LOCAL,dwordsize,syment)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
 
-	Data SHT_REL=9
+	Data SHT_RELA=4
 	Data symind=symind
 
-	Chars elfreldata=".rel.data"
+	Chars elfreldata=".rela.data"
 	Str ptrelfreldata^elfreldata
 	Add elf_sec_fileoff tableReg
-	SetCall errormsg elfaddstrsec(ptrelfreldata,SHT_REL,null,elf_sec_fileoff,ptraddresses,symind,dataind,dwordsize,elf32_dyn_d_val_relent)
+	SetCall errormsg elfaddstrsec(ptrelfreldata,SHT_RELA,null,elf_sec_fileoff,ptraddresses,symind,dataind,dwordsize,relent)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
 
-	Chars elfreltxt=".rel.text"
+	Chars elfreltxt=".rela.text"
 	Str ptrelfreltxt^elfreltxt
 	Add elf_sec_fileoff addressesReg
-	SetCall errormsg elfaddstrsec(ptrelfreltxt,SHT_REL,null,elf_sec_fileoff,ptrextra,symind,codeind,dwordsize,elf32_dyn_d_val_relent)
+	SetCall errormsg elfaddstrsec(ptrelfreltxt,SHT_RELA,null,elf_sec_fileoff,ptrextra,symind,codeind,dwordsize,relent)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
 
 	Chars elfstrtab=".strtab"
 	Str ptrelfstrtab^elfstrtab
-	Data SHT_STRTAB=3
 	Add elf_sec_fileoff extraReg
-	SetCall errormsg elfaddstrsec(ptrelfstrtab,SHT_STRTAB,null,elf_sec_fileoff,ptrnames,null,null,bytesize,null)
+	SetCall errormsg elfaddstrsec(ptrelfstrtab,(SHT_STRTAB),null,elf_sec_fileoff,ptrnames,null,null,bytesize,null)
 	If errormsg!=noerr
 		Call msgerrexit(errormsg)
 	EndIf
 
 	Set startofdata elf_startofdata
 EndElse
-
-#commons#
-Set fileheaders elf_fileheaders
-Set sizefileheaders elf_fileheaders_size
-#commons#
-
-#imports
-If implibsstarted==true
-	#interpreter
-	Inc elf32_ehd_e_phnum
-
-	Set elf32_phdr_p_offset_interp elf32_phdr_p_offset_code
-	Add elf32_phdr_p_offset_interp codesecReg
-
-	Set elf32_phdr_p_vaddr_interp elf32_phdr_p_vaddr_code
-	Add elf32_phdr_p_vaddr_interp codesecReg
-	#SetCall elf32_phdr_p_vaddr_interp congruentmoduloatsegments(elf32_phdr_p_vaddr_interp,elf32_phdr_p_offset_interp,page_sectionalignment,codesecReg)
-
-	Set elf32_phdr_p_paddr_interp elf32_phdr_p_vaddr_interp
-
-	SetCall interpretersize strlen(ptrinterpreter)
-	Inc interpretersize
-
-	Set elf32_phdr_p_filesz_interp interpretersize
-	Set elf32_phdr_p_memsz_interp interpretersize
-
-	#dynamic
-	Inc elf32_ehd_e_phnum
-	
-	Set elf32_phdr_p_offset_dyn elf32_phdr_p_offset_interp
-	Add elf32_phdr_p_offset_dyn interpretersize
-
-	Set elf32_phdr_p_vaddr_dyn elf32_phdr_p_vaddr_interp
-	Add elf32_phdr_p_vaddr_dyn interpretersize
-
-	Set elf32_phdr_p_paddr_dyn elf32_phdr_p_vaddr_dyn
-
-	Set elf32_phdr_p_filesz_dyn tableReg
-	Add elf32_phdr_p_filesz_dyn elf_dynfix_size
-
-	Set elf32_phdr_p_memsz_dyn elf32_phdr_p_filesz_dyn
-
-	#libraries load
-	Inc elf32_ehd_e_phnum
-
-	Set elf32_phdr_p_offset_lib elf32_phdr_p_offset_dyn
-	Add elf32_phdr_p_offset_lib elf32_phdr_p_filesz_dyn
-
-	set elf32_phdr_p_vaddr_lib elf32_phdr_p_vaddr_dyn
-	Add elf32_phdr_p_vaddr_lib elf32_phdr_p_filesz_dyn
-
-	data test1#1
-	data test2#1
-	set test1 elf32_phdr_p_vaddr_interp
-	div test1 page_sectionalignment
-	set test2 elf32_phdr_p_vaddr_lib
-	div test2 page_sectionalignment
-	if test2==test1
-		add elf32_phdr_p_vaddr_lib page_sectionalignment
-	endif
-
-	Set elf32_phdr_p_paddr_lib elf32_phdr_p_vaddr_lib
-
-	##resolve libraries
-	###hash
-	Set elf32_dyn_d_ptr_hash elf32_phdr_p_vaddr_lib
-
-	#
-	Set elf32_phdr_p_filesz_lib elf_hash_minsize
-	#
-
-	Set sizeofchain addressesReg
-	Div sizeofchain elf32_dyn_d_val_syment
-
-	## '## '=import command dependent
-	Data loopsymbols#1
-	Data ptrloopsymbols^loopsymbols
-	Set loopsymbols zero
-	While loopsymbols<sizeofchain
-		SetCall errormsg addtosec(ptrloopsymbols,dwordsize,ptrmiscbag)
-		If errormsg!=noerr
-			Call msgerrexit(errormsg)
-		EndIf
-		Inc loopsymbols
-	EndWhile
-	##
-	Set hash_var_size miscbagReg
-
-	#
-	Add elf32_phdr_p_filesz_lib hash_var_size
-	#
-
-	###symtab
-	Set elf32_dyn_d_ptr_symtab elf32_dyn_d_ptr_hash
-	Add elf32_dyn_d_ptr_symtab elf_hash_minsize
-	Add elf32_dyn_d_ptr_symtab hash_var_size
-	
-	#
-	Add elf32_phdr_p_filesz_lib addressesReg
-	#
-
-	###strtab
-	Set elf32_dyn_d_ptr_strtab elf32_dyn_d_ptr_symtab
-	Add elf32_dyn_d_ptr_strtab addressesReg
-
-	###strsz
-	Set elf32_dyn_d_val_strsz namesReg
-
-	#
-	Add elf32_phdr_p_filesz_lib namesReg
-	#
-
-	###rel
-	Set elf32_dyn_d_ptr_rel elf32_dyn_d_ptr_strtab
-	Add elf32_dyn_d_ptr_rel namesReg
-
-	###relsz
-	Set elf32_dyn_d_val_relsz sizeofchain
-
-	Mult elf32_dyn_d_val_relsz elf32_dyn_d_val_relent
-
-	#
-	Add elf32_phdr_p_filesz_lib elf32_dyn_d_val_relsz
-	#
-
-	##
-	Data elf_rel_offset#1
-	Chars elf_rel_info_type={R_386_32}
-	Data elf_rel_info_symbolindex#1
-
-	Set elf_rel_offset elf32_dyn_d_ptr_rel
-	Add elf_rel_offset elf32_dyn_d_val_relsz
-	Set elf_rel_info_symbolindex zero
-
-	While elf_rel_info_symbolindex<sizeofchain
-		SetCall errormsg addrel(elf_rel_offset,elf_rel_info_type,elf_rel_info_symbolindex,ptrmiscbag)
-		If errormsg!=noerr
-			Call msgerrexit(errormsg)
-		EndIf
-		Inc elf_rel_info_symbolindex
-		Add elf_rel_offset dwordsize
-	EndWhile
-	##
-
-	Set rel_var_size miscbagReg
-	Sub rel_var_size hash_var_size
-	
-	Set elf_rel_entries_size sizeofchain
-	Mult elf_rel_entries_size dwordsize
-
-	SetCall errormsg addtosec(null,elf_rel_entries_size,ptrmiscbag)
-	If errormsg!=noerr
-		Call msgerrexit(errormsg)
-	EndIf
-
-	Data el_rel_entries_loop#1
-	Set el_rel_entries_loop miscbag
-	Add el_rel_entries_loop miscbagReg
-	Set loopsymbols zero
-	While loopsymbols<sizeofchain
-		Sub el_rel_entries_loop dwordsize
-		Set el_rel_entries_loop# zero
-		Inc loopsymbols
-	EndWhile
-
-	#commons#
-	Set importfileheaders elf_importfileheaders
-	Set sizeimportfileheaders elf_importfileheaders_size
-
-	Set virtualimportsoffset elf32_phdr_p_vaddr_lib
-	Add virtualimportsoffset elf32_phdr_p_filesz_lib
-	#commons#
-
-	#
-	Add elf32_phdr_p_filesz_lib elf_rel_entries_size
-	#
-
-	Set elf32_phdr_p_memsz_lib elf32_phdr_p_filesz_lib
-
-
-
-	
-	#sub elf32_phdr_p_offset_lib elf32_phdr_p_filesz_interp
-	#sub elf32_phdr_p_offset_lib elf32_phdr_p_filesz_dyn
-
-	#add elf32_phdr_p_filesz_lib elf32_phdr_p_filesz_interp
-	#add elf32_phdr_p_filesz_lib elf32_phdr_p_filesz_dyn
-
-	#Set elf32_phdr_p_paddr_lib elf32_phdr_p_vaddr_lib
-	#Set elf32_phdr_p_memsz_lib elf32_phdr_p_filesz_lib
-EndIf
-
--- ocompiler-1.orig/src/files/actions/main/index/aftercall.s
+++ ocompiler-1/src/files/actions/main/index/aftercall.s
@@ -34,7 +34,12 @@ else
 	if errormsg==(noerror)
 		set g_e_b_p# (TRUE)
 		if object==(TRUE)
-			set g_e_p# tableReg;div g_e_p# elf32_dyn_d_val_syment
+			set g_e_p# tableReg
+			if p_is_for_64_resp#==(TRUE)
+				div g_e_p# (elf64_dyn_d_val_syment)
+			else
+				div g_e_p# elf32_dyn_d_val_syment
+			endelse
 			#adding at current names reg the content lenghting comsize
 			SetCall errormsg elfaddstrszsym(ac_store_content,ac_store_size,acsym_value,acsym_size,(STT_NOTYPE),(STB_GLOBAL),acsym_shndx,ptrtable)
 		endif
--- ocompiler-1.orig/src/files/actions/main/index/callex.s
+++ ocompiler-1/src/files/actions/main/index/callex.s
@@ -52,7 +52,7 @@ if errormsg==(noerror)
 					#dec ecx
 					chars *=0xFF;chars *=1*toregopcode|ecxregnumber|0xc0
 				const callex_size1=!-callex_start
-					# mov edx,[eax+ecx*4]
+					# mov [eax+ecx*4],edx
 					chars callex_c2=0x8b;chars *=edxregnumber*toregopcode|4;chars callex_sib#1
 					#push e(r)dx
 					chars *=0x52
--- ocompiler-1.orig/src/files/actions/main/index/import.s
+++ ocompiler-1/src/files/actions/main/index/import.s
@@ -11,8 +11,8 @@ Data impescapes=0
 Data ptrimpquotsz^impquotsz
 Data ptrimpescapes^impescapes
 
-If implibsstarted==false
-	If object==false
+If object==false
+	If implibsstarted==false
 		Chars noliberr="Unexpected IMPORT statement; there is no LIBRARY opened."
 		Str ptrnoliberr^noliberr
 		Set errormsg ptrnoliberr
@@ -37,12 +37,16 @@ If errormsg==noerr
 			Set functionoffset tableReg
 		EndElse
 		#get the function index
-		Div functionoffset elf32_dyn_d_val_syment
 		If object==false
+			Div functionoffset elf32_dyn_d_val_syment
 			#get the dword offset to call at, index*dword
 			Mult functionoffset dwordsize
 			SetCall errormsg elfaddsym(namesReg,null,null,STT_FUNC,STB_GLOBAL,null,ptraddresses)
-		EndIf
+		ElseIf p_is_for_64_resp#==(TRUE)
+			div functionoffset (elf64_dyn_d_val_syment)
+		Else
+			Div functionoffset elf32_dyn_d_val_syment
+		EndElse
 	EndElse
 	If errormsg==noerr
 		SetCall errormsg quotinmem(pcontent,pcomsize,ptrimpquotsz,ptrimpescapes)
--- ocompiler-1.orig/src/files/actions/main/index/library.s
+++ ocompiler-1/src/files/actions/main/index/library.s
@@ -29,11 +29,21 @@ EndElse
 If errormsg==noerr
 	SetCall errormsg quotinmem(pcontent,pcomsize,ptrlibquotsz,ptrlibescapes)
 	If errormsg==noerr
+		#if implibsstarted==false
+		#	If fileformat==elf_unix
+		#		#the first section to be null
+		#		SetCall errormsg elfaddstrsec(ptrnull,null,0,0,null,null,0,0,0,0)
+		#		#reset miscbag used at resolve maybe
+		#		set miscbagReg 0
+		#	endif
+		#endif
+		#If errormsg==noerr
 		SetCall errormsg addtosecstresc(pcontent,pcomsize,libquotsz,libescapes,ptrnames,true)
 		If errormsg==noerr
 			Call stepcursors(pcontent,pcomsize)
 			Set implibsstarted true
 		EndIf
+		#endif
 	EndIf
 EndIf
 
--- ocompiler-1.orig/src/files/actions/write.s
+++ ocompiler-1/src/files/actions/write.s
@@ -25,22 +25,48 @@ If fileformat==elf_unix
 			Call errexit()
 		EndIf
 		Add sizefileheaders elf_progdeffileheaders_size
+		If implibsstarted==true
+			SetCall writeres writefile(fileout,importfileheaders,sizeimportfileheaders)
+			If writeres==writefalse
+				Call errexit()
+			EndIf
+			Add sizefileheaders sizeimportfileheaders
+		EndIf
 	Else
 		SetCall writeres writefile(fileout,miscbag,miscbagReg)
 		If writeres==writefalse
 			Call errexit()
 		EndIf
 		Add sizefileheaders miscbagReg
-		Set miscbagReg zero
+		#cannot see why i set this zero
+		#Set miscbagReg zero
 	EndElse
 EndIf
-If implibsstarted==true
-	SetCall writeres writefile(fileout,importfileheaders,sizeimportfileheaders)
-	If writeres==writefalse
-		Call errexit()
-	EndIf
-	Add sizefileheaders sizeimportfileheaders
-EndIf
+If fileformat==elf_unix
+	If object==false
+		if implibsstarted==false
+			SetCall errormsg elfaddsecn()
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			SetCall writeres writefile(fileout,miscbag,miscbagReg)
+			If writeres==writefalse;Call errexit();EndIf
+			Add sizefileheaders miscbagReg
+		else
+			SetCall errormsg elfaddsec_base(secstrs_off_atnames,0,0,null,null,0,0,0,0,null,ptrextra)
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			SetCall errormsg elfaddsec_base(dynstr,(SHT_STRTAB),(SHF_ALLOC),elf_str_offset,elf32_dyn_d_val_strsz,0,0,bytesize,0,elf32_dyn_d_ptr_strtab,ptrextra)
+			#                                                   dynstr has alloc, the other str,no
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			const SHT_DYNAMIC=6
+			SetCall errormsg elfaddsec_base(dynsec,(SHT_DYNAMIC),(SHF_WRITE|SHF_ALLOC),elf32_phdr_p_offset_dyn,elf32_phdr_p_filesz_dyn,1,0,elf32_phdr_p_align_dyn,qwordsize,elf32_phdr_p_vaddr_dyn,ptrextra)
+			If errormsg!=noerr;Call msgerrexit(errormsg);EndIf
+			#
+			SetCall writeres writefile(fileout,extra,extraReg)
+			If writeres==writefalse;Call errexit();EndIf
+			Add sizefileheaders extraReg
+			#extra used nomore
+		endelse
+	endif
+endif
 
 SetCall writeres padsec(fileout,sizefileheaders,startofdata)
 If writeres==writefalse
--- ocompiler-1.orig/src/files/functions/64bit.s
+++ ocompiler-1/src/files/functions/64bit.s
@@ -150,4 +150,139 @@ function val64_phase_3()
 endfunction
 function val64_p_get()
 	data x#1;return #x
-endfunction
\ No newline at end of file
+endfunction
+
+function function_call_64m(sd hex_1,sd hex_2,sd hex_3,sd hex_4,ss args_push,sd hex_x)
+	sd err
+	Data code%ptrcodesec
+	sd nr_of_args;setcall nr_of_args nr_of_args_64need()
+	if nr_of_args>0
+		SetCall err addtosec(hex_1,4,code);If err!=(noerror);Return err;EndIf
+		if nr_of_args>1
+			SetCall err addtosec(hex_2,5,code);If err!=(noerror);Return err;EndIf
+			if nr_of_args>2
+				SetCall err addtosec(hex_3,5,code);If err!=(noerror);Return err;EndIf
+				if nr_of_args>3
+					SetCall err addtosec(hex_4,5,code);If err!=(noerror);Return err;EndIf
+				endif
+			endif
+		endif
+	endif
+	#shadow space
+	set args_push# 4
+	if nr_of_args<args_push#;set args_push# nr_of_args;endif
+	sub args_push# 4;mult args_push# -1
+	if args_push#!=0
+		mult args_push# (qwsz)
+		call rex_w(#err);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(hex_x,3,code);If err!=(noerror);Return err;EndIf
+	endif
+	#stack align,more to see when the offset was taken
+	sd stack_align_p;setcall stack_align_p stack_align_off_p_get()
+	ss code_pointer;call getcont(code,#code_pointer)
+	add code_pointer stack_align_p#
+	sd against_one=4;if nr_of_args>4;set against_one nr_of_args;endif;and against_one 1
+	#Jump short if not carry
+	if against_one==0;set code_pointer# (0x73)
+	#Jump short if carry
+	else;set code_pointer# (0x72);endelse
+	return (noerror)
+endfunction
+function function_call_64(sd is_callex)
+	sd err
+	Data code%ptrcodesec
+	#
+	#rcx,[rsp+0]
+	chars hex_1={REX_Operand_64,0x8B,0x0C,0x24}
+	#rdx,rsp+8
+	chars hex_2={REX_Operand_64,0x8B,0x54,0x24,0x08}
+	#r8,rsp+16
+	chars hex_3={REX_R8_15,0x8B,0x44,0x24,0x10}
+	#r9,rsp+24
+	chars hex_4={REX_R8_15,0x8B,0x4C,0x24,0x18}
+	#sub esp,x;default 4 args stack space convention
+	chars hex_x={0x83,0xEC};chars args_push#1
+		
+	if is_callex==(FALSE)
+		setcall err function_call_64m(#hex_1,#hex_2,#hex_3,#hex_4,#args_push,#hex_x)
+		Return err
+	endif
+	#
+	#cmp eax,imm32
+	chars cmp_je=0x3d;data cmp_imm32#1
+	#jump
+	chars callex_jump#1;chars j_off#1
+	##
+	#mov eax,ebx
+	chars find_args={0x8b,0xc3}
+	#sub eax,esp
+	chars *={0x2b,0xc4}
+	#edx=0;ecx=QWORD;div edx:eax,ecx
+	chars *=0xba;data *=0;chars *=0xb9;data *=qwsz;chars *={0xF7,0xF1}
+	#
+	SetCall err addtosec(#find_args,0x10,code);If err!=(noerror);Return err;EndIf
+	#jump if equal
+	set callex_jump (0x74)
+	#
+	set cmp_imm32 0
+	set j_off (4+7+5+7+5+7+5)
+	SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(#hex_1,4,code);If err!=(noerror);Return err;EndIf
+	#
+		set cmp_imm32 1
+		set j_off (5+7+5+7+5)
+		SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(#hex_2,5,code);If err!=(noerror);Return err;EndIf
+	#
+			set cmp_imm32 2
+			set j_off (5+7+5)
+			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+				SetCall err addtosec(#hex_3,5,code);If err!=(noerror);Return err;EndIf
+	#
+				set cmp_imm32 3
+				set j_off (5)
+				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+					SetCall err addtosec(#hex_4,5,code);If err!=(noerror);Return err;EndIf
+	#jump if above
+	set callex_jump (0x77)
+	set args_push (qwsz)
+	#4*REX.W
+	data jump64#1;set jump64 4
+	#
+	set cmp_imm32 3
+	set j_off (3+7+3+7+3+7+3);add j_off jump64
+	SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+		subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
+		set cmp_imm32 2
+		set j_off (3+7+3+7+3);add j_off jump64
+		SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+			subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
+			set cmp_imm32 1
+			set j_off (3+7+3);add j_off jump64
+			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+				subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
+				SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
+				set cmp_imm32 0
+				set j_off (3);add j_off jump64
+				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
+					call rex_w(#err);If err!=(noerror);Return err;EndIf
+					SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
+	return (noerror)
+endfunction
+
+function function_start_64()
+	Data code%ptrcodesec
+	sd err
+	const functionx_start=!
+	#mov [rsp+8h],rcx
+	chars functionx_code={REX_Operand_64,moveatmemtheproc,0x4C,0x24,0x08}
+	#mov [rsp+10h],rdx
+	chars *={REX_Operand_64,moveatmemtheproc,0x54,0x24,0x10}
+	#mov [rsp+18h],r8
+	chars *={REX_R8_15,moveatmemtheproc,0x44,0x24,0x18}
+	#mov [rsp+20h],r9
+	chars *={REX_R8_15,moveatmemtheproc,0x4C,0x24,0x20}
+	SetCall err addtosec(#functionx_code,(!-functionx_start),code)
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ ocompiler-1/src/files/functions/actions/argstwo.s
@@ -193,6 +193,7 @@ Function twoargs(data ptrcontent,data pt
 				add opsec 1
 			elseif subtype==(cCALLEX)
 				add opsec 1
+				call val64_phase_1();call val64_phase_2()
 			endelseif
 		endif
 		SetCall errnr writeop_immfilter(dataargsec,opsec,intchar,sufixsec,regopcode)
--- ocompiler-1.orig/src/files/functions/actions/enumcomma.s
+++ ocompiler-1/src/files/functions/actions/enumcomma.s
@@ -14,12 +14,12 @@ function writevar(data ptrvalue,data uni
 				#data
 				Data ptraddresses%ptraddresses
 				Data relocoff=0
-				SetCall err adddirectrel(ptraddresses,relocoff,relindex)
+				SetCall err adddirectrel_base(ptraddresses,relocoff,relindex,ptrvalue#)
 			else
 				#code
 				data ptrextra%ptrextra
 				data stackoff=rampadd_value_off
-				setcall err adddirectrel(ptrextra,stackoff,relindex)
+				setcall err adddirectrel_base(ptrextra,stackoff,relindex,ptrvalue#)
 			endelse
 			If err!=noerr
 				Return err
--- ocompiler-1.orig/src/files/functions/actions/fn.s
+++ ocompiler-1/src/files/functions/actions/fn.s
@@ -14,9 +14,10 @@ Function unresolvedcallsfn(data struct,d
 	Data ptrobject%ptrobject
 
 	If ptrobject#==true
-		Chars elf_rel_info_type={R_386_PC32}
+		#Chars elf_rel_info_type={R_386_PC32}
+		Chars elf_rel_info_type={R_386_32}
 		Data ptrextra%ptrextra
-		SetCall err addrel(offset,elf_rel_info_type,valuedata,ptrextra)
+		SetCall err addrel_base(offset,elf_rel_info_type,valuedata,atend,ptrextra)
 	Else
 		#add to resolve at end
 		Data unressz=3*dwsz
@@ -138,16 +139,7 @@ Function parsefunction(data ptrcontent,d
 			if subtype==(cFUNCTIONX)
 				setcall b is_for_64()
 				if b==(TRUE)
-					const functionx_start=!
-					#mov [rsp+8h],rcx
-					chars functionx_code={REX_Operand_64,moveatmemtheproc,0x4C,0x24,0x08}
-					#mov [rsp+10h],rdx
-					chars *={REX_Operand_64,moveatmemtheproc,0x54,0x24,0x10}
-					#mov [rsp+18h],r8
-					chars *={REX_R8_15,moveatmemtheproc,0x44,0x24,0x18}
-					#mov [rsp+20h],r9
-					chars *={REX_R8_15,moveatmemtheproc,0x4C,0x24,0x20}
-					SetCall err addtosec(#functionx_code,(!-functionx_start),code)
+					setcall err function_start_64()
 					If err!=noerr
 						Return err
 					EndIf
@@ -241,112 +233,8 @@ function write_function_call(sd ptrdata,
 	
 	sd b;setcall b is_for_64_is_impX_or_fnX_get()
 	if b==(TRUE)
-		#rcx,[rsp+0]
-		chars hex_1={REX_Operand_64,0x8B,0x0C,0x24}
-		#rdx,rsp+8
-		chars hex_2={REX_Operand_64,0x8B,0x54,0x24,0x08}
-		#r8,rsp+16
-		chars hex_3={REX_R8_15,0x8B,0x44,0x24,0x10}
-		#r9,rsp+24
-		chars hex_4={REX_R8_15,0x8B,0x4C,0x24,0x18}
-		#sub esp,x;default 4 args stack space convention
-		chars hex_x={0x83,0xEC};chars args_push#1
-			
-		if is_callex==(FALSE)
-			sd nr_of_args;setcall nr_of_args nr_of_args_64need()
-			if nr_of_args>0
-				SetCall err addtosec(#hex_1,4,code);If err!=(noerror);Return err;EndIf
-				if nr_of_args>1
-					SetCall err addtosec(#hex_2,5,code);If err!=(noerror);Return err;EndIf
-					if nr_of_args>2
-						SetCall err addtosec(#hex_3,5,code);If err!=(noerror);Return err;EndIf
-						if nr_of_args>3
-							SetCall err addtosec(#hex_4,5,code);If err!=(noerror);Return err;EndIf
-						endif
-					endif
-				endif
-			endif
-			#shadow space
-			set args_push 4
-			if nr_of_args<args_push;set args_push nr_of_args;endif
-			sub args_push 4;mult args_push -1
-			if args_push!=0
-				mult args_push (qwsz)
-				call rex_w(#err);If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-			endif
-			#stack align,more to see when the offset was taken
-			sd stack_align_p;setcall stack_align_p stack_align_off_p_get()
-			ss code_pointer;call getcont(code,#code_pointer)
-			add code_pointer stack_align_p#
-			sd against_one=4;if nr_of_args>4;set against_one nr_of_args;endif;and against_one 1
-			#Jump short if not carry
-			if against_one==0;set code_pointer# (0x73)
-			#Jump short if carry
-			else;set code_pointer# (0x72);endelse
-		else
-			#cmp eax,imm32
-			chars cmp_je=0x3d;data cmp_imm32#1
-			#jump
-			chars callex_jump#1;chars j_off#1
-			##
-			#mov eax,ebx
-			chars find_args={0x8b,0xc3}
-			#sub eax,esp
-			chars *={0x2b,0xc4}
-			#edx=0;ecx=QWORD;div edx:eax,ecx
-			chars *=0xba;data *=0;chars *=0xb9;data *=qwsz;chars *={0xF7,0xF1}
-			#
-			SetCall err addtosec(#find_args,0x10,code);If err!=(noerror);Return err;EndIf
-			#jump if equal
-			set callex_jump (0x74)
-			#
-			set cmp_imm32 0
-			set j_off (4+7+5+7+5+7+5)
-			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#hex_1,4,code);If err!=(noerror);Return err;EndIf
-			#
-				set cmp_imm32 1
-				set j_off (5+7+5+7+5)
-				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-					SetCall err addtosec(#hex_2,5,code);If err!=(noerror);Return err;EndIf
-			#
-					set cmp_imm32 2
-					set j_off (5+7+5)
-					SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-						SetCall err addtosec(#hex_3,5,code);If err!=(noerror);Return err;EndIf
-			#
-						set cmp_imm32 3
-						set j_off (5)
-						SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-							SetCall err addtosec(#hex_4,5,code);If err!=(noerror);Return err;EndIf
-			#jump if above
-			set callex_jump (0x77)
-			set args_push (qwsz)
-			#4*REX.W
-			data jump64#1;set jump64 4
-			#
-			set cmp_imm32 3
-			set j_off (3+7+3+7+3+7+3);add j_off jump64
-			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-				subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-				set cmp_imm32 2
-				set j_off (3+7+3+7+3);add j_off jump64
-				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-					subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-					SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-					set cmp_imm32 1
-					set j_off (3+7+3);add j_off jump64
-					SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-						subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-						SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-						set cmp_imm32 0
-						set j_off (3);add j_off jump64
-						SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-							call rex_w(#err);If err!=(noerror);Return err;EndIf
-							SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-		endelse
+		setcall err function_call_64(is_callex)
+		If err!=(noerror);Return err;EndIf
 	endif
 
 	Data ptrfnmask#1
@@ -360,39 +248,41 @@ function write_function_call(sd ptrdata,
 	And fnmask idatafn
 	
 	If fnmask==idatafn
-		data ptrvirtualimportsoffset%ptrvirtualimportsoffset
-		SetCall err unresolvedcallsfn(code,1,ptrdata#,ptrvirtualimportsoffset)
-		If err!=(noerror)
-			Return err
-		EndIf
 		If ptrobject#==(FALSE)
 			Set boolindirect (TRUE)
 		EndIf
 	EndIf
 
 	If boolindirect==(FALSE)
-		Chars directcall={0xe8}
+		Chars directcall#1
 		Data directcalloff#1
-
+		chars *={0xff,0xd0}
+		
 		Data ptrdirectcall^directcall
-		Data directcallsize=1+dwsz
+		const directcallsize=1+dwsz
 		data ptrdirectcalloff^directcalloff
 
 		If fnmask!=idatafn
+			set directcall 0xe8
 			setcall err unresolvedLocal(1,code,ptrdata,ptrdirectcalloff)
-			If err!=(noerror)
-				Return err
-			EndIf
+			If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(ptrdirectcall,(directcallsize),code)
+			If err!=(noerror);Return err;EndIf
 		Else
-			#reloc when linking;0-dwsz(appears to be dwsz from Data directcallsize=1+dwsz)
-			Set directcalloff (0-dwsz)
+			#was: reloc when linking;0-dwsz(appears to be dwsz from Data directcallsize=1+dwsz), no truncation, so direct better
+			set directcall 0xb8
+			Set directcalloff 0
+			SetCall err unresolvedcallsfn(code,1,ptrdata#,directcalloff)
+			If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(ptrdirectcall,(directcallsize+2),code)
+			If err!=(noerror);Return err;EndIf
 		EndElse
-
-		SetCall err addtosec(ptrdirectcall,directcallsize,code)
-		If err!=(noerror)
-			Return err
-		EndIf
 	Else
+		if fnmask==idatafn
+			data ptrvirtualimportsoffset%ptrvirtualimportsoffset
+			SetCall err unresolvedcallsfn(code,1,ptrdata#,ptrvirtualimportsoffset)
+			If err!=(noerror);Return err;EndIf
+		endif
 		Chars callaction={0xff}
 		Data noreg=noregnumber
 		Chars callactionopcode={2}
@@ -408,7 +298,6 @@ function write_function_call(sd ptrdata,
 	if global_err_pB#!=(FALSE)
 		sd global_err_ptr;setcall global_err_ptr global_err_p()
 		Data ptrextra%ptrextra
-		#pointing to data. at 32 disp32 is absolute,at 64 relative
 		If ptrobject#==(FALSE)
 		#absolute
 			const global_err_ex_start=!
@@ -422,36 +311,15 @@ function write_function_call(sd ptrdata,
 			#
 			SetCall err addtosec(#g_err_mov,(global_err_ex_sz),code)
 		Else
-			sd is64;setcall is64 is_for_64()
-			if is64==(FALSE)
-			#relative: using ecx(code absolute)+disp32
-				const g_err_o32_b=!
-				#mov ecx,coderel
-				chars g_err_o32=0xb8+ecxregnumber;data g_err_rel#1
-				#cmp byte[ecx+imm32],0
-				chars *={0x80,7*toregopcode|ecxregnumber|0x80}
-				#
-				const g_err_o32_sz=!-g_err_o32_b
-				#
-				call getcontReg(code,#g_err_rel);add g_err_rel (bsz+dwsz+bsz+bsz+dwsz+bsz)
-				SetCall err adddirectrel(ptrextra,(bsz),(codeind));If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#g_err_o32,(g_err_o32_sz),code);If err!=(noerror);Return err;EndIf
-			else
-			#relative
-			#cmp byte[imm32],0
-				chars g_err_cmp={0x80,7*toregopcode|5}
-				#
-				SetCall err addtosec(#g_err_cmp,(bsz+bsz),code);If err!=(noerror);Return err;EndIf
-			endelse
-				const global_err_obj_start=!
-			data g_err_cmp_disp32#1
-			chars *=0
-				const global_err_obj_sz=!-global_err_obj_start
-			set g_err_cmp_disp32 (0-global_err_obj_sz)
-			sd ac_off;call getcontReg(code,#ac_off)
-			SetCall err addrel(ac_off,(R_386_PC32),global_err_ptr#,ptrextra);If err!=(noerror);Return err;EndIf
+			#mov to ecx is reseting the high part of the rcx
+			const global_err_obj_start=!
+			chars g_err=0xb9
+			data *rel=0
+			chars *g_cmp={0x80,7*toregopcode|ecxregnumber,0}
+			const global_err_obj_sz=!-global_err_obj_start
 			#
-			SetCall err addtosec(#g_err_cmp_disp32,(global_err_obj_sz),code)
+			setcall err adddirectrel_base(ptrextra,(bsz),global_err_ptr#,0);If err!=(noerror);Return err;EndIf
+			SetCall err addtosec(#g_err,(global_err_obj_sz),code)
 		EndElse
 		If err!=(noerror);Return err;EndIf
 		#jz
--- ocompiler-1.orig/src/files/functions/actions/fndecargs.s
+++ ocompiler-1/src/files/functions/actions/fndecargs.s
@@ -94,7 +94,7 @@ Function fndecargs(data ptrcontent,data
 	Data ptrextra%ptrextra
 	Data reloff=offend-offstart
 	Data dataind=dataind
-	SetCall err adddirectrel(ptrextra,reloff,dataind)
+	SetCall err adddirectrel_base(ptrextra,reloff,dataind,memoff)
 	If err!=noerr
 		Return err
 	EndIf
--- ocompiler-1.orig/src/files/functions/argument/comwrite.s
+++ ocompiler-1/src/files/functions/argument/comwrite.s
@@ -71,7 +71,7 @@ function writetake(sd takeindex,sd entry
 		setcall var function_in_code()
 		if var#==0
 			Data dataind=dataind
-			SetCall errnr adddirectrel(ptrextra,relocoff,dataind)
+			SetCall errnr adddirectrel_base(ptrextra,relocoff,dataind,takeloc)
 			If errnr!=(noerror)
 				Return errnr
 			EndIf
@@ -83,7 +83,7 @@ function writetake(sd takeindex,sd entry
 			setcall takeloc get_function_value(importbit,entry)
 			sd index
 			setcall index get_function_values(importbit,#takeloc,entry)
-			SetCall errnr adddirectrel(ptrextra,relocoff,index)
+			SetCall errnr adddirectrel_base(ptrextra,relocoff,index,takeloc)
 			If errnr!=(noerror)
 				Return errnr
 			EndIf
@@ -139,6 +139,7 @@ Function writeoperation(data location,ch
 
 	Data true=TRUE
 	If sufix==true
+		#setcall errnr rex_w_if64();If errnr!=noerr;Return errnr;EndIf it's not ok will break data
 		Chars newtake={moveatprocthemem}
 		Const edxtoedx=edxregnumber*8|edxregnumber
 		Chars *newtakemodrm={edxtoedx}
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ ocompiler-1/src/files/functions/dataassign.s
@@ -329,23 +329,21 @@ function get_function_value(sd importbit
 	if importbit!=0
 		#imports
 		return pointer#
-	else
-		#local
-		sd value
-		call get_fn_pos(pointer,#value)
-		return value
-	endelse
+	endif
+	#local
+	sd value
+	call get_fn_pos(pointer,#value)
+	return value
 endfunction
 #relocindex
 function get_function_values(sd importbit,sd p_value,sd pointer)
 	If importbit==0
 		#code
 		return (codeind)
-	Else
-		#import
-		set p_value# 0
-		return pointer#
-	EndElse
+	endif
+	#import
+	set p_value# 0
+	return pointer#
 endfunction
 
 #err
--- ocompiler-1.orig/src/files/functions/elf/elf.s
+++ ocompiler-1/src/files/functions/elf/elf.s
@@ -18,7 +18,8 @@ Function addtonames(data str,data regoff
 EndFunction
 
 #err
-Function elfaddsec(data stringname,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
+function elfaddsec_base(sd stringname,sd type,sd flags,sd fileoffset,sd bsize,sd link,sd info,sd align,sd entsize,sd addr,sd ptrbag)
+	Const elf_section=!
 	#Section header
 	#Section name (string tbl index)
 	Data sh_name#1
@@ -27,7 +28,7 @@ Function elfaddsec(data stringname,data
 	#Section flags
 	Data sh_flags#1
 	#Section virtual addr at execution
-	Data *sh_addr=0
+	Data sh_addr#1
 	#Section file offset
 	Data sh_offset#1
 	#Section size in bytes
@@ -40,112 +41,143 @@ Function elfaddsec(data stringname,data
 	Data sh_addralign#1
 	#Entry size if section holds table
 	Data sh_entsize#1
-
-	Const elf_section^sh_name
-	Const lastsectionh^sh_entsize
-	Const elf_section_size=lastsectionh+dwsz-elf_section
-	Data elf_section%elf_section
-	Data elf_section_size=elf_section_size
+	Const elf_section_size=!-elf_section
+	
+	Const elf64_section=!
+	Data sh64_name#1
+	Data sh64_type#1
+	Data sh64_flags#1;data *=0
+	Data sh64_addr#1;data *=0
+	Data sh64_offset#1;data *=0
+	Data sh64_size#1;data *=0
+	Data sh64_link#1
+	Data sh64_info#1
+	Data sh64_addralign#1;data *=0
+	Data sh64_entsize#1;data *=0
+	Const elf64_section_size=!-elf64_section
 
 	Const SHT_NULL=0
 	Const SHT_PROGBITS=1
 	Const SHT_NOBITS=8
 		
+	const SHF_WRITE=1
 		#Occupies memory during execution,1 << 1
 	Const SHF_ALLOC=2*1
 		#Executable,1 << 2
 	Const SHF_EXECINSTR=2*2
 		#`sh_info' contains SHT index,1 << 6
 	Const SHF_INFO_LINK=2*6
-
-	Data err#1
-	Data ptrmiscbag%ptrmiscbag
-
-	Data SHT_NULL=SHT_NULL
+	
 	Data SHT_PROGBITS=SHT_PROGBITS
 	Data SHT_NOBITS=SHT_NOBITS
 	Data zero=0
-
-	If type==SHT_NULL
-		Call memset(elf_section,zero,elf_section_size)
-	Else
-		Set sh_name stringname
-		
-		Data ptrsh_size^sh_size
-		Call getcontReg(seccont,ptrsh_size)
-		If type==SHT_PROGBITS
-			If sh_size==zero
-				Set type SHT_NOBITS
-			EndIf
+	If type==SHT_PROGBITS
+		If bsize==zero
+			Set type SHT_NOBITS
 		EndIf
-		Set sh_type type
-
-		Set sh_flags flags
-		Set sh_offset fileoffset
-		#   sh_size
-		Set sh_link link
-		Set sh_info info
-		Set sh_addralign align
-		Set sh_entsize entsize
-	EndElse
-	SetCall err addtosec(elf_section,elf_section_size,ptrmiscbag)
+	EndIf
+	
+	Data err#1
+	#is false at inits, no worry about only at object
+	sd e64;setcall e64 is_for_64()
+	if e64==(TRUE)
+		Set sh64_name stringname;Set sh64_type type;Set sh64_flags flags;set sh64_addr addr;Set sh64_offset fileoffset
+		set sh64_size bsize;Set sh64_link link;Set sh64_info info;Set sh64_addralign align;Set sh64_entsize entsize
+		setcall err addtosec(#sh64_name,(elf64_section_size),ptrbag)
+	else
+		Set sh_name stringname;Set sh_type type;Set sh_flags flags;set sh_addr addr;Set sh_offset fileoffset
+		set sh_size bsize;Set sh_link link;Set sh_info info;Set sh_addralign align;Set sh_entsize entsize
+		SetCall err addtosec(#sh_name,(elf_section_size),ptrbag)
+	endelse
 	Return err
-EndFunction
-
+endfunction
 #err
-Function elfaddstrsec(data stringoffname,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
-	Data regnr#1
-	Data ptrregnr^regnr
-	Data err#1
-	Data noerr=noerror
-	SetCall err addtonames(stringoffname,ptrregnr)
-	If err==noerr
-		SetCall err elfaddsec(regnr,type,flags,fileoffset,seccont,link,info,align,entsize)
-	EndIf
+function elfaddsecn()
+	Data ptrmiscbag%ptrmiscbag
+	sd err
+	SetCall err elfaddsec_base((NULL),(SHT_NULL),0,(NULL),(NULL),0,0,0,0,(NULL),ptrmiscbag)
+	Return err
+endfunction
+#err
+Function elfaddsec(data stringoff,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
+	sd bsize
+	Call getcontReg(seccont,#bsize)
+	Data ptrmiscbag%ptrmiscbag
+	sd err
+	SetCall err elfaddsec_base(stringoff,type,flags,fileoffset,bsize,link,info,align,entsize,(NULL),ptrmiscbag)
 	Return err
 EndFunction
+#err
+Function elfaddstrsec(data stringofname,data type,data flags,data fileoffset,data seccont,data link,data info,data align,data entsize)
+	sd err
+	sd regnr#1
+	sd ptrregnr^regnr
+	SetCall err addtonames(stringofname,ptrregnr)
+	If err==(noerror)
+		setcall err elfaddsec(regnr,type,flags,fileoffset,seccont,link,info,align,entsize)
+	endif
+	return err
+EndFunction
 
 #err
 Function elfaddsym(data stringoff,data value,data size,chars type,chars bind,data index,data struct)
-	#Symbol table entry
-	#Symbol name (string tbl index)
-	Data elf32_sym_st_name#1
-	#Symbol value
-	Data elf32_sym_st_value#1
-	#Symbol size
-	Data elf32_sym_st_size#1
-	#Symbol type and binding
-	Const STB_LOCAL=0
-	Const STB_GLOBAL=1
-	Const STT_NOTYPE=0
-	Const STT_FUNC=2
-	Const STT_SECTION=3
-	Chars elf32_sym_st_info#1
-	#Symbol visibility
-	Chars *elf32_sym_st_other={0}
-	#Section index
-	Chars elf32_sym_st_shndx#2
-
-	Const elf_sym_start^elf32_sym_st_name
-	Data elf_sym_size=!-elf_sym_start
-	Data elf_sym%elf_sym_start
-
-	Set elf32_sym_st_name stringoff
-	Set elf32_sym_st_value value
-	Set elf32_sym_st_size size
-
-	Set elf32_sym_st_info type
 	Chars tohibyte={16}
+	sd st_info
+	Set st_info type
 	Mult bind tohibyte
-	Or elf32_sym_st_info bind
+	Or st_info bind
 
-	Data ptrndxdest^elf32_sym_st_shndx
 	Data ptrndxsrc^index
 	Data wsz=wsz
-	Call memtomem(ptrndxdest,ptrndxsrc,wsz)
 
 	sd err
-	SetCall err addtosec(elf_sym,elf_sym_size,struct)
+	sd x;setcall x is_for_64()
+	if x==(TRUE)
+		Data elf64_sym_st_name#1
+		Chars elf64_sym_st_info#1
+		Chars *elf64_sym_st_other={0}
+		Chars elf64_sym_st_shndx#2
+		Data elf64_sym_st_value#1;data *=0
+		Data elf64_sym_st_size#1;data *=0
+	
+		Set elf64_sym_st_name stringoff
+		Set elf64_sym_st_value value
+		Set elf64_sym_st_size size
+		set elf64_sym_st_info st_info
+		Call memtomem(#elf64_sym_st_shndx,ptrndxsrc,wsz)
+
+		Const elf64_sym_start^elf64_sym_st_name
+		SetCall err addtosec(#elf64_sym_st_name,(!-elf64_sym_start),struct)
+	else
+		#Symbol table entry
+		#Symbol name (string tbl index)
+		Data elf32_sym_st_name#1
+		#Symbol value
+		Data elf32_sym_st_value#1
+		#Symbol size
+		Data elf32_sym_st_size#1
+		#Symbol type and binding
+		Const STB_LOCAL=0
+		Const STB_GLOBAL=1
+		Const STT_NOTYPE=0
+		Const STT_FUNC=2
+		Const STT_SECTION=3
+		Chars elf32_sym_st_info#1
+		#Symbol visibility
+		Chars *elf32_sym_st_other={0}
+		#Section index
+		Chars elf32_sym_st_shndx#2
+	
+		Set elf32_sym_st_name stringoff
+		Set elf32_sym_st_value value
+		Set elf32_sym_st_size size
+		set elf32_sym_st_info st_info
+		Call memtomem(#elf32_sym_st_shndx,ptrndxsrc,wsz)
+
+		Const elf_sym_start^elf32_sym_st_name
+		SetCall err addtosec(#elf32_sym_st_name,(!-elf_sym_start),struct)
+	endelse
+	
 	Return err
 EndFunction
 #err
@@ -185,32 +217,65 @@ Data objfnmask#1
 Const ptrobjfnmask^objfnmask
 
 #err
-Function addrel(data offset,chars type,data symbolindex,data struct)
-	#offset
-	Data elf_rel_offset#1
-	#Relocation type and symbol index
+Function addrel_base(sd offset,sd type,sd symbolindex,sd addend,sd struct)
 	#Direct 32 bit
 	Const R_386_32=1
+	#const R_X86_64_64=1
+	const R_X86_64_32=10
 	#PC relative 32 bit
-	Const R_386_PC32=2
+	#const R_386_PC32=2
+	#const R_X86_64_PC32=R_386_PC32
+	#const R_X86_64_PC64=24
 	
-	Chars elf_rel_info_type#1
-	Data elf_rel_info_symbolindex#1
-	
-	Data elf_rel^elf_rel_offset
-	Data elf_rel_sz=elf32_dyn_d_val_relent
-
-	Set elf_rel_offset offset
-	Set elf_rel_info_type type
-	Set elf_rel_info_symbolindex symbolindex
+	Data elf_rel#1
+	Data elf_rel_sz#1
 
-	Data err#1
+	sd err
+	sd x;setcall x is_for_64()
+	if x==(TRUE)
+		Data elf64_r_offset#1;data *=0
+		data *elf64_r_info_type=R_X86_64_32
+		data elf64_r_info_symbolindex#1
+		data elf64_r_addend#1;data *=0
+		
+		#it is not enough
+		#Call memtomem(#elf64_r_offset,#offset,(qwsz))
+		set elf64_r_offset offset
+		set elf64_r_info_symbolindex symbolindex
+		set elf64_r_addend addend
+		
+		set elf_rel #elf64_r_offset
+		set elf_rel_sz (elf64_dyn_d_val_relent)
+	else
+		#offset
+		Data elf_r_offset#1
+		#Relocation type and symbol index
+		Chars elf_r_info_type#1
+		chars elf_r_info_symbolindex#3
+		data elf_r_addend#1
+
+		Set elf_r_offset offset
+		Set elf_r_info_type type
+		Call memtomem(#elf_r_info_symbolindex,#symbolindex,3)
+		set elf_r_addend addend
+		
+		set elf_rel #elf_r_offset
+		set elf_rel_sz (elf32_dyn_d_val_relent)
+	endelse
+	
 	SetCall err addtosec(elf_rel,elf_rel_sz,struct)
 	Return err
 EndFunction
 
 #err
-Function adddirectrel(data relsec,data extraoff,data index)
+Function addrel(sd offset,sd type,sd symbolindex,sd struct)
+	sd err
+	setcall err addrel_base(offset,type,symbolindex,0,struct)
+	return err
+endfunction
+
+#err
+Function adddirectrel_base(sd relsec,sd extraoff,sd index,sd addend)
 	Data noerr=noerror
 	Data ptrobject%ptrobject
 	Data false=FALSE
@@ -232,6 +297,6 @@ Function adddirectrel(data relsec,data e
 	Call getcontReg(struct,ptroff)
 	Add off extraoff
 	Chars elf_rel_info_type={R_386_32}
-	SetCall err addrel(off,elf_rel_info_type,index,relsec)
+	SetCall err addrel_base(off,elf_rel_info_type,index,addend,relsec)
 	Return err
 EndFunction
--- ocompiler-1.orig/src/files/headers/commons.h
+++ ocompiler-1/src/files/headers/commons.h
@@ -53,6 +53,7 @@ Data dwordsize=dwsz
 Data zero=0
 Data one=1
 data two=2
+data three=3
 Data negative=-1
 Data i#1
 Chars dot="."
--- ocompiler-1.orig/src/files/headers/elf_format.h
+++ ocompiler-1/src/files/headers/elf_format.h
@@ -1,7 +1,7 @@
 
 
 #sectionalignment
-Const elf_startofdata=0x200
+Const elf_startofdata=0x400
 Data elf_startofdata=elf_startofdata
 Const elf_imagebase=0x8048000
 
@@ -11,11 +11,15 @@ const ELFMAG1=asciiE
 const ELFMAG2=asciiL
 const ELFMAG3=asciiF
 
+const ELFCLASS32=1
+const ELFCLASS64=2
+const EM_386=3
+const EM_X86_64=62
+const ET_REL=1
+
 chars elf32_ehd_e_ident_sign={ELFMAG0,ELFMAG1,ELFMAG2,ELFMAG3}
 
 #32-bit objects
-const ELFCLASS32=1
-#const ELFCLASS64=2
 chars *elf32_ehd_e_ident_class={ELFCLASS32}
 
 #2's complement, little endian
@@ -41,8 +45,6 @@ chars *elf32_ehd_e_ident_pad={0,0,0,0,0,
 #Object file type
 Chars elf32_ehd_e_type#2
 #Architecture,Intel 80386
-const EM_386=3
-#const EM_X86_64=62
 Chars *elf32_ehd_e_machine={EM_386,0}
 
 data *elf32_ehd_e_version=EV_CURRENT
@@ -54,8 +56,7 @@ data elf32_ehd_e_phoff#1
 data elf32_ehd_e_shoff#1
 data *elf32_ehd_e_flags=0
 #Size of this header
-Const elfhdsize=52
-chars *elf32_ehd_e_ehsize={elfhdsize,0}
+chars *elf32_ehd_e_ehsize={52,0}
 #Program header table entry size
 Const elf32_ehd_e_phentsize=32
 chars *elf32_ehd_e_phentsize={elf32_ehd_e_phentsize,0}
@@ -77,10 +78,38 @@ Data elf_fileheaders%elf_fileheaders_sta
 Data elf_fileheaders_size=elf_fileheaders_end-elf_fileheaders_start
 
 Data ptrelf32_ehd_e_type^elf32_ehd_e_type
+data ptrelf32_ehd_e_shoff^elf32_ehd_e_shoff
 data ptrelf32_ehd_e_phnum^elf32_ehd_e_phnum
 data ptrelf32_ehd_e_shnum^elf32_ehd_e_shnum
 data ptrelf32_ehd_e_shstrndx^elf32_ehd_e_shstrndx
 
+
+#64 bit objects
+Const elf64_fileheaders_start=!
+chars elf64_ehd_e_ident_sign={ELFMAG0,ELFMAG1,ELFMAG2,ELFMAG3}
+chars *elf64_ehd_e_ident_class={ELFCLASS64}
+chars *elf64_ehd_e_ident_data={ELFDATA2LSB}
+chars *elf64_ehd_e_ident_version={EV_CURRENT}
+chars *elf64_ehd_e_ident_osabi={ELFOSABI_NONE}
+chars *elf64_ehd_e_ident_abiversion={EI_ABIVERSION}
+chars *elf64_ehd_e_ident_pad={0,0,0,0,0,0,0}
+Chars *elf64_ehd_e_type={ET_REL,0}
+Chars *elf64_ehd_e_machine={EM_X86_64,0}
+data *elf64_ehd_e_version=EV_CURRENT
+data *elf64_ehd_e_entry={0,0}
+data *elf64_ehd_e_phoff={0,0}
+data elf64_ehd_e_shoff#1;data *=0
+data *elf64_ehd_e_flags=0
+chars *elf64_ehd_e_ehsize={64,0}
+chars *elf64_ehd_e_phentsize={0,0}
+chars *elf64_ehd_e_phnum={0,0}
+chars *elf64_ehd_e_shentsize={64,0}
+chars elf64_ehd_e_shnum#2
+chars elf64_ehd_e_shstrndx#2
+chars *pad={0,0}
+Const elf64_fileheaders_size=!-elf64_fileheaders_start
+
+
 #program headers
 
 const PF_X=1
@@ -165,7 +194,7 @@ data elf32_phdr_p_memsz_dyn#1
 #Segment flags
 data *elf32_phdr_p_flags_dyn=PF_R
 #Segment align
-data *elf32_phdr_p_align_dyn=0x1
+data elf32_phdr_p_align_dyn=0x1
 
 #Library section
 data *elf32_phdr_p_type_lib=PT_LOAD
@@ -206,12 +235,12 @@ Data *DT_STRTAB=5
 Data elf32_dyn_d_ptr_strtab#1
 Data *DT_STRSZ=10
 Data elf32_dyn_d_val_strsz#1
-Data *DT_REL=17
+Data *DT_RELA=7
 Data elf32_dyn_d_ptr_rel#1
-Data *DT_RELSZ=18
+Data *DT_RELASZ=8
 Data elf32_dyn_d_val_relsz#1
-Data *DT_RELENT=19
-Const elf32_dyn_d_val_relent=8
+Data *DT_RELAENT=9
+Const elf32_dyn_d_val_relent=12
 Data elf32_dyn_d_val_relent=elf32_dyn_d_val_relent
 Data *DT_NULL=0
 Data elf32_dyn_d_val_null=0
@@ -240,6 +269,7 @@ Data elf_rel_entries_size#1
 ##
 
 
+const SHT_STRTAB=3
 
-
-
+Const elf64_dyn_d_val_syment=0x18
+Const elf64_dyn_d_val_relent=0x18
--- ocompiler-1.orig/src/files/inits.s
+++ ocompiler-1/src/files/inits.s
@@ -102,7 +102,7 @@ Set fnavailable one
 
 Set allocerrormsg null
 
-#implibsstarted for closing at the end and for import parts
+#implibsstarted for closing at the end and for import parts; is here because 0 bytes src is something and asking for this at end
 Set implibsstarted false
 
 #fn info text is at preferences
--- /dev/null
+++ ocompiler-1/src/windows/obj64.s
@@ -0,0 +1,7 @@
+
+#windows elf rel format, with 64 code
+
+Format ElfObj64Microsoft
+
+Include "./files/winobj64imports.h"
+Include "./obj.s"
\ No newline at end of file
