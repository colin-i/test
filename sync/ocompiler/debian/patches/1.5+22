Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+22) xenial; urgency=medium
 .
   * important fix at value *^stack; movzx; multiple optimizations
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2022-08-13

--- ocompiler-1.orig/src/files/functions/64/align.s
+++ ocompiler-1/src/files/functions/64/align.s
@@ -162,8 +162,9 @@ endfunction
 function align_entryscope()
 	sd type;setcall type align_type()
 	if type!=0
-		#bt rbx,3 (offset 3) x8 or x0
-		chars bt={REX_Operand_64,0x0F,0xBA,bt_reg_imm8|ebxregnumber,3}
+		#bt ebx,3 (offset 3) x8 or x0
+		#rex to bt the first byte it is useless
+		chars bt={twobytesinstruction_byte1,bt_instruction,bt_reg_imm8|ebxregnumber,3}
 		#j(c|nc);sub rbx,8
 		chars jump#1;chars *=4;chars *={REX_Operand_64,0x83,RegReg*tomod|(5*toregopcode)|ebxregnumber,8}
 		if type==(even_align)
@@ -177,7 +178,7 @@ function align_entryscope()
 		endelse
 		vdata code%ptrcodesec
 		sd err
-		SetCall err addtosec(#bt,(5+6),code)
+		SetCall err addtosec(#bt,(4+6),code)
 		return err
 	endif
 	return (noerror)
--- ocompiler-1.orig/src/files/functions/64/bit.s
+++ ocompiler-1/src/files/functions/64/bit.s
@@ -95,28 +95,28 @@ function bigbits(sd data)
 	return test
 endfunction
 
-function stack64_op_set()
-	sd b;setcall b is_for_64()
-	if b==(TRUE);call stack64_op_set_get((TRUE),(TRUE));endif
-endfunction
+#function stack64_op_set()
+#	sd b;setcall b is_for_64()
+#	if b==(TRUE);call stack64_op_set_get((TRUE),(TRUE));endif
+#endfunction
 #(false)get
-function stack64_op_set_get(sd b,sd val)
-	data x#1
-	if b==(TRUE);set x val
-	else;return x
-	endelse
-endfunction
+#function stack64_op_set_get(sd b,sd val)
+#	data x#1
+#	if b==(TRUE);set x val
+#	else;return x
+#	endelse
+#endfunction
 #err
-function stack64_op()
-	sd b;setcall b stack64_op_set_get((FALSE))
-	if b!=(FALSE)
-		#reset
-		call stack64_op_set_get((TRUE),(FALSE))
-		#at push 64 and call 64, without rex is ok
-		sd p;setcall p val64_p_get()
-		set p# (val64_no)
-	endif
-endfunction
+#function stack64_op()
+#	sd b;setcall b stack64_op_set_get((FALSE))
+#	if b!=(FALSE)
+#		#reset
+#		call stack64_op_set_get((TRUE),(FALSE))
+#		#at push 64 and call 64, without rex is ok
+#		sd p;setcall p val64_p_get()
+#		set p# (val64_no)
+#	endif
+#endfunction
 
 function stack64_add(sd val)
 	sd b;setcall b is_for_64()
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ ocompiler-1/src/files/functions/actions/argstwo.s
@@ -18,7 +18,7 @@ Function twoargs(data ptrcontent,data pt
 	Data false=FALSE
 	Data true=TRUE
 
-	Data noreg=noregnumber
+	#Data noreg=noregnumber
 	Data eaxreg=eaxregnumber
 	Data ecxreg=ecxregnumber
 
@@ -40,8 +40,8 @@ Function twoargs(data ptrcontent,data pt
 	Set sameimportant true
 	Data divmul#1
 	Set divmul false
-	Data regprep#1
-	Set regprep eaxreg
+	#Data regprep#1
+	#Set regprep eaxreg
 	Data regopcode#1
 	Set regopcode eaxreg
 
@@ -75,9 +75,9 @@ Function twoargs(data ptrcontent,data pt
 		ElseIf subtype==(cSUB)
 			Chars subprim={0x29}
 			Set opprim subprim
-		ElseIf subtype<(cAND)
+		ElseIf subtype<=(cREM)
 			Set opprim atprocthemem
-			Set regprep ecxreg
+			#Set regprep ecxreg
 			Set regopcode ecxreg
 			Set divmul true
 			if lowprim==(FALSE);setcall big is_big(dataargprim,sufixprim)
@@ -100,7 +100,7 @@ Function twoargs(data ptrcontent,data pt
 		Else
 		#(cCALLEX)
 			Set opprim atprocthemem
-			Set regprep ecxreg
+			#Set regprep ecxreg
 			Set regopcode ecxreg
 		EndElse
 	Else
@@ -139,8 +139,10 @@ Function twoargs(data ptrcontent,data pt
 		EndIf
 	EndElse
 
-	Data intchar#1
-	Set intchar noreg
+	#Data intchar#1
+	data is_prepare#1
+	set is_prepare (FALSE)
+	#Set intchar noreg
 	Set opsec atprocthemem
 
 	If ptrcondition==false
@@ -149,15 +151,19 @@ Function twoargs(data ptrcontent,data pt
 			if subtype!=(cCALLEX)
 				#at callex they can be different
 				Dec opsec
-			elseif lowsec==true
-				dec opsec
-			endelseif
+			else
+			#if lowsec==true;dec opsec
+				#it is not possible to push from ff...al and scalar push using full rcx*8 at normal (therefor same for ff...cl)
+				return "Second argument at CALLEX must not be one byte."
+			endelse
 		ElseIf lowsec==true
-			Dec opsec
+			#Dec opsec
 			If sameimportant==true
-				Set intchar regprep
+				#Set intchar regprep
+				set is_prepare (TRUE)
 			Else
 				Dec opprim
+				Dec opsec
 			EndElse
 		EndElseIf
 	Else
@@ -175,21 +181,19 @@ Function twoargs(data ptrcontent,data pt
 				endif
 			endelse
 		Else
-			Dec opsec
-			Set intchar eaxreg
+			#Dec opsec
+			#Set intchar eaxreg
+			set is_prepare (TRUE)
 			If lowprim==true
 				#case compare low vs high, then: get low on all eax compare with high but op from mem vs proc becomes proc vs mem
-				#note that xor eax,eax will zero rax (not needing xor rax,rax)
 				Add opprim two
+				add compimmop two
+
+				#note that xor eax,eax will zero rax (not needing xor rax,rax)
 				Data aux#1
-				Set aux dataargprim
-				Set dataargprim dataargsec
-				Set dataargsec aux
-				Set aux sufixprim
-				Set sufixprim sufixsec
-				Set sufixsec aux
+				Set aux dataargprim;Set dataargprim dataargsec;Set dataargsec aux
+				Set aux sufixprim;Set sufixprim sufixsec;Set sufixsec aux
 				call switchimm()
-				add compimmop two
 				#and for ss#
 				set aux lowprim;set lowprim lowsec;set lowsec aux
 				#and char==#sd
@@ -214,11 +218,12 @@ Function twoargs(data ptrcontent,data pt
 		else
 			if p_prefix#==(FALSE)
 				sd comp_at_bigs
-				setcall comp_at_bigs comp_sec(lowsec,dataargprim,sufixprim,dataargsec,sufixsec,sameimportant)
-				setcall errnr writeop_promotes(dataargsec,opsec,intchar,sufixsec,regopcode,lowsec,comp_at_bigs)
+				setcall comp_at_bigs comp_sec(lowsec,dataargprim,sufixprim,dataargsec,sufixsec,sameimportant,is_prepare)
+				setcall errnr writeop_promotes(dataargsec,opsec,sufixsec,regopcode,lowsec,comp_at_bigs)
 			else
 			#only take at prefix on regcode
-				call writeoperation_take(#errnr,dataargsec,sufixsec,regopcode,lowsec)
+				setcall errnr writetake(regopcode,dataargsec)
+				#call writeoperation_take(#errnr,dataargsec,sufixsec,regopcode,lowsec)
 				#pprefix is reset in the road at remind
 			endelse
 			call restore_argmask()
@@ -267,63 +272,7 @@ Function twoargs(data ptrcontent,data pt
 			Set regopcodeex regopcodemult
 		Else
 			Set regopcodeex regopcodediv
-			#33D2 85c0 7902 f7d2
-			#32E4 84c0 7902 f6d4
-			Chars d1_0#1
-			Chars d1_1#1
-			Chars d2_0#1
-			Chars *d2_1={0xc0}
-			Chars d3_0=0x79;chars d3_1#1
-			Chars d4_0#1
-			Chars d4_1#1
-
-			Const bitsedxregop=edxregnumber*8
-			Const bitsahregop=ahregnumber*8
-			Const bitsnotop=Notregopcode*8
-
-			Const pre1_1_h=regregmod|bitsedxregop|edxregnumber
-			Chars predef1_1_high={pre1_1_h}
-			Const pre4_1_h=regregmod|bitsnotop|edxregnumber
-			Chars predef4_1_high={pre4_1_h}
-			Const pre1_1_l=regregmod|bitsahregop|ahregnumber
-			Chars predef1_1_low={pre1_1_l}
-			Const pre4_1_l=regregmod|bitsnotop|ahregnumber
-			Chars predef4_1_low={pre4_1_l}
-
-			Chars d1_0ini={0x33}
-			Chars d2_0ini={0x85}
-			Chars d4_0ini={0xf7}
-
-			Set d1_0 d1_0ini
-			Set d2_0 d2_0ini
-			Set d4_0 d4_0ini
-
-			If lowprim==false
-				Set	d1_1 predef1_1_high
-				Set	d4_1 predef4_1_high
-			Else
-				Dec d1_0
-				Dec d2_0
-				Dec d4_0
-				Set d1_1 predef1_1_low
-				Set d4_1 predef4_1_low
-			EndElse
-			SetCall errnr addtosec(#d1_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
-			if big==(TRUE)
-				call rex_w(#errnr)
-				If errnr!=noerr;Return errnr;EndIf
-			endif
-			SetCall errnr addtosec(#d2_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
-			if big==(TRUE)
-				set d3_1 3
-				SetCall errnr addtosec(#d3_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
-				call rex_w(#errnr)
-				If errnr!=noerr;Return errnr;EndIf
-			else
-				set d3_1 2
-				SetCall errnr addtosec(#d3_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
-			endelse
-			SetCall errnr addtosec(#d4_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
+			setcall errnr div_prepare(lowprim,big)
 		EndElse
 
 		Chars opcodexini={0xF7}
@@ -365,9 +314,9 @@ Function twoargs(data ptrcontent,data pt
 			setcall errnr addtosec(#storeex,2,codeptr)
 		else
 			if rem==(FALSE)
-				SetCall errnr writeop(dataargprim,storeex,noreg,sufixprim,eaxreg,lowprim)
+				SetCall errnr writeop(dataargprim,storeex,sufixprim,eaxreg,lowprim)
 			else
-				SetCall errnr writeoperation(dataargprim,storeex,noreg,sufixprim,(edxregnumber),ecxreg,lowprim)
+				SetCall errnr writeoperation(dataargprim,storeex,sufixprim,(edxregnumber),ecxreg,lowprim)
 			endelse
 		endelse
 	ElseIf ptrcondition!=false
@@ -405,10 +354,11 @@ Function twoargs(data ptrcontent,data pt
 	Return errnr
 EndFunction
 
-#-1 normal, 0 unpromote, 1 sign extend
-function comp_sec(sd lowsec,sd dataargprim,sd sufixprim,sd dataargsec,sd sufixsec,sd sameimportant)
+#-1 normal, 0 unpromote, 1 sign extend, 2 zero extend
+function comp_sec(sd lowsec,sd dataargprim,sd sufixprim,sd dataargsec,sd sufixsec,sd sameimportant,sd is_prepare)
+	sd prim
 	if lowsec==(FALSE)
-		sd prim;setcall prim is_big(dataargprim,sufixprim)
+		setcall prim is_big(dataargprim,sufixprim)
 		sd sec;setcall sec is_big(dataargsec,sufixsec)
 		if prim!=sec
 			if sec==(TRUE)
@@ -419,7 +369,15 @@ function comp_sec(sd lowsec,sd dataargpr
 				return 1
 			endelseif
 		endif
-	endif
+	elseif is_prepare==(TRUE)
+		setcall prim is_big(dataargprim,sufixprim)
+		if prim==(TRUE)
+			#zero extend all r64
+			sd p;setcall p val64_p_get()
+			set p# (val64_willbe)
+		endif
+		return 2
+	endelseif
 	return -1
 endfunction
 
@@ -442,20 +400,20 @@ function writeop_prim(sd dataargprim,sd
 			#this is and/or... at sd low not needing to write rex
 			setcall err writeoper((edxregnumber),dataargprim,sufixprim)
 			if err!=(noerror);return err;endif
-			setcall err writeoperation_op(opprim,(noregnumber),(eaxregnumber),(edxregnumber))
+			setcall err writeoperation_op(opprim,(FALSE),(eaxregnumber),(edxregnumber))
 			return err
 		endif
 	endif
-	SetCall err writeop(dataargprim,opprim,(noregnumber),sufixprim,(eaxregnumber),lowprim)
+	SetCall err writeop(dataargprim,opprim,sufixprim,(eaxregnumber),lowprim)
 	return err
 endfunction
 
 #err
-function writeop_promotes(sd dataarg,sd op,sd intchar,sd sufix,sd regopcode,sd low,sd comp_at_bigs)
+function writeop_promotes(sd dataarg,sd op,sd sufix,sd regopcode,sd low,sd comp_at_bigs)
 	sd err
 	if comp_at_bigs==-1
-		SetCall err writeop(dataarg,op,intchar,sufix,regopcode,low)
-	else #0 or 1
+		SetCall err writeop(dataarg,op,sufix,regopcode,low)
+	else #0-2
 		setcall err writeoper((edxregnumber),dataarg,sufix) #no val64 recordings
 		if err==(noerror)
 			if comp_at_bigs==1 #these are all 64
@@ -463,8 +421,11 @@ function writeop_promotes(sd dataarg,sd
 				set op (moveatprocthemem_sign)
 				sd p;setcall p val64_p_get()
 				set p# (val64_willbe)
-			endif
-			setcall err writeoperation_op(op,(noregnumber),regopcode,(edxregnumber))
+			else
+				#2 for zero extend; these are all low
+				set op 0xb6
+			endelse
+			setcall err writeoperation_op(op,low,regopcode,(edxregnumber))
 		endif
 	endelse
 	return err
@@ -503,3 +464,34 @@ function restore_argmask()
 		set data# a#
 	endif
 endfunction
+
+
+#err
+function div_prepare(sd low,sd big)
+	const bt_atdiv=bt_reg_imm8|eaxregnumber
+	vData codeptr%ptrcodesec
+	sd errnr
+	if big==(TRUE)
+	#bt rax,63;jc,;mov 0,edx;jmp,;mov -1,rdx
+	#In x64, any operation on a 32-bit register clears the top 32 bits of the corresponding 64-bit register too, so there's no need to use mov 0,rax (and xor rax, rax)
+		const div_prepare_high=!
+		chars high={REX_Operand_64,twobytesinstruction_byte1,bt_instruction,bt_atdiv,63,0x72,7,atedximm,0,0,0,0,jmp_rel8,7,REX_Operand_64,mov_imm_to_rm,regregmod|edxregnumber,-1,-1,-1,-1}
+		SetCall errnr addtosec(#high,(!-div_prepare_high),codeptr)
+	elseif low==(TRUE)
+	#bt eax,15;jc,;mov ah,0;jmp,;mov ah,-1
+		const div_prepare_low=!
+		chars small={twobytesinstruction_byte1,bt_instruction,bt_atdiv,7,0x72,5,0xc6,regregmod|ahregnumber,0,jmp_rel8,3,0xc6,regregmod|ahregnumber,-1}
+		SetCall errnr addtosec(#small,(!-div_prepare_low),codeptr)
+	else
+	#bt eax,31;jc,;mov 0,edx;jmp,;mov -1,edx
+		const div_prepare_mediu=!
+		chars mediu={twobytesinstruction_byte1,bt_instruction,bt_atdiv,31,0x72,7,atedximm,0,0,0,0,jmp_rel8,5,atedximm,-1,-1,-1,-1}
+		SetCall errnr addtosec(#mediu,(!-div_prepare_mediu),codeptr)
+	endelse
+	return errnr
+	#before
+	#xor  test   jns  not
+	#33D2 4885c0 7903 48f7d2
+	#32E4 84c0   7902 f6d4
+	#33D2 85c0   7902 f7d2
+endfunction
--- ocompiler-1.orig/src/files/functions/actions/fn.s
+++ ocompiler-1/src/files/functions/actions/fn.s
@@ -373,11 +373,11 @@ function write_function_call(sd ptrdata,
 			If err!=(noerror);Return err;EndIf
 		endif
 		Chars callaction={0xff}
-		Data noreg=noregnumber
+		#Data noreg=noregnumber
 		Chars callactionopcode={2}
 		Data eaxregnumber=eaxregnumber
-		call stack64_op_set()
-		SetCall err writeoperation(ptrdata,callaction,noreg,(FALSE),callactionopcode,eaxregnumber)#last missing param is at sufix and at declare is not
+		#call stack64_op_set()
+		SetCall err writeopera(ptrdata,callaction,callactionopcode,eaxregnumber) #no sufix was
 	EndElse
 	If err!=(noerror)
 		Return err
--- ocompiler-1.orig/src/files/functions/argument/argument.s
+++ ocompiler-1/src/files/functions/argument/argument.s
@@ -156,10 +156,10 @@ Function argument(data ptrcontent,data p
 	sd imm
 	setcall imm getisimm()
 	if imm==false
-		Data noreg=noregnumber
-		Data eaxreg=eaxregnumber
-		Data intchar#1
-		Set intchar noreg
+		#Data noreg=noregnumber
+		#Data eaxreg=eaxregnumber
+		#Data intchar#1
+		#Set intchar noreg
 		If forwardORcallsens!=forward
 		#push
 			#If lowbyte==false
@@ -170,10 +170,10 @@ Function argument(data ptrcontent,data p
 			#	Set regopcode pushopcode
 			#	call stack64_op_set()
 			#Else
-			If lowbyte==true
-				#prepare for eax for al
-				Set intchar eaxreg
-			EndIf
+			#If lowbyte==true
+			#	#prepare for eax for al
+			#	Set intchar eaxreg
+			#EndIf
 			Chars pushaction={moveatprocthemem}
 			Set op pushaction
 			set regopcode (eaxregnumber)
@@ -184,16 +184,15 @@ Function argument(data ptrcontent,data p
 			Set ptrcontinuation ptrpushcontinuation
 			set sizeofcontinuation pushcontinuationsize
 			#EndElse
-		EndIf
-		If lowbyte==true
+		ElseIf lowbyte==true
 		#imm don't use one byte at the moment
-			Dec op
-			If regprepare_bool==true
-				Set intchar regopcode
-			EndIf
-		EndIf
+			if regprepare_bool==false
+				Dec op
+			endif
+		#Else;Set intchar regopcode
+		EndElseIf
 		sd comp_at_bigs;setcall comp_at_bigs comp_one(lowbyte,dataarg,sufix,op)
-		setcall err writeop_promotes(dataarg,op,intchar,sufix,regopcode,lowbyte,comp_at_bigs)
+		setcall err writeop_promotes(dataarg,op,sufix,regopcode,lowbyte,comp_at_bigs)
 		call restore_argmask() #before this there is no err!=noerr: it is not a must, only less space
 	Else
 	#imm
@@ -219,8 +218,9 @@ endfunction
 #same as comp_sec
 function comp_one(sd low,sd dataarg,sd sufix,sd op)
 	if op==(moveatprocthemem)
+		sd p
 		if low==(FALSE)
-			sd p;setcall p prefix_bool() #can't touch functions
+			setcall p prefix_bool() #can't touch functions
 			if p#==0
 				sd big;setcall big is_big(dataarg,sufix)
 				if big==(FALSE)
@@ -231,7 +231,15 @@ function comp_one(sd low,sd dataarg,sd s
 					endif
 				endif
 			endif
-		endif
+		else
+			sd b;setcall b is_for_64()
+			if b==(TRUE)
+			#return all r64; take all;is is from the time when was set that data, waiting outside, can have a char extended with zeros
+				setcall p val64_p_get()
+				set p# (val64_willbe)
+			endif
+			return 2
+		endelse
 	endif
 	return -1
 endfunction
@@ -242,7 +250,7 @@ function write_imm_sign(sd dataarg,sd re
 	sd err
 	setcall err rex_w_if64()
 	if err==(noerror)
-		chars movs_imm=0xc7
+		chars movs_imm=mov_imm_to_rm
 		SetCall err addtosec(#movs_imm,1,codeptr)
 		if err==(noerror)
 			sd op
--- ocompiler-1.orig/src/files/functions/argument/comwrite.s
+++ ocompiler-1/src/files/functions/argument/comwrite.s
@@ -55,6 +55,41 @@ function takewithimm(sd ind,sd addr)
 	SetCall err addtosec(#takeop,sz1,ptrcodesec)
 	return err
 endfunction
+#er
+function datatake_reloc(sd takeindex,sd take_loc)
+	data p_is_object%ptrobject
+	if p_is_object#==(TRUE)
+		sd relocoff
+		setcall relocoff reloc64_offset(1)
+		sd errnr
+		setcall errnr adddirectrel_base_inplace(relocoff,#take_loc)
+		If errnr!=(noerror)
+			Return errnr
+		EndIf
+	endif
+	setcall errnr datatake(takeindex,take_loc)
+	return errnr
+endfunction
+#er
+function datatake(sd takeindex,sd take_loc)
+	sd errnr
+	setcall errnr reloc64_ante();If errnr!=(noerror);Return errnr;EndIf
+	setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
+	setcall errnr reloc64_post()
+	return errnr
+endfunction
+#err
+function adddirectrel_base_inplace(sd relocoff,sd p_take_loc)
+	Data ptrextra%ptrextra
+	Data dataind=dataind
+	sd errnr
+	SetCall errnr adddirectrel_base(ptrextra,relocoff,dataind,p_take_loc#)
+	If errnr==(noerror)
+		call inplace_reloc(p_take_loc)
+	EndIf
+	Return errnr
+endfunction
+#er
 function writetake(sd takeindex,sd entry)
 	Data errnr#1
 	sd take_loc;set take_loc entry#
@@ -69,12 +104,10 @@ function writetake(sd takeindex,sd entry
 			sd var
 			setcall var function_in_code()
 			if var#==0
-				Data dataind=dataind
-				SetCall errnr adddirectrel_base(ptrextra,relocoff,dataind,take_loc)
+				setcall errnr adddirectrel_base_inplace(relocoff,#take_loc)
 				If errnr!=(noerror)
 					Return errnr
 				EndIf
-				call inplace_reloc(#take_loc)
 			else
 				#function in code, not sd^local, sd^imp
 				#function in code is only at objects at the moment, is set only once at arg.s
@@ -97,9 +130,7 @@ function writetake(sd takeindex,sd entry
 				endif
 			endelse
 		endif
-		setcall errnr reloc64_ante();If errnr!=(noerror);Return errnr;EndIf
-		setcall errnr takewithimm(takeindex,take_loc);If errnr!=(noerror);Return errnr;EndIf
-		setcall errnr reloc64_post()
+		setcall errnr datatake(takeindex,take_loc)
 	else
 		chars stack_relative#1
 		chars regreg=RegReg
@@ -188,50 +219,59 @@ function sufix64(sd location)
 	sd bittest;setcall bittest bigbits(location)
 	if bittest!=0
 		sd for_64;setcall for_64 is_for_64()
+		return for_64
 		#p test
-		if for_64==(TRUE)
-			return (val64_willbe)
-			#rex if p
-		endif
+		#if for_64==(TRUE)
+		#	return (val64_willbe)
+		#	#rex if p
+		#endif
 		#take on takeindex
 	endif
 	return (val64_no)
 endfunction
 
 #er
-Function writeoperation_op(sd operationopcode,sd regprepare,sd regopcode,sd takeindex)
+Function writeoperation_op(sd operationopcode,sd is_prepare,sd regopcode,sd takeindex)
 	Data ptrcodesec%ptrcodesec
 	Data errnr#1
 	Data noerr=noerror
 	Data sz2=bsz+bsz
 
+	sd v64;setcall v64 val64_p_get()
+	if v64#==(val64_willbe)
+		call rex_w(#errnr);if errnr!=(noerror);return errnr;endif
+		set v64# (val64_no)
+	endif
 
-	sd prefix
-	setcall prefix prefix_bool()
 	sd mod=mod_0
-	#this will reset call,push and set v64
-	Call stack64_op()
 
-	#if is low
-	If regprepare!=(noregnumber)
-		Chars comprepare1={0x33}
-		Chars comprepare2#1
-		setcall comprepare2 formmodrm((RegReg),regprepare,regprepare)
-		SetCall errnr addtosec(#comprepare1,sz2,ptrcodesec)
+	#if is like was xor prepare,prepare
+	If is_prepare==(TRUE)
+	#!=(noregnumber)
+		#Chars comprepare1={0x33}
+		#Chars comprepare2#1
+		#setcall comprepare2 formmodrm((RegReg),regprepare,regprepare)
+		#SetCall errnr addtosec(#comprepare1,sz2,ptrcodesec)
+
+		#zero extend
+		chars extend_byte=twobytesinstruction_byte1
+		SetCall errnr addtosec(#extend_byte,1,ptrcodesec)
 		If errnr!=noerr
 			Return errnr
 		EndIf
 	Else
-	#there is no prefix at low, and no val64
+		#at calls there is no low
+		#there is no prefix at low, and no val64
+		sd prefix
+		setcall prefix prefix_bool()
 		If prefix#!=0
 			set mod (RegReg)
 			set prefix# 0
-		EndIf
-		sd v64;setcall v64 val64_p_get()
-		if v64#==(val64_willbe)
-			call rex_w(#errnr);if errnr!=(noerror);return errnr;endif
-			set v64# (val64_no)
-		endif
+		endIf
+		#Else
+		#	#this will reset calls and set v64
+		#	Call stack64_op()
+		#endElse
 	EndElse
 
 	Chars actionop#1
@@ -243,19 +283,29 @@ Function writeoperation_op(sd operationo
 	Return errnr
 Endfunction
 #er
-Function writeoperation(sd location,sd operationopcode,sd regprepare,sd sufix,sd regopcode,sd takeindex,sd is_low)
+Function writeoperation(sd location,sd operationopcode,sd sufix,sd regopcode,sd takeindex,sd is_low)
 	sd err;sd v_64
 	setcall v_64 writeoperation_take(#err,location,sufix,takeindex,is_low)
 	if err!=(noerror);return err;endif
 	sd v64;setcall v64 val64_p_get();set v64# v_64
-	setcall err writeoperation_op(operationopcode,regprepare,regopcode,takeindex)
+	setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
 	return err
 Endfunction
 
 #er
-Function writeop(sd location,sd operationopcode,sd regprepare,sd sufix,sd regopcode,sd is_low)
+Function writeop(sd location,sd operationopcode,sd sufix,sd regopcode,sd is_low)
 	Data err#1
 	Data edxregnumber=edxregnumber
-	SetCall err writeoperation(location,operationopcode,regprepare,sufix,regopcode,edxregnumber,is_low)
+	SetCall err writeoperation(location,operationopcode,sufix,regopcode,edxregnumber,is_low)
 	Return err
 EndFunction
+
+#er
+function writeopera(sd location,sd operationopcode,sd regopcode,sd takeindex)
+	sd err
+	setcall err writetake(takeindex,location)
+	if err==(noerror)
+		setcall err writeoperation_op(operationopcode,(FALSE),regopcode,takeindex)
+	endif
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ ocompiler-1/src/files/functions/dataassign.s
@@ -25,25 +25,23 @@ Function dataassign(sd ptrcontent,sd ptr
 	Data charsnr=charsnumber
 	Data stringsnr=stringsnumber
 
-	data offset#1
-	Data ptroffset^offset
+	data offset_const#1
+	Data ptroffset_const^offset_const
 	Data constantsstruct%ptrconstants
-	Data container#1
-	Data pointer_structure#1
-	Data ptrcontainer^container
+	#Data pointer_structure#1
 	#at constants and at data^sd,str^ss
 
 	Data ptrrelocbool%ptrrelocbool
 
-	If typenumber!=charsnr
+	#If typenumber!=charsnr
 	#for const and at pointer with stack false
 	#this can't go after dataparse, addvarref will increase the offset
-		if typenumber==constantsnr
-			set pointer_structure constantsstruct
-		else
-			setcall pointer_structure getstructcont(typenumber)
-		endelse
-		Call getcontReg(pointer_structure,ptroffset)
+	if typenumber==constantsnr
+		#	set pointer_structure constantsstruct
+		#else
+		#	setcall pointer_structure getstructcont(typenumber)
+		#endelse
+		Call getcontReg(constantsstruct,ptroffset_const)
 	EndIf
 	SetCall err dataparse(ptrcontent,ptrsize,typenumber,assignsign,ptrrelocbool,stack,long_mask)
 	If err!=noerr
@@ -227,16 +225,22 @@ Function dataassign(sd ptrcontent,sd ptr
 			else
 				set ptrrelocbool# false
 				if stack==false
-					data eax=eaxregnumber
-					setcall err writetake(eax,pointer)
+					setcall err writetake((eaxregnumber),pointer)
+					If err!=noerr
+						Return err
+					EndIf
+					setcall value get_img_vdata_dataReg()
+					setcall err datatake_reloc((edxregnumber),value)
 					If err!=noerr
 						Return err
 					EndIf
-					data op=moveatmemtheproc
-					Data noreg=noregnumber
-					Call getcont(pointer_structure,ptrcontainer)
-					Add container offset
-					SetCall err writeop(container,op,noreg,false,eax)#last missing param is at sufix and at declare is not
+					sd v64;setcall v64 val64_p_get()
+					if long_mask!=0
+						setcall v64# is_for_64()
+					else
+						set v64# (val64_no)
+					endelse
+					setcall err writeoperation_op((moveatmemtheproc),(FALSE),(eaxregnumber),(edxregnumber))
 					If err!=noerr
 						Return err
 					EndIf
@@ -318,8 +322,10 @@ Function dataassign(sd ptrcontent,sd ptr
 				Return err
 			EndIf
 		Else
+			Data container#1
+			Data ptrcontainer^container
 			Call getcont(constantsstruct,ptrcontainer)
-			Add container offset
+			Add container offset_const
 			Set container# value
 		EndElse
 	endif
--- ocompiler-1.orig/src/files/headers/asm.h
+++ ocompiler-1/src/files/headers/asm.h
@@ -16,13 +16,18 @@ const REX_R8_15=REX_default|REX_W|REX_R
 
 Const retcom=0xc3
 const intimm8=0xCD
-const ateaximm=0xb8
-#Const atedximm=0xba
+const jmp_rel8=0xeb
 
+const ateaximm=0xb8
+Const atedximm=0xba
 Const moveatmemtheproc=0x89
 Const moveatprocthemem=0x8b
 Const moveatregthemodrm=moveatprocthemem
 const moveatprocthemem_sign=0x63
+const mov_imm_to_rm=0xc7
+
+const twobytesinstruction_byte1=0x0F
+const bt_instruction=0xBA
 
 #mod,reg/opcode,r/m
 
@@ -52,4 +57,4 @@ Const regopcode_mask=0x7
 #mixt
 Const Notregopcode=2
 #
-const bt_reg_imm8=espregnumber*toregopcode|regregmod
+const bt_reg_imm8=4*toregopcode|regregmod
--- ocompiler-1.orig/src/files/headers/header.h
+++ ocompiler-1/src/files/headers/header.h
@@ -333,8 +333,8 @@ Const not_hexenum=0
 Const hexenum=1
 
 
-const val64_no=0
-const val64_willbe=1
+const val64_no=FALSE
+const val64_willbe=TRUE
 
 const direct_convention_input=0
 const ignore_convention_input=1
--- ocompiler-1.orig/src/files/inits/inits.s
+++ ocompiler-1/src/files/inits/inits.s
@@ -56,7 +56,7 @@ set var# 0
 #64bit
 #is init , is tested at any import and is set TRUE/FALSE only at elfobj... syntax
 sd p_is_for_64_value;setcall p_is_for_64_value p_is_for_64();set p_is_for_64_value# (FALSE)
-call stack64_op_set_get((TRUE),(FALSE))
+#call stack64_op_set_get((TRUE),(FALSE))
 call val64_init()
 
 #afterCall
