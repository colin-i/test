Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-4.1) bionic; urgency=medium
 .
   * linux calling convention and rex.w were was not
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2021-11-20

--- ocompiler-1.orig/.ocompiler.txt
+++ ocompiler-1/.ocompiler.txt
@@ -33,6 +33,6 @@ Log import functions
 0 is No; 1 is Yes
 log_import_functions=1
 
-Ignore 64-bits tags if detected
-0 is No; 1 is Yes
+Ignore elfobj64
+0 is No,use linux convention if ocompiler was compiled for linux,else use microsoft; 1 is Yes; 2 is No,and cross-compile
 neg_64=0
\ No newline at end of file
--- ocompiler-1.orig/o.html
+++ ocompiler-1/o.html
@@ -32,7 +32,7 @@
 
 <h3><a href="#includingfiles">X. Including files</a></h3>
 
-<h3><a href="#linux">XI. Creating elf files for linux</a></h3>
+<h3><a href="#exec">XI. Creating executable files</a></h3>
 
 <h3><a href="#object">XII. Creating object files</a></h3>
 
@@ -69,7 +69,7 @@
 	<br>
 	There are 2 scopes: the global scope and the function scope.
 	<br>
-	The commands are from i386(but with the HEX macro anything can be wrote to code section).
+	The commands are from i386 with extension for x86-64 (but with the HEX macro anything can be wrote to code section).
 </p>
 
 <h3><a name="declaringdata">Declaring data</a></h3>
@@ -248,7 +248,7 @@
 	</p>
 <br>
 	<p>
-	Operations can be performed at declarations with arithmetic (+,-,*,/,$) and bitwise (&,|,^) signs.
+	Operations can be performed at declarations with arithmetic (+,-,*,/,$) and bitwise (&,|,^,~) signs. - and ~ can prefix a number/constant.
 	<br>
 	Example:
 	<br>
@@ -320,7 +320,7 @@
 	<br>
 	The return command is used to terminate the program or a function.
 	<br>
-	It returns the value. The asm value termination is <i>ret</i> (0xc3). To return <i>int 0x80</i>(0xcd,0x80;linux sys_exit;eax=1,ebx=return value) use <b>Exit</b>. If the scope is started with <b>EntryLinux</b> all returns will use <i>exit code</i> at <i>return</i> commands.
+	It returns the value. The asm value termination is <i>ret</i> (0xc3). To return <i>int 0x80</i>(0xcd,0x80;linux sys_exit;eax=1,ebx=return value) use <b>Exit</b>. If the scope is started with <b>EntryLinux</b> all returns from the main scope will use <i>exit code</i> at <i>return</i> commands.
 	<br>
 	Example:
 	<br>
@@ -347,49 +347,11 @@
         set string "text test"<br>
         #string will point to "text test"</a>
 	</p>
-	<p>
-	3. Incrementation
-	<br>
-	Language command: <b>Inc</b>
-	<br>
-	The incrementation command adds one to the value.
-	<br>
-	Example:
-	<br>
-	<a class="code">
-        Data value=30<br>
-        Inc value<br>
-        #the value will be 31</a>
-	<b>IncSt</b> adds 4 bytes to the argument or 8 bytes when building for 64-bit application.
-	<br>
-	Example:
-	<br>
-	<a class="code">
-        sd x#2;sd z^x<br>
-        set z# 1;incst z;set z# 2<br>
-        add z# x<br>
-        #at z# will be 3</a>
-	</p>
-	<p>
-	4. Decrementation
-	<br>
-	Language command: <b>Dec</b>
-	<br>
-	The decrementation command substracts one from the value.
-	<br>
-	Example:
-	<br>
-	<a class="code">
-        Data value=30<br>
-        Dec value<br>
-        #the value will be 29</a>
-	</p>
 </p>
 
 
 <h3><a name="arithmeticoperations">IV. Arithmetic operations</a></h3>
 <p>
-	O language has 4 arithmetic operations.
 	<p>
 	1. Addition
 	<br>
@@ -404,7 +366,7 @@
         #the valueA will be 50</a>
 	</p>
 	<p>
-	2. Substraction
+	2. Subtraction
 	<br>
 	Language command: <b>Sub</b>
 	<br>
@@ -417,7 +379,7 @@
         #the valueA will be -10</a>
 	</p>
 	<p>
-	3. Multiplication
+	3. Multiplication (signed)
 	<br>
 	Language command: <b>Mult</b>
 	<br>
@@ -430,22 +392,74 @@
         #the valueA will be 600</a>
 	</p>
 	<p>
-	4. Division
+	4. Division (signed)
 	<br>
-	Language command: <b>Div</b>
+	Language command: <b>Div</b> <b>Rem</b>
 	<br>
 	Example:
 	<br>
 	<a class="code">
-        Data valueA=40<br>
+        Data valueA=465<br>
         Data valueB=20<br>
         Div valueA valueB<br>
-        #the valueA will be 2</a>
+        #the valueA will be 23<br>
+        Rem valueA valueB<br>
+        #the valueA will be 3</a>
+	</p>
+	<p>
+	5. Incrementation
+	<br>
+	Language command: <b>Inc</b> <b>IncSt</b>
+	<br>
+	The incrementation command adds one to the value.
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        Data value=30<br>
+        Inc value<br>
+        #the value will be 31</a>
+	<b>IncSt</b> adds 4 bytes to the argument or 8 bytes when building for 64-bit application.
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        sd x#2;sd z^x<br>
+        set z# 1;incst z;set z# 2<br>
+        add z# x<br>
+        #at z# will be 3</a>
+	</p>
+	<p>
+	6. Decrementation
+	<br>
+	Language command: <b>Dec</b>
+	<br>
+	The decrementation command subtracts one from the value.
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        Data value=30<br>
+        Dec value<br>
+        #the value will be 29</a>
+	</p>
+	<p>
+	7. Negation
+	<br>
+	Language command: <b>Neg</b>
+	<br>
+	Subtract the operand from 0.
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        Data value=30<br>
+        Neg value<br>
+        #the value will be -30</a>
 	</p>
 </p>
 <h3><a name="bitwiseoperations">V. Bitwise operations</a></h3>
 <p>
-	O language has 4 bitwise operations.
 	<p>
 	1. And
 	<br>
@@ -489,6 +503,29 @@
         Not valueA<br>
         #the valueA will be 0xF0f0F0f0</a>
 	</p>
+	<p>
+	5. ShL
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        sd shift_left_once=2<br>
+        shl shift_left_once<br>
+        #the value will be 4</a>
+	</p>
+	<p>
+	6. ShR SaR
+	<br>
+	Example:
+	<br>
+	<a class="code">
+        sd shift_right_once=0x10<br>
+        SHR shift_right_once<br>
+        #the value will be 8</a>
+        sd shift_right_signed_once=-2<br>
+        SaR shift_right_signed_once<br>
+        #the value will be -1</a>
+	</p>
 </p>
 <h3><a name="usingpointers">VI. Using pointers</a></h3>
 <p>
@@ -653,9 +690,9 @@
         Include "files\\main.o"</a>
 	</p>
 </p>
-<h3><a name="linux">XI. Creating elf files for linux</a></h3>
+<h3><a name="exec">XI. Creating executable files</a></h3>
 <p>
-	Executable and Linking Format (ELF) files can be created for Unix - System V, operable on linux platforms.
+	Exe files for windows will be created by default. Executable and Linking Format (ELF) files can be created for Unix - System V, operable on linux platforms. <i>format elf</i> will override the default <i>format exe</i>.
 	<p>
 	Example:
 	<br>
@@ -697,21 +734,25 @@
 	</p>
   </div>
   <div>
-	64-bit objects with some 64-bit code commands for Microsoft calling convention can be created by adding <b>64Microsoft</b> at <i>Format ElfObj</i>.<br>
-	To call with Microsoft calling convention use <b>ImportX</b>. To set the 64-bit return value use <b>SetX</b>. To prepare 64-bit convention function entry use <b>FunctionX</b>.
+	64-bit objects with 64-bit stack data and Microsoft/Linux calling convention can be created by adding <b>64</b> at <i>Format ElfObj</i>.<br>
+	To mark a function for 64-bit convention convention import with <b>ImportX</b> or declare with <b>FunctionX</b>.
 	<p>
 	Example:
 	<br>
 	<a class="code">
-        Format ElfObj64Microsoft<br>
+        Format ElfObj64<br>
         Entry main(data *argc,data *argv)<br>
         importx "printf" printf<br>
-        data returnvalue#1;data test#1<br>
-        setxcall returnvalue printf("Test: ")<br>
-        call printf("Low: %i, High: %i",returnvalue,test)<br>
-        Return 1</a>
+        if :!=8<br>
+          call printf("Not at 64 bits")<br>
+          return 1<br>
+        endif<br>
+        sd returnvalue<br>
+        setcall returnvalue printf("Test: ")<br>
+        call printf("long %lx,returnvalue)<br>
+        Return 0</a>
 	</p>
-	64-bit can be ignored from preferences.
+	64-bit can be ignored from preferences. Cross-compiles can be made at the same option from preferences.
   </div>
 </p>
 <h3><a name="otheroperations">XIII. Other operations</a></h3>
@@ -730,7 +771,7 @@
 	<br>
 	Write bytes in the code section.
 	<br>
-	4. Warnings
+	4. Warning
 	<br>
 	Turn on or off the warnings.
 	<p>
@@ -744,7 +785,8 @@
         #this will write 3 bytes in the code section<br>
         warning off<br>
         import "common_function" common<br>
-        #if the warnings are on this will let the function in peace</a>
+        #useful when having a header in multiple objects<br>
+        warning on</a>
 	</p>
 	<p>
 	When the option function_name from the .ocompiler.txt file is set to Yes(1), the name is wrote in the code section above the function, for debugging asm code.<br>
--- ocompiler-1.orig/src/files/actions/main/index.s
+++ ocompiler-1/src/files/actions/main/index.s
@@ -133,9 +133,14 @@ If comsize!=0
 		EndElse
 		If errormsg==zero
 			If comsize!=zero
-				Chars _unreccomaftererr="Unrecognized data after command."
-				Str unreccomaftererr^_unreccomaftererr
-				Set errormsg unreccomaftererr
+				if content#!=(asciiNumber)
+					Chars _unreccomaftererr="Unrecognized data after command."
+					Str unreccomaftererr^_unreccomaftererr
+					Set errormsg unreccomaftererr
+				else
+					#this is comment after command
+					Call advancecursors(pcontent,pcomsize,comsize)
+				endelse
 			#twoparse==2 more
 			#after the first noncomment command, the format command cannot be changed
 			elseif formatdefined==1;Set formatdefined 2
--- ocompiler-1.orig/src/files/actions/main/index/callex.s
+++ ocompiler-1/src/files/actions/main/index/callex.s
@@ -11,48 +11,40 @@ if errormsg==(noerror)
 		setcall errormsg twoargs(pcontent,pcomsize,(cCALLEX),(NULL))
 		if errormsg==(noerror)
 			#
-			sd callex64;setcall callex64 is_for_64_is_impX_or_fnX_get()
-			if callex64==(TRUE)
-				setcall errormsg callex64_call((microsoft_convention_preset_args))
-			endif
-			#
-			if errormsg==(noerror)
+			sd callex_data;sd callex_sz
+			const callex_regopcode=ecxregnumber*toregopcode
+			sd callex_bool;setcall callex_bool is_for_64()
+			if callex_bool==(TRUE)
+				sd callex64;setcall callex64 is_for_64_is_impX_or_fnX_get()
+				if callex64==(TRUE)
+					setcall errormsg callex64_call()
+				endif
+				if errormsg==(noerror)
+					const callex_x86_64_start=!
+					#same but with 2 rex, inc je, -2 jmp, and 3* at sib
+					chars callex_x86_64={REX_Operand_64,0x81,0xf9,0,0,0,0,0x74,8,REX_Operand_64,0xFF,1*toregopcode|ecxregnumber|regregmod,0xff,6*toregopcode|espregnumber,3*tomod|callex_regopcode,0xEB,0xef}
+					set callex_sz (!-callex_x86_64_start);set callex_data #callex_x86_64
+				endif
+			else
 				const callex_start=!
 				# ## cmp ecx,0
-				chars callex_c1={0x81,0xf9};data *=0
+				chars callex_i386={0x81,0xf9};data *=0
 				#je ###
-				chars *={0x74};chars callex_je#1
-					#dec ecx
-					chars *=0xFF;chars *=1*toregopcode|ecxregnumber|0xc0
-				const callex_size1=!-callex_start
-					# mov [eax+ecx*4],edx  this is gdb view
-					chars callex_c2=0x8b;chars *=edxregnumber*toregopcode|4;chars callex_sib#1
-					#push e(r)dx
-					chars *=0x52
-					#jmp ##
-					chars *=0xEB;chars callex_jmp#1
-				# ###
-				const callex_size2=!-callex_start-callex_size1
-				#set jumps and mov.sib: index ecx and base eax
-				set callex_sib 8
-				#set jumps,index*4(2) or *8(3)
-				sd callex_bool;setcall callex_bool is_for_64()
-				set callex_je 0x08;set callex_jmp 0xf0
-				if callex_bool==(FALSE);or callex_sib (2*tomod)
-				else;#for 64
-					or callex_sib (3*tomod)
-					inc callex_je;dec callex_jmp
-				endelse
+				chars *={0x74};chars *callex_je=7
+				#dec ecx
+				chars *=0xFF;chars *=1*toregopcode|ecxregnumber|0xc0
+				# push [eax+ecx*4]
+				chars *callex_c2=0xff;chars *=6*toregopcode|espregnumber;chars *callex_sib=2*tomod|callex_regopcode
+				#jmp ##
+				chars *=0xEB;chars *callex_jmp=0xf1
 				#
-				SetCall errormsg addtosec(#callex_c1,(callex_size1),ptrcodesec)
+				set callex_sz (!-callex_start);set callex_data #callex_i386
+			endelse
+			#
+			if errormsg==(noerror)
+				SetCall errormsg addtosec(callex_data,callex_sz,ptrcodesec)
 				if errormsg==(noerror)
-					if callex_bool==(TRUE);call rex_w(#errormsg);endif
-					if errormsg==(noerror)
-						SetCall errormsg addtosec(#callex_c2,(callex_size2),ptrcodesec)
-						if errormsg==(noerror)
-							setcall errormsg write_function_call(top_data,bool_indirect,(TRUE))
-						endif
-					endif
+					setcall errormsg write_function_call(top_data,bool_indirect,(TRUE))
 				endif
 			endif
 		endif
--- ocompiler-1.orig/src/files/actions/main/index/format.s
+++ ocompiler-1/src/files/actions/main/index/format.s
@@ -20,14 +20,22 @@ If formatresponse==false
 		
 		sd p_is_for_64_resp;setcall p_is_for_64_resp p_is_for_64()
 		
-		SetCall elfobjformresp stringsatmemspc(pcontent,pcomsize,ptrelfobjformat,false,"64MICROSOFT",p_is_for_64_resp)
+		SetCall elfobjformresp stringsatmemspc(pcontent,pcomsize,ptrelfobjformat,false,"64",p_is_for_64_resp)
 		If elfobjformresp==true
 			sd neg_64;setcall neg_64 p_neg_is_for_64()
-			if neg_64#==(TRUE)
+			if neg_64#==1
 				if p_is_for_64_resp#==(TRUE)
 					set p_is_for_64_resp# (FALSE)
 				endif
-			endif
+			elseif p_is_for_64_resp#==(TRUE)
+				if neg_64#==0
+					call convdata((convdata_init),(variable_convention))
+				elseif (variable_convention)==(ms_convention)
+					call convdata((convdata_init),(lin_convention))
+				else
+					call convdata((convdata_init),(ms_convention))
+				endelse
+			endelseif
 			Set object true
 			SetCall errormsg elfaddstrsym(ptrnull,null,null,null,null,null,ptrtable)
 			If errormsg==noerr
--- ocompiler-1.orig/src/files/actions/main/index/function.s
+++ ocompiler-1/src/files/actions/main/index/function.s
@@ -14,20 +14,22 @@ ElseIf programentrypoint!=codesecReg
 	Call sprintf(allocerrormsg,fnafteren,ptrentrystartfile,entrylinenumber)
 	Set errormsg allocerrormsg
 Else
-	If subtype==(cENTRYLINUX)
-		set subtype (cENTRY)
-		set el_b_p# (TRUE)
-	endif
-	If subtype==(cENTRY)
+	sd el_or_e=FALSE;if subtype==(cENTRY);set el_or_e (TRUE);elseif subtype==(cENTRYLINUX);set el_or_e (TRUE);endelseif
+	If el_or_e==(TRUE)
 		Data referencebit=referencebit
 		Set objfnmask referencebit
 		if twoparse==1
 			set fnavailable two
+			If subtype==(cENTRYLINUX)
+				set el_b_p# (TRUE)
+			endif
 		endif
 	Else
 		Set objfnmask null
 		Set innerfunction true
 	EndElse
-	Data declarefn=declarefunction
-	SetCall errormsg parsefunction(pcontent,pcomsize,declarefn,subtype)
+	if errormsg==(noerror)
+		Data declarefn=declarefunction
+		SetCall errormsg parsefunction(pcontent,pcomsize,declarefn,subtype)
+	endif
 EndElse
\ No newline at end of file
--- ocompiler-1.orig/src/files/functions/64bit.s
+++ ocompiler-1/src/files/functions/64bit.s
@@ -15,6 +15,16 @@ function p_neg_is_for_64()
 	return #bool
 endfunction
 
+function scope64_p()
+	data bool#1;return #bool
+endfunction
+function scope64_get()
+	sd p;setcall p scope64_p();return p#
+endfunction
+function scope64_set(sd b)
+	sd p;setcall p scope64_p();set p# b
+endfunction
+
 #get
 function is_for_64_is_impX_or_fnX_p_get();data b#1;return #b;endfunction
 #get
@@ -69,12 +79,10 @@ endfunction
 
 
 ##REX_W
-#size of prefix(=1)
 function rex_w(sd p_err)
 	Data code%ptrcodesec
-	chars r=REX_Operand_64;data sz=1
-	SetCall p_err# addtosec(#r,sz,code)
-	return sz
+	chars r=REX_Operand_64
+	SetCall p_err# addtosec(#r,1,code)
 endfunction
 #er
 function rex_w_if64()
@@ -86,6 +94,14 @@ function rex_w_if64()
 	call rex_w(#err)
 	return err
 endfunction
+function is_big(sd dataarg)
+	sd b;setcall b is_stack(dataarg)
+	if b!=(NULL)
+		setcall b is_for_64()
+		return b
+	endif
+	return (FALSE)
+endfunction
 
 function stack64_op_set()
 	sd b;setcall b is_for_64()
@@ -106,12 +122,16 @@ function stack64_op(sd takeindex,sd p_mo
 	call stack64_op_set_get((TRUE),(FALSE))
 	#return if outside mod=3
 	if p_mod#==(RegReg);return (noerror);endif
+	
+	sd err
+	SetCall err val64_phase_3();If err!=(noerror);Return err;EndIf
+	
 	#set outside mod=3
 	set p_mod# (RegReg)
 	#mov reg,[reg]
 	chars x=moveatprocthemem;chars y#1
 	setcall y formmodrm((mod_0),takeindex,takeindex)
-	sd err;data code%ptrcodesec
+	data code%ptrcodesec
 	setcall err addtosec(#x,2,code)
 	return err
 endfunction
@@ -132,13 +152,9 @@ endfunction
 function val64_phase_1()
 	sd b;setcall b is_for_64()
 	if b==(TRUE)
-		sd p;setcall p val64_p_get();set p# 1
+		sd p;setcall p val64_p_get();set p# (val64_willbe)
 	endif
 endfunction
-function val64_phase_2()
-	sd p;setcall p val64_p_get()
-	if p#==1;set p# 2;endif
-endfunction
 #er
 function val64_phase_3()
 	sd p;setcall p val64_p_get()
@@ -152,31 +168,125 @@ function val64_p_get()
 	data x#1;return #x
 endfunction
 
-function function_call_64m(sd hex_1,sd hex_2,sd hex_3,sd hex_4,ss args_push,sd hex_x,sd conv)
+function convdata(sd type,sd dest)
+	if type==(convdata_total)
+		data nr_of_args#1
+		return nr_of_args
+	elseif type==(convdata_call)
+		#rdi
+		chars hex_1={REX_Operand_64,moveatprocthemem,ediregnumber*toregopcode|espregnumber,0x24,0}
+		#rsi
+		chars hex_2={REX_Operand_64,moveatprocthemem,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
+		#rcx/rdx,rsp+
+		chars hex_3={REX_Operand_64,moveatprocthemem};chars c3#1;chars *=0x24;chars c3o#1
+		#rdx/rcx,rsp+
+		chars hex_4={REX_Operand_64,moveatprocthemem};chars c4#1;chars *=0x24;chars c4o#1
+		#r8,rsp+
+		chars hex_5={REX_R8_15,moveatprocthemem,0x44,0x24};chars c5o#1
+		#r9,rsp+
+		chars hex_6={REX_R8_15,moveatprocthemem,0x4C,0x24};chars c6o#1
+		if nr_of_args==(lin_convention)
+			set dest# #hex_1
+			incst dest;set dest# #hex_2
+			incst dest
+		endif
+		set dest# #hex_3
+		incst dest;set dest# #hex_4
+		incst dest;set dest# #hex_5
+		incst dest;set dest# #hex_6
+		return (void)
+	elseif type==(convdata_fn)
+		const functionxlin_start=!
+		#pop a
+		chars functionxlin_code=0x58
+		#sub esp,conv8
+		chars *={REX_Operand_64,0x83,5*toregopcode|regregmod|espregnumber};chars *=lin_convention*qwsz
+		#push a
+		chars *=0x50
+		chars *={REX_Operand_64,moveatmemtheproc,ediregnumber*toregopcode|disp8mod|espregnumber,0x24,8}
+		chars *={REX_Operand_64,moveatmemtheproc,esiregnumber*toregopcode|disp8mod|espregnumber,0x24,16}
+		const functionx_start=!
+		#mov [rsp++8h],rcx
+		chars functionx_code={REX_Operand_64,moveatmemtheproc};chars f3#1;chars *=0x24;chars f3o#1
+		#mov [rsp++10h],rdx
+		chars *={REX_Operand_64,moveatmemtheproc};chars f4#1;chars *=0x24;chars f4o#1
+		#mov [rsp++18h],r8
+		chars *={REX_R8_15,moveatmemtheproc,0x44,0x24};chars f5o#1
+		#mov [rsp++20h],r9
+		chars *={REX_R8_15,moveatmemtheproc,0x4C,0x24};chars f6o#1
+		if nr_of_args==(ms_convention)
+			set dest# (!-functionx_start)
+			return #functionx_code
+		else
+			set dest# (!-functionxlin_start)
+			return #functionxlin_code
+		endelse
+	endelseif
+	set nr_of_args dest
+	if nr_of_args==(ms_convention)
+		set c3 0x0C;set c3o 0
+		set c4 0x54;set c4o 8
+		set c5o 16;set c6o 24
+		set f3 0x4C;set f3o 8
+		set f4 0x54;set f4o 16
+		set f5o 24;set f6o 32
+	else
+		set c3 0x54;set c3o 16
+		set c4 0x4C;set c4o 24
+		set c5o 32;set c6o 40
+		set f3 0x54;set f3o 24
+		set f4 0x4C;set f4o 32
+		set f5o 40;set f6o 48
+	endelse
+endfunction
+
+function function_call_64fm(sd nr_of_args,sd hex_n,sd conv,sd code)
 	sd err
-	Data code%ptrcodesec
-	sd nr_of_args;setcall nr_of_args nr_of_args_64need()
 	if nr_of_args>0
-		SetCall err addtosec(hex_1,4,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(hex_n#,4,code);If err!=(noerror);Return err;EndIf
 		if nr_of_args>1
-			SetCall err addtosec(hex_2,5,code);If err!=(noerror);Return err;EndIf
+			incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
 			if nr_of_args>2
-				SetCall err addtosec(hex_3,5,code);If err!=(noerror);Return err;EndIf
+				incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
 				if nr_of_args>3
-					SetCall err addtosec(hex_4,5,code);If err!=(noerror);Return err;EndIf
+					incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+					if conv==(lin_convention)
+						if nr_of_args>4
+							incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+							if nr_of_args>5
+								incst hex_n;SetCall err addtosec(hex_n#,5,code);If err!=(noerror);Return err;EndIf
+							endif
+						endif
+					endif
 				endif
 			endif
 		endif
 	endif
-	#shadow space
-	set args_push# conv
-	if nr_of_args<args_push#;set args_push# nr_of_args;endif
-	sub args_push# conv;mult args_push# -1
-	if args_push#!=0
-		mult args_push# (qwsz)
-		call rex_w(#err);If err!=(noerror);Return err;EndIf
-		SetCall err addtosec(hex_x,3,code);If err!=(noerror);Return err;EndIf
-	endif
+	return (noerror)
+endfunction
+function function_call_64f(sd hex_n,sd conv,sd code)
+	sd err
+	sd nr_of_args;setcall nr_of_args nr_of_args_64need()
+	#
+	setcall err function_call_64fm(nr_of_args,hex_n,conv,code);If err!=(noerror);Return err;EndIf
+	#
+	if conv==(ms_convention)
+		if nr_of_args<conv
+			#shadow space
+			#sub esp,x;default 4 args stack space convention
+			chars hex_w={REX_Operand_64,0x83,0xEC};chars argspush#1
+			set argspush nr_of_args;sub argspush conv;mult argspush (-1*qwsz)
+			SetCall err addtosec(#hex_w,4,code);If err!=(noerror);Return err;EndIf
+		endif
+	elseif nr_of_args>0
+		#lin_convention
+		#add esp,x
+		chars hex_x={REX_Operand_64,0x83,regregmod|espregnumber};chars adjuster#1
+		if nr_of_args>conv;set adjuster conv;else;set adjuster nr_of_args;endelse
+		mult adjuster (qwsz)
+		SetCall err addtosec(#hex_x,4,code);If err!=(noerror);Return err;EndIf
+	endelseif
+	#
 	#stack align,more to see when the offset was taken
 	sd stack_align_p;setcall stack_align_p stack_align_off_p_get()
 	ss code_pointer;call getcont(code,#code_pointer)
@@ -188,125 +298,136 @@ function function_call_64m(sd hex_1,sd h
 	else;set code_pointer# (0x72);endelse
 	return (noerror)
 endfunction
-function function_call_64(sd is_callex,sd conv)
+function function_call_64(sd is_callex)
+	sd conv;setcall conv convdata((convdata_total))
 	sd err
 	Data code%ptrcodesec
+	sd hex_1;sd hex_2;sd hex_3;sd hex_4;sd hex_5;sd hex_6
+	call convdata((convdata_call),#hex_1)
 	#
-	#rcx,[rsp+0]
-	chars hex_1={REX_Operand_64,0x8B,0x0C,0x24}
-	#rdx,rsp+8
-	chars hex_2={REX_Operand_64,0x8B,0x54,0x24,0x08}
-	#r8,rsp+16
-	chars hex_3={REX_R8_15,0x8B,0x44,0x24,0x10}
-	#r9,rsp+24
-	chars hex_4={REX_R8_15,0x8B,0x4C,0x24,0x18}
-	#sub esp,x;default 4 args stack space convention
-	chars hex_x={0x83,0xEC};chars args_push#1
-		
 	if is_callex==(FALSE)
-		setcall err function_call_64m(#hex_1,#hex_2,#hex_3,#hex_4,#args_push,#hex_x,conv)
+		setcall err function_call_64f(#hex_1,conv,code)
 		Return err
 	endif
-	#
-	#cmp eax,imm32
-	chars cmp_je=0x3d;data cmp_imm32#1
-	#jump
-	chars callex_jump#1;chars j_off#1
 	##
-	#mov eax,ebx
-	chars find_args={0x8b,0xc3}
-	#sub eax,esp
-	chars *={0x2b,0xc4}
-	#edx=0;ecx=QWORD;div edx:eax,ecx
-	chars *=0xba;data *=0;chars *=0xb9;data *=qwsz;chars *={0xF7,0xF1}
-	#
-	SetCall err addtosec(#find_args,0x10,code);If err!=(noerror);Return err;EndIf
-	#jump if equal
-	set callex_jump (0x74)
+	#mov edx,eax
+	chars find_args={REX_Operand_64,0x8b,edxregnumber|regregmod}
+	SetCall err addtosec(#find_args,3,code);If err!=(noerror);Return err;EndIf
 	#
-	set cmp_imm32 0
-	set j_off (4+7+5+7+5+7+5)
-	SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-		SetCall err addtosec(#hex_1,4,code);If err!=(noerror);Return err;EndIf
-	#
-		set cmp_imm32 1
-		set j_off (5+7+5+7+5)
-		SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-			SetCall err addtosec(#hex_2,5,code);If err!=(noerror);Return err;EndIf
+	#convention and shadow space
+	#cmp rax,imm32
+	chars cmp_je={REX_Operand_64,0x3d};data cmp_imm32#1
+	set cmp_imm32 conv;dec cmp_imm32
+	#jump if above
+	chars *callex_jump=0x77;chars j_off#1
 	#
-			set cmp_imm32 2
-			set j_off (5+7+5)
-			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#hex_3,5,code);If err!=(noerror);Return err;EndIf
+	#convention gdb view,and gui view
+	#push a
+	chars callex_conv=0x50
+	#neg al
+	chars *={0xf6,3*toregopcode|regregmod}
+	#add al conv
+	chars *=0x04;chars conv_neg#1
+	#mov cl 5
+	chars *={0xb1,5}
+	#mult al cl
+	chars *={0xf6,4*toregopcode|ecxregnumber|regregmod}
+	#call
+	chars *={0xe8,0,0,0,0}
+	#pop c
+	chars *=0x59
+	#add rax rcx    can be --image-base=int64 but more than 0xff000000 x64 dbg says invalid but there is int64 rip in parent x64 debug
+	chars *={REX_Operand_64,0x01,ecxregnumber|regregmod}
+	#pop a
+	chars *=0x58
+	#add rcx,imm8
+	chars *={REX_Operand_64,0x83,ecxregnumber|regregmod,11}
+	#j cl
+	chars *={0xff,4*toregopcode|ecxregnumber|regregmod}
 	#
-				set cmp_imm32 3
-				set j_off (5)
-				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-					SetCall err addtosec(#hex_4,5,code);If err!=(noerror);Return err;EndIf
-	#jump if above
-	set callex_jump (0x77)
-	set args_push (qwsz)
-	#4*REX.W
-	data jump64#1;set jump64 conv
+	set conv_neg conv
+	set j_off 25
+	SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(#callex_conv,25,code);If err!=(noerror);Return err;EndIf
+	if conv==(lin_convention)
+		SetCall err addtosec(hex_6,5,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(hex_5,5,code);If err!=(noerror);Return err;EndIf
+	endif
+	SetCall err addtosec(hex_4,5,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(hex_3,5,code);If err!=(noerror);Return err;EndIf
+	SetCall err addtosec(hex_2,5,code);If err!=(noerror);Return err;EndIf
+	ss rspwithoffset;set rspwithoffset hex_1;add rspwithoffset 2;or rspwithoffset# (disp8mod)
+	SetCall err addtosec(hex_1,5,code);If err!=(noerror);Return err;EndIf
+	xor rspwithoffset# (disp8mod)
 	#
-	set cmp_imm32 3
-	set j_off (3+7+3+7+3+7+3);add j_off jump64
-	SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-		subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-		SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-		set cmp_imm32 2
-		set j_off (3+7+3+7+3);add j_off jump64
-		SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-			subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-			SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-			set cmp_imm32 1
-			set j_off (3+7+3);add j_off jump64
-			SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-				subcall jump64 rex_w(#err);If err!=(noerror);Return err;EndIf
-				SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-				set cmp_imm32 0
-				set j_off (3);add j_off jump64
-				SetCall err addtosec(#cmp_je,7,code);If err!=(noerror);Return err;EndIf
-					call rex_w(#err);If err!=(noerror);Return err;EndIf
-					SetCall err addtosec(#hex_x,3,code);If err!=(noerror);Return err;EndIf
-	return (noerror)
+	#shadow space
+	if conv==(ms_convention)
+		#neg al
+		chars callex_shadow={0xf6,3*toregopcode|regregmod}
+		#add al conv-1
+		chars *=0x04;chars shadow_neg#1
+		#push qwordsz
+		chars *={0x6a,qwsz}
+		#mul al [esp]
+		chars *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
+		#sub rsp,rax
+		chars *={REX_Operand_64,0x2b,espregnumber*toregopcode|regregmod}
+		#
+		set shadow_neg conv;dec shadow_neg
+		set j_off 12
+		SetCall err addtosec(#cmp_je,8,code);If err!=(noerror);Return err;EndIf
+		SetCall err addtosec(#callex_shadow,12,code)
+	else
+		#lin_convention
+		#cmp rax,imm32
+		chars callex_unshadow={REX_Operand_64,0x3d};data *cmp_imm32=lin_convention
+		#jump if below or equal
+		chars *callex_jump=0x76;chars *j_off=10
+		chars *rax_conv={REX_Operand_64,0xb8};data *={lin_convention,0}
+		#push qwordsz
+		chars *={0x6a,qwsz}
+		#inc eax
+		chars *={0xfe,regregmod}
+		#mul al [esp]
+		chars *={0xf6,4*toregopcode|espregnumber,espregnumber*toregopcode|espregnumber}
+		#add rsp,rax
+		chars *={REX_Operand_64,0x03,espregnumber*toregopcode|regregmod}
+		#
+		SetCall err addtosec(#callex_unshadow,28,code)
+	endelse
+	return err
 endfunction
 #err
 function function_start_64()
 	Data code%ptrcodesec
+	sd data;sd sz
+	setcall data convdata((convdata_fn),#sz)
 	sd err
-	const functionx_start=!
-	#mov [rsp+8h],rcx
-	chars functionx_code={REX_Operand_64,moveatmemtheproc,0x4C,0x24,0x08}
-	#mov [rsp+10h],rdx
-	chars *={REX_Operand_64,moveatmemtheproc,0x54,0x24,0x10}
-	#mov [rsp+18h],r8
-	chars *={REX_R8_15,moveatmemtheproc,0x44,0x24,0x18}
-	#mov [rsp+20h],r9
-	chars *={REX_R8_15,moveatmemtheproc,0x4C,0x24,0x20}
-	SetCall err addtosec(#functionx_code,(!-functionx_start),code)
+	SetCall err addtosec(data,sz,code)
+	return err
 endfunction
 #err
-function callex64_call(sd conv)
+function callex64_call()
+	sd conv;setcall conv convdata((convdata_total))
 	#Stack aligned on 16 bytes.
 	const callex64_start=!
 	#bt rsp,3 (bit offset 3)
 	chars callex64_code={REX_Operand_64,0x0F,0xBA,bt_reg_imm8|espregnumber,3}
 	#jc @ (jump when rsp=....8)
-	chars *=0x72;chars *=6+2+4+2+2
-	#6cmp ecx,5
-	chars *={0x81,0xf9};data jcase1#1
+	chars *=0x72;chars *=7+2+4+2+2
+	#7cmp ecx,5
+	chars *={REX_Operand_64,0x81,0xf9};data jcase1#1
 	set jcase1 conv;inc jcase1
 	#2jb $
-	chars *=0x72;chars *=4+2+2+6+2+4+2+4
+	chars *=0x72;chars *=4+2+2+7+2+4+2+4
 	#4bt ecx,0
 	chars *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
 	#2jc %
-	chars *=0x72;chars *=2+6+2+4+2
+	chars *=0x72;chars *=2+7+2+4+2
 	#2jmp $
-	chars *=0xEB;chars *=6+2+4+2+4
-	#6@ cmp ecx,5
-	chars *={0x81,0xf9};data jcase2#1
+	chars *=0xEB;chars *=7+2+4+2+4
+	#7@ cmp ecx,5
+	chars *={REX_Operand_64,0x81,0xf9};data jcase2#1
 	set jcase2 conv;inc jcase2
 	#2jb %
 	chars *=0x72;chars *=4+2
@@ -314,9 +435,11 @@ function callex64_call(sd conv)
 	chars *={0x0F,0xBA,bt_reg_imm8|ecxregnumber,0}
 	#2jc $
 	chars *=0x72;chars *=4
-	#4% sub rsp,8
+	#%
+	#4 sub rsp,8
 	chars *={REX_Operand_64,0x83,0xEC};chars *=8
 	#$
+	chars *keep_nr_args={REX_Operand_64,0x8b,edxregnumber*toregopcode|ecxregnumber|regregmod}
 	sd ptrcodesec%ptrcodesec
 	sd err
 	SetCall err addtosec(#callex64_code,(!-callex64_start),ptrcodesec)
--- ocompiler-1.orig/src/files/functions/actions/argstwo.s
+++ ocompiler-1/src/files/functions/actions/argstwo.s
@@ -1,5 +1,4 @@
 
-
 #err
 Function twoargs(data ptrcontent,data ptrsize,data subtype,data ptrcondition)
 	Data lowprim#1
@@ -62,6 +61,8 @@ Function twoargs(data ptrcontent,data pt
 	Chars two=2
 
 	Set primcalltype false
+	
+	sd big;sd rem
 	If ptrcondition==false
 		#imm second arg
 		call setimm()
@@ -69,14 +70,7 @@ Function twoargs(data ptrcontent,data pt
 		if subtype_test!=0
 			xor subtype (x_call_flag)
 			Set primcalltype true
-			if subtype==(cSETX)
-				if lowprim==(TRUE)
-					return "SetX is not encodable at an 8-bit argument."
-				endif
-				set subtype (cSET);call val64_phase_1()
-			endif
-		elseif subtype==(cSETX);return "SetX is used at SetXCall only.64 bit variables are not available at the moment."
-		endelseif
+		endif
 		if subtype==(cSET)
 			Set opprim atmemtheproc
 		ElseIf subtype==(cADD)
@@ -90,6 +84,10 @@ Function twoargs(data ptrcontent,data pt
 			Set regprep ecxreg
 			Set regopcode ecxreg
 			Set divmul true
+			if lowprim==(FALSE);setcall big is_big(dataargprim)
+			else;set big (FALSE);endelse
+			if subtype==(cREM);set rem (TRUE)
+			else;set rem (FALSE);endelse
 		ElseIf subtype<=(cXOR)
 			Set sameimportant false
 			If subtype==(cAND)
@@ -158,16 +156,24 @@ Function twoargs(data ptrcontent,data pt
 			EndElse
 		EndElseIf
 	Else
+		sd store_big;set store_big (FALSE)
 		If lowprim==lowsec
 			If lowprim==true
 				Dec opprim
 				Dec opsec
-			EndIf
+			else
+			#this code with the rex promotes, if this near comp later,undefined dataargsec(1==1)will go wrong in is_big, viol
+				setcall imm getisimm()
+				if imm==false
+					setcall store_big is_big(dataargsec)
+				endif
+			endelse
 		Else
 			Dec opsec
 			Set intchar eaxreg
 			If lowprim==true
 				#case compare low vs high, then: get low on all eax compare with high but op from mem vs proc becomes proc vs mem
+				#note that xor eax,eax will zero rax (not needing xor rax,rax)
 				Add opprim two
 				Data aux#1
 				Set aux dataargprim
@@ -184,6 +190,7 @@ Function twoargs(data ptrcontent,data pt
 	
 	Data codeptr%ptrcodesec
 
+	sd is_sta
 	If primcalltype==false
 		setcall imm getisimm()
 		if imm==true
@@ -193,9 +200,9 @@ Function twoargs(data ptrcontent,data pt
 				add opsec 1
 			elseif subtype==(cCALLEX)
 				add opsec 1
-				sd is_sta;setcall is_sta is_stack(dataargprim)
+				setcall is_sta is_stack(dataargprim)
 				if is_sta!=(NULL)
-					call val64_phase_1();call val64_phase_2()
+					call val64_phase_1()
 				endif
 			endelseif
 		endif
@@ -203,20 +210,20 @@ Function twoargs(data ptrcontent,data pt
 		If errnr!=noerr
 			Return errnr
 		EndIf
-	Else
-		if divmul==(TRUE)
-			#only at multcall and divcall
-			chars transferreturntoecx={0x89,0xc1}
-			str ptrcall^transferreturntoecx
-			data calltransfersize=2
-			setcall errnr addtosec(ptrcall,calltransfersize,codeptr)
-			If errnr!=noerr
-				Return errnr
-			EndIf
-		else
-			call val64_phase_2()
-		endelse
-	EndElse
+	Elseif divmul==(TRUE)
+		#only at multcall and divcall
+		chars transferreturntoecx={0x89,0xc1}
+		str ptrcall^transferreturntoecx
+		data calltransfersize=2
+		if big==(TRUE)
+			call rex_w(#errnr)
+			If errnr!=noerr;Return errnr;EndIf
+		endif
+		setcall errnr addtosec(ptrcall,calltransfersize,codeptr)
+		If errnr!=noerr
+			Return errnr
+		EndIf
+	EndElseif
 	
 	#write first arg, the second already was
 	set p_prefix# remind_first_prefix
@@ -228,23 +235,29 @@ Function twoargs(data ptrcontent,data pt
 		chars immcomparationtake=0xb9
 		set opprim immcomparationtake
 	endif
+
 	SetCall errnr writeop_immfilter(dataargprim,opprim,noreg,sufixprim,eaxreg)
 	If errnr!=noerr
 		Return errnr
 	EndIf
+
 	if imm==true
 		#continue to write the imm comparation(first is imm, second doesnt care)ex: 1(constant)==1(constant)->cmp ecx,eax (eax,ecx can be if switch)
+		#the jump for this is below, if imm or if not imm
 		chars immcompdata#1
 		set immcompdata compimmop
 		chars *immcompdatamodrm=0xc1
 		str immcomp^immcompdata
 		data immcompsz=2
+		if store_big==(TRUE)
+			call rex_w(#errnr)
+			If errnr!=noerr;Return errnr;EndIf
+		endif
 		SetCall errnr addtosec(immcomp,immcompsz,codeptr)
 		If errnr!=noerr
 			Return errnr
 		EndIf
 	endif
-
 	If divmul==true
 		Data regreg=RegReg
 
@@ -262,27 +275,23 @@ Function twoargs(data ptrcontent,data pt
 			Chars d1_1#1
 			Chars d2_0#1
 			Chars *d2_1={0xc0}
-			Chars *d3={0x79,0x02}
+			Chars d3_0=0x79;chars d3_1#1
 			Chars d4_0#1
 			Chars d4_1#1
 			
-			Const bitsregreg=RegReg*8*8
 			Const bitsedxregop=edxregnumber*8
 			Const bitsahregop=ahregnumber*8
 			Const bitsnotop=Notregopcode*8
 
-			Const pre1_1_h=bitsregreg|bitsedxregop|edxregnumber
+			Const pre1_1_h=regregmod|bitsedxregop|edxregnumber
 			Chars predef1_1_high={pre1_1_h}
-			Const pre4_1_h=bitsregreg|bitsnotop|edxregnumber
+			Const pre4_1_h=regregmod|bitsnotop|edxregnumber
 			Chars predef4_1_high={pre4_1_h}
-			Const pre1_1_l=bitsregreg|bitsahregop|ahregnumber
+			Const pre1_1_l=regregmod|bitsahregop|ahregnumber
 			Chars predef1_1_low={pre1_1_l}
-			Const pre4_1_l=bitsregreg|bitsnotop|ahregnumber
+			Const pre4_1_l=regregmod|bitsnotop|ahregnumber
 			Chars predef4_1_low={pre4_1_l}
 
-			Str setdivsign^d1_0
-			Data divsignsize=8
-
 			Chars d1_0ini={0x33}
 			Chars d2_0ini={0x85}
 			Chars d4_0ini={0xf7}
@@ -292,19 +301,31 @@ Function twoargs(data ptrcontent,data pt
 			Set d4_0 d4_0ini
 
 			If lowprim==false
-				Set d1_1 predef1_1_high
-				Set d4_1 predef4_1_high
+				Set	d1_1 predef1_1_high
+				Set	d4_1 predef4_1_high
 			Else
 				Dec d1_0
-				Dec	d2_0
+				Dec d2_0
 				Dec d4_0
 				Set d1_1 predef1_1_low
 				Set d4_1 predef4_1_low
 			EndElse
-			SetCall errnr addtosec(setdivsign,divsignsize,codeptr)
-			If errnr!=noerr
-				Return errnr
-			EndIf
+			SetCall errnr addtosec(#d1_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
+			if big==(TRUE)
+				call rex_w(#errnr)
+				If errnr!=noerr;Return errnr;EndIf
+			endif
+			SetCall errnr addtosec(#d2_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
+			if big==(TRUE)
+				set d3_1 3
+				SetCall errnr addtosec(#d3_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
+				call rex_w(#errnr)
+				If errnr!=noerr;Return errnr;EndIf
+			else
+				set d3_1 2
+				SetCall errnr addtosec(#d3_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
+			endelse
+			SetCall errnr addtosec(#d4_0,2,codeptr);If errnr!=noerr;Return errnr;EndIf
 		EndElse
 
 		Chars opcodexini={0xF7}
@@ -313,7 +334,8 @@ Function twoargs(data ptrcontent,data pt
 		Data sizeex=2
 		Str ptropcodeex^opcodeex
 		Chars storeex#1
-
+		chars storeexrm#1
+		
 		Set opcodeex opcodexini
 		Set storeex atmemtheproc
 
@@ -325,17 +347,37 @@ Function twoargs(data ptrcontent,data pt
 		SetCall modrmex formmodrm(regreg,regopcodeex,ecxreg)
 		Set regopcodeex modrmex
 
+		if big==(TRUE)
+			call rex_w(#errnr)
+			If errnr!=noerr;Return errnr;EndIf
+		endif
 		SetCall errnr addtosec(ptropcodeex,sizeex,codeptr)
 		If errnr!=noerr
 			Return errnr
 		EndIf
 
-		SetCall errnr writeop(dataargprim,storeex,noreg,sufixprim,eaxreg)
+		if lowprim==(TRUE)
+		# str# ss# chars
+		#rdx is ready
+			if rem==(FALSE)
+				setcall storeexrm formmodrm((mod_0),eaxreg,(edxregnumber))
+			else
+				setcall storeexrm formmodrm((mod_0),(ahregnumber),(edxregnumber))
+			endelse
+			setcall errnr addtosec(#storeex,2,codeptr)
+		else
+			if rem==(FALSE)
+				SetCall errnr writeop(dataargprim,storeex,noreg,sufixprim,eaxreg)
+			else
+				SetCall errnr writeoperation(dataargprim,storeex,noreg,sufixprim,(edxregnumber),ecxreg)
+			endelse
+		endelse
 		Return errnr
 	ElseIf ptrcondition!=false
 		Chars jumpifnotcond={0x0f}
 		Chars cond#1
-		Data *jump=0
+		#this will be resolved at endcond
+		Data *jump#1
 
 		Data jumpcond^jumpifnotcond
 		Data conddatasz=6
--- ocompiler-1.orig/src/files/functions/actions/enumcomma.s
+++ ocompiler-1/src/files/functions/actions/enumcomma.s
@@ -7,31 +7,40 @@ function writevar(data ptrvalue,data uni
 	data true=TRUE
 	data false=FALSE
 	data ptrobject%ptrobject
-
-	if ptrobject#==1
-		If ptrrelocbool#==true
-			if stack==false
+	
+	if stack==false
+		if ptrobject#==1
+			If ptrrelocbool#==true
 				#data
 				Data ptraddresses%ptraddresses
 				Data relocoff=0
 				SetCall err adddirectrel_base(ptraddresses,relocoff,relindex,ptrvalue#)
-			else
-				#code
-				data ptrextra%ptrextra
-				data stackoff=rampadd_value_off
-				setcall err adddirectrel_base(ptrextra,stackoff,relindex,ptrvalue#)
-			endelse
+				If err!=noerr
+					Return err
+				EndIf
+			endif
+		endif
+		data ptrdatasec%ptrdatasec
+		SetCall err addtosec(ptrvalue,unitsize,ptrdatasec)
+		return err
+	endif
+	
+	sd for_64;setcall for_64 is_for_64()
+	if ptrobject#==1
+		If ptrrelocbool#==true
+			#code
+			sd stackoff=rampadd_value_off
+			if for_64==(TRUE)
+				inc stackoff
+			endif
+			data ptrextra%ptrextra
+			setcall err adddirectrel_base(ptrextra,stackoff,relindex,ptrvalue#)
 			If err!=noerr
 				Return err
 			EndIf
 		EndIf
 	endif
-	if stack==false
-		data ptrdatasec%ptrdatasec
-		SetCall err addtosec(ptrvalue,unitsize,ptrdatasec)
-	else
-		setcall err addtocodeforstack(ptrvalue#,rightstackpointer)
-	endelse
+	setcall err addtocodeforstack(ptrvalue#,rightstackpointer,for_64)
 	return err
 endfunction
 
--- ocompiler-1.orig/src/files/functions/actions/fn.s
+++ ocompiler-1/src/files/functions/actions/fn.s
@@ -32,6 +32,15 @@ Function unresolvedcallsfn(data struct,d
 	Return err
 EndFunction
 
+#b
+function is_funcx_subtype(sd subtype)
+	if subtype==(cFUNCTIONX)
+		return (TRUE)
+	elseif subtype==(cENTRY)
+		return (TRUE)
+	endelseif
+	return (FALSE)
+endfunction
 #subtype is only when declarefn(not callfn)
 #err
 Function parsefunction(data ptrcontent,data ptrsize,data declare,sd subtype)
@@ -71,6 +80,7 @@ Function parsefunction(data ptrcontent,d
 		Data value#1
 		Data ptrvalue^value
 
+		sd scope64
 		data p_two_parse%cptr_twoparse
 		if p_two_parse#==2
 			Data globalinnerfunction%globalinnerfunction
@@ -88,7 +98,9 @@ Function parsefunction(data ptrcontent,d
 			Data mask#1
 			Data ptrobjfnmask%ptrobjfnmask
 			Set mask ptrobjfnmask#
-			if subtype==(cFUNCTIONX)
+			
+			setcall scope64 is_funcx_subtype(subtype)
+			if scope64==(TRUE)
 				setcall b is_for_64()
 				if b==(TRUE);or mask (x86_64bit);endif
 			endif
@@ -136,15 +148,25 @@ Function parsefunction(data ptrcontent,d
 				EndIf
 			EndIf
 			
-			if subtype==(cFUNCTIONX)
-				setcall b is_for_64()
-				if b==(TRUE)
+			setcall scope64 is_funcx_subtype(subtype)
+			#functionx,entry in 64 conventions
+			#entrylinux has no return but has argc,aexec,a1...an
+			if scope64==(TRUE)
+				setcall scope64 is_for_64()
+				if scope64==(TRUE)
 					setcall err function_start_64()
 					If err!=noerr
 						Return err
 					EndIf
 				endif
-			endif
+				call scope64_set(scope64)
+			elseif subtype==(cENTRYLINUX)
+				#scope64 not using, never get into getreturn here
+				setcall err entrylinux_top();if err!=noerr;Return err;EndIf
+			else
+				#cFUNCTION
+				call scope64_set((FALSE))
+			endelse
 		endelse
 	Else
 		data boolindirect#1
@@ -211,9 +233,8 @@ function prepare_function_call(sd pconte
 	EndElse
 	Call advancecursors(pcontent,psize,sz)
 	
-	#move over the stack arguments
+	#move over the stack arguments, ebx is also shorting the first stack variable (mov rbx,rdx)
 	#mov esp,ebx
-		#callex(64) also use ebx to find the number of args
 	Data code%ptrcodesec
 	sd err
 	#
@@ -233,7 +254,7 @@ function write_function_call(sd ptrdata,
 	
 	sd b;setcall b is_for_64_is_impX_or_fnX_get()
 	if b==(TRUE)
-		setcall err function_call_64(is_callex,(microsoft_convention_preset_args))
+		setcall err function_call_64(is_callex)
 		If err!=(noerror);Return err;EndIf
 	endif
 
@@ -326,18 +347,19 @@ function write_function_call(sd ptrdata,
 		chars g_err_jz=0x74;chars ret_end_sz#1
 		#
 		ss ret_end_p
-		setcall ret_end_sz getreturn(#ret_end_p)
 		sd is_linux_term;setcall is_linux_term is_linux_end()
 		if is_linux_term==(TRUE)
 			#int 0x80, sys_exit, eax 1,ebx the return number
 			const g_err_sys_start=!
 			chars g_err_sys={0x8b,ebxregnumber*toregopcode|0xc0|eaxregnumber}
 			chars *={0xb8,1,0,0,0}
-			Chars *={0xCD,0x80}
+			Chars *={intimm8,0x80}
 			const g_err_sys_size=!-g_err_sys_start
 			set ret_end_sz (g_err_sys_size)
 			set ret_end_p #g_err_sys
-		endif
+		else
+			setcall ret_end_sz getreturn(#ret_end_p)
+		endelse
 		SetCall err addtosec(#g_err_jz,(bsz+bsz),code);If err!=(noerror);Return err;EndIf
 		#return
 		SetCall err addtosec(ret_end_p,ret_end_sz,code);If err!=(noerror);Return err;EndIf
@@ -365,4 +387,12 @@ endfunction
 function is_linux_end()
 	sd entrylinux_bool_ptr;setcall entrylinux_bool_ptr entrylinux_bool_p()
 	return entrylinux_bool_ptr#
-endfunction
\ No newline at end of file
+endfunction
+#er
+function entrylinux_top()
+	chars s={0x6a,0}
+	data code%ptrcodesec
+	sd err
+	setcall err addtosec(#s,2,code)
+	return err
+endfunction
--- ocompiler-1.orig/src/files/functions/argument/argument.s
+++ ocompiler-1/src/files/functions/argument/argument.s
@@ -1,6 +1,17 @@
 
-
 function getreturn(data ptrptrcontinuation)
+	sd b;setcall b scope64_get()
+	if b==(TRUE)
+		sd conv;setcall conv convdata((convdata_total))
+		if conv==(lin_convention)
+			chars lin64_return={0xc9,0x5b}
+			#pop c;add rsp,8*conv;push c
+			chars *={0x59,REX_Operand_64,0x83,regregmod|espregnumber,lin_convention*qwsz,0x51}
+			chars *=retcom
+			set ptrptrcontinuation# #lin64_return
+			return (2+6+1)
+		endif
+	endif
 	Chars returncontinuation={0xc9,0x5b,retcom}
 	str ptrreturncontinuation^returncontinuation
 	data sizeretcontinuation=3
@@ -51,19 +62,15 @@ Function argument(data ptrcontent,data p
 		If subtype==(cRETURN)
 			call setimm()
 			set immop immtake
-
-			Chars return={moveatprocthemem}
-
-			setcall sizeofcontinuation getreturn(ptrptrcontinuation)
-
-			Set op return
-			set regopcode (eaxregnumber)
 			Set integerreminder true
+			Set op (moveatprocthemem)
+
+			#exit from linux term
+			if termswitch==(FALSE);setcall termswitch is_linux_end();endif
 
-			#not cEXIT
-			if termswitch==(FALSE)
-				setcall termswitch is_linux_end();endif
 			if termswitch==true
+				#if to keep rsp can be leave pop sub rsp,:
+				
 				#int 0x80, sys_exit, eax 1,ebx the return number
 				chars sys_exit={0xb8,1,0,0,0}
 				data exinit^sys_exit
@@ -80,12 +87,15 @@ Function argument(data ptrcontent,data p
 				add immop ebxregnumber
 
 				#
-				Chars unixcontinuation={0xCD,0x80}
+				Chars unixcontinuation={intimm8,0x80}
 				data ptrunixcontinuation^unixcontinuation
 				Data two=2
 				Set ptrcontinuation ptrunixcontinuation
 				set sizeofcontinuation two
-			endif
+			else
+				set regopcode (eaxregnumber)
+				setcall sizeofcontinuation getreturn(ptrptrcontinuation)
+			endelse
 			#fileformat#
 		ElseIf subtype==(cNOT)
 			Chars not={0xF7}
@@ -105,12 +115,24 @@ Function argument(data ptrcontent,data p
 			else;set incs_sz (qwsz);endelse
 			set ptrcontinuation #incs_sz
 			set sizeofcontinuation (bsz)
-		Else
-		#dec
+		ElseIf subtype==(cDEC)
 			Chars dec={0xFF}
 			Chars decregopcode={1}
 			Set op dec
 			Set regopcode decregopcode
+		ElseIf subtype==(cNEG)
+			set op (0xf7)
+			set regopcode 3
+		Else
+			set op (0xD1)
+			If subtype==(cSHL)
+				set regopcode 4
+			ElseIf subtype==(cSHR)
+				set regopcode 5
+			Else
+			#cSAR
+				set regopcode 7
+			EndElse
 		EndElse
 	Else
 	#push imm prepare test
--- ocompiler-1.orig/src/files/functions/argument/comwrite.s
+++ ocompiler-1/src/files/functions/argument/comwrite.s
@@ -45,7 +45,6 @@ function writetake(sd takeindex,sd entry
 	data null=0
 
 	Data errnr#1
-	Data noerr=noerror
 
 	Chars takeini={0xb8}
 
@@ -94,33 +93,24 @@ function writetake(sd takeindex,sd entry
 				EndIf
 			endif
 		endelse
-	endif
-
-	SetCall errnr addtosec(ptrtake,sz1,ptrcodesec)
-	If errnr!=noerr
-		Return errnr
-	EndIf
-	
-	if stack==null
-		return noerr
+		SetCall errnr addtosec(ptrtake,sz1,ptrcodesec)
 	else
-		setcall errnr rex_w_if64();if errnr!=(noerror);return (noerror);endif
-		
-		chars getfromstack={0x03}
-		chars getfromstack_modrm#1
-
 		chars stack_relative#1
 		chars regreg=RegReg
-
 		setcall stack_relative stack_get_relative(entry)
+		chars getfromstack={0x03}
+		chars getfromstack_modrm#1
 		SetCall getfromstack_modrm formmodrm(regreg,takeindex,stack_relative)
-
 		data ptrgetfromstack^getfromstack
 		data sizegetfromstack=2
-
+		if takeloc!=0
+			SetCall errnr addtosec(ptrtake,sz1,ptrcodesec)
+			set getfromstack 0x03
+		else;set getfromstack (moveatprocthemem);endelse
+		setcall errnr rex_w_if64();if errnr!=(noerror);return errnr;endif
 		SetCall errnr addtosec(ptrgetfromstack,sizegetfromstack,ptrcodesec)
-		Return errnr
 	endelse
+	Return errnr
 endfunction
 
 #er
@@ -137,13 +127,24 @@ Function writeoperation(data location,ch
 	Data noreg=noregnumber
 	Data sz2=bsz+bsz
 
+	sd take64stack=FALSE;sd v64
+	sd stacktest;setcall stacktest is_stack(location)
+	if stacktest!=(NULL)
+		sd for_64;setcall for_64 is_for_64()
+		if for_64==(TRUE)
+			set take64stack (TRUE)
+			setcall v64 val64_p_get();set v64# (val64_willbe)
+		endif
+	endif
 	Data true=TRUE
 	If sufix==true
-		#setcall errnr rex_w_if64();If errnr!=noerr;Return errnr;EndIf it's not ok will break data
-		Chars newtake={moveatprocthemem}
-		Const edxtoedx=edxregnumber*8|edxregnumber
-		Chars *newtakemodrm={edxtoedx}
+		if take64stack==(TRUE)
+			call rex_w(#errnr);If errnr!=noerr;Return errnr;EndIf
+		endif
+		Chars newtake=moveatprocthemem
+		Chars newtakemodrm#1
 		Str ptrnewtake^newtake
+		setcall newtakemodrm formmodrm((mod_0),takeindex,takeindex)
 		SetCall errnr addtosec(ptrnewtake,sz2,ptrcodesec)
 		If errnr!=noerr
 			Return errnr
--- ocompiler-1.orig/src/files/functions/commons/getcommand.s
+++ ocompiler-1/src/files/functions/commons/getcommand.s
@@ -6,8 +6,9 @@ Const spacenotreq=0
 Chars cDATA_c="DATA";Chars cCHARS_c="CHARS";Chars cSTR_c="STR";Chars cSD_c="SD";Chars cSS_c="SS"
 	Chars cCONST_c="CONST";Chars cAFTERCALL_c="AFTERCALL";Chars cIMPORTAFTERCALL_c="IMPORTAFTERCALL"
 Chars cFORMAT_c="FORMAT"
-Chars cRETURN_c="RETURN";Chars cNOT_c="NOT";Chars cINC_c="INC";Chars cINCST_c="INCST";Chars cDEC_c="DEC";Chars cEXIT_c="EXIT"
-Chars cSET_c="SET";Chars cSETX_c="SETX";Chars cADD_c="ADD";Chars cSUB_c="SUB";Chars cMULT_c="MULT";Chars cDIV_c="DIV";Chars cAND_c="AND";Chars cOR_c="OR";Chars cXOR_c="XOR"
+Chars cRETURN_c="RETURN";Chars cNOT_c="NOT";Chars cINC_c="INC";Chars cINCST_c="INCST";Chars cDEC_c="DEC";Chars cEXIT_c="EXIT";Chars cNEG_c="NEG";Chars cSHL_c="SHL";Chars cSHR_c="SHR";Chars cSAR_c="SAR"
+Chars cSET_c="SET";Chars cADD_c="ADD";Chars cSUB_c="SUB";Chars cMULT_c="MULT";Chars cDIV_c="DIV";Chars cREM_c="REM";Chars cAND_c="AND";Chars cOR_c="OR";Chars cXOR_c="XOR"
+#                 ;Chars cSETX_c="SETX"
 Chars cLIBRARY_c="LIBRARY";
 Chars cIMPORT_c="IMPORT";Chars cIMPORTX_c="IMPORTX";
 Chars cFUNCTION_c="FUNCTION";Chars cFUNCTIONX_c="FUNCTIONX";Chars cENTRY_c="ENTRY";Chars cENTRYLINUX_c="ENTRYLINUX"
@@ -109,6 +110,26 @@ Const numberofcommandsvars=!-commandsvar
 			Data *=cONEARG
 			Data *=cEXIT
 			Data *=spacereq
+		Const cNEG=!-cONEARG_top
+			data *^cNEG_c
+			Data *=cONEARG
+			Data *=cNEG
+			Data *=spacereq
+		Const cSHL=!-cONEARG_top
+			data *^cSHL_c
+			Data *=cONEARG
+			Data *=cSHL
+			Data *=spacereq
+		Const cSHR=!-cONEARG_top
+			data *^cSHR_c
+			Data *=cONEARG
+			Data *=cSHR
+			Data *=spacereq
+		Const cSAR=!-cONEARG_top
+			data *^cSAR_c
+			Data *=cONEARG
+			Data *=cSAR
+			Data *=spacereq
 	Const cPRIMSEC=!-coms_start
 	Const cPRIMSEC_top=!
 		Const cSET=!-cPRIMSEC_top
@@ -116,11 +137,6 @@ Const numberofcommandsvars=!-commandsvar
 			Data *=cPRIMSEC
 			Data *=cSET
 			Data *=spacereq
-		Const cSETX=!-cPRIMSEC_top
-			data *^cSETX_c
-			Data *=cPRIMSEC
-			Data *=cSETX
-			Data *=spacereq
 		Const cADD=!-cPRIMSEC_top
 			data *^cADD_c
 			Data *=cPRIMSEC
@@ -141,6 +157,11 @@ Const numberofcommandsvars=!-commandsvar
 			Data *=cPRIMSEC
 			Data *=cDIV
 			Data *=spacereq
+		Const cREM=!-cPRIMSEC_top
+			data *^cREM_c
+			Data *=cPRIMSEC
+			Data *=cREM
+			Data *=spacereq
 		Const cAND=!-cPRIMSEC_top
 			data *^cAND_c
 			Data *=cPRIMSEC
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ ocompiler-1/src/files/functions/dataassign.s
@@ -281,6 +281,7 @@ Function dataassign(data ptrcontent,data
 	EndElse
 	if skipNumberValue==false
 		If typenumber!=constantsnr
+			#addtocode(#test,1,code) cannot add to code for test will trick the next compiler, entry is started,will look like a bug
 			setcall err writevar(ptrvalue,valuewritesize,relocindx,stack,rightstackpointer)
 			If err!=noerr
 				Return err
--- ocompiler-1.orig/src/files/functions/stack/stack.s
+++ ocompiler-1/src/files/functions/stack/stack.s
@@ -79,8 +79,8 @@ function entryscope()
 	#mov e(r)bx e(r)sp
 	const scope3_start=!;chars scope3={moveatregthemodrm,0xdc};const scope3_sz=!-scope3_start
 	#sub e(r)bx dword
-	const scope4_start=!;chars scope4={0x81,0xc3};const scope4_sz=!-scope4_start
-	data scopestack=0
+	const scope4_start=!;chars scope4={0x81,0xc3}
+	data *scopestack=0;const scope4_sz=!-scope4_start
 	
 	setcall err addtosec(#scope1,(scope1_sz),container);if err!=(noerror);return err;endif
 	setcall err rex_w_if64();if err!=(noerror);return err;endif
@@ -89,7 +89,6 @@ function entryscope()
 	setcall err addtosec(#scope3,(scope3_sz),container);if err!=(noerror);return err;endif
 	setcall err rex_w_if64();if err!=(noerror);return err;endif
 	setcall err addtosec(#scope4,(scope4_sz),container);if err!=(noerror);return err;endif
-	setcall err addtosec(#scopestack,(dwsz),container);if err!=(noerror);return err;endif
 	#
 	data set=0;call ramp_index(set,container)
 	return (noerror)
@@ -112,12 +111,12 @@ endfunction
 
 
 #er
-function addtocodeforstack(data value,data rightstackpointer)
+function addtocodeforstack(sd value,sd rightstackpointer,sd for_64)
 	data eax=eaxregnumber
 
 	data null=0
 	chars movtostack#1
-	chars *modrm=disp32*tomod|ebxregnumber
+	chars *modrm=disp32mod|ebxregnumber
 	data rampindex#1
 	data rampvalue#1
 
@@ -143,6 +142,10 @@ function addtocodeforstack(data value,da
 		set size sizereg
 	endelse
 
+	if for_64==(TRUE)
+		call rex_w(#err);if err!=(noerror);return err;endif
+	endif
+
 	setcall rampindex addramp()
 	setcall rampindex neg(rampindex)
 	set rampvalue value
@@ -150,5 +153,3 @@ function addtocodeforstack(data value,da
 	setcall err addtosec(stack,size,ptrcodesec)
 	return err
 endfunction
-
-
--- ocompiler-1.orig/src/files/functions/values/operations.s
+++ ocompiler-1/src/files/functions/values/operations.s
@@ -8,6 +8,39 @@ Const andNumber=4
 Const orNumber=5
 Const xorNumber=6
 Const powNumber=7
+#Const remNumber=8
+#Const shlNumber=9
+#Const shrNumber=10
+#asciiminus and asciinot for one arg
+
+function const_security(sd item)
+	#2$31 is last one
+	#1 shl 63 is last one
+	#maximum first overflow, ok
+	#data maximum=qwsz*8
+	data maximum=dwsz*8
+	if item>=maximum
+		call safeMessage("Overflow at constants.")
+		return maximum
+	endif
+	return item
+endfunction
+#function shift_right(sd a,sd n)
+#	setcall n const_security(n)
+#	while n>0
+#		dec n
+#		shr a
+#	endwhile
+#	return a
+#endfunction
+#function shift_left(sd a,sd n)
+#	setcall n const_security(n)
+#	while n>0
+#		dec n
+#		shl a
+#	endwhile
+#	return a
+#endfunction
 
 #err pointer
 Function operation(str content,data size,data inoutvalue,data number)
@@ -23,23 +56,15 @@ Function operation(str content,data size
 		Return errptr
 	EndIf
 
-	Data addnumber=addNumber
-	Data subnumber=subNumber
-	Data mulnumber=mulNumber
-	Data divnumber=divNumber
-	Data andnumber=andNumber
-	Data ornumber=orNumber
-	Data xornumber=xorNumber
-
 	Data currentitem=0
 	Set currentitem inoutvalue#
-	If number==addnumber
+	If number==(addNumber)
 		Add currentitem newitem
-	ElseIf number==subnumber
+	ElseIf number==(subNumber)
 		Sub currentitem newitem
-	ElseIf number==mulnumber
+	ElseIf number==(mulNumber)
 		Mult currentitem newitem
-	ElseIf number==divnumber
+	ElseIf number==(divNumber)
 		Data zero=0
 		If newitem==zero
 			Chars zerodiv="Division by 0 error."
@@ -47,16 +72,17 @@ Function operation(str content,data size
 			Return ptrzerodiv
 		EndIf
 		Div currentitem newitem
-	ElseIf number==andnumber
+	ElseIf number==(andNumber)
 		And currentitem newitem
-	ElseIf number==ornumber
+	ElseIf number==(orNumber)
 		Or currentitem newitem
-	ElseIf number==xornumber
+	ElseIf number==(xorNumber)
 		Xor currentitem newitem
 	Else
+	#If number==(powNumber)
 		if newitem<0
 			if currentitem==0
-				#is 0 power -n
+				#is 1/(0 power n)
 				Return ptrzerodiv
 			elseif currentitem==1
 				#is 1/(1 power n)
@@ -67,13 +93,33 @@ Function operation(str content,data size
 		elseif newitem==0
 			set currentitem 1
 		else
-			sd item
-			set item currentitem
+			setcall newitem const_security(newitem)
+			sd item;set item currentitem
 			while newitem!=1
 				mult currentitem item
 				dec newitem
 			endwhile
 		endelse
+	#ElseIf number==(remNumber)
+	#	If newitem==zero
+	#		Return ptrzerodiv
+	#	EndIf
+		#Rem currentitem newitem
+	#ElseIf number==(shlNumber)
+	#	if newitem<0
+	#		neg newitem
+	#		setcall currentitem shift_right(currentitem,newitem)
+	#	else
+	#		setcall currentitem shift_left(currentitem,newitem)
+	#	endelse
+	#Else
+	#If number==(shrNumber)
+	#	if newitem<0
+	#		neg newitem
+	#		setcall currentitem shift_left(currentitem,newitem)
+	#	else
+	#		setcall currentitem shift_right(currentitem,newitem)
+	#	endelse
 	EndElse
 
 	Set inoutvalue# currentitem
@@ -82,53 +128,44 @@ EndFunction
 
 #bool
 Function signop(chars byte,data outval)
-	Chars plus={asciiplus}
-	Chars minus={asciiminus}
+	Chars plus=asciiplus
+	Chars minus=asciiminus
 
-	Chars mult={asciiast}
-	Chars div={asciislash}
+	Chars mult=asciiast
+	Chars div=asciislash
 	
-	Chars and={asciiand}
-	Chars or={asciivbar}
-	Chars xor={asciicirc}
+	Chars and=asciiand
+	Chars or=asciivbar
+	Chars xor=asciicirc
 	
-	Chars pow="$"
-
-	Data addnumber=addNumber
-	Data subnumber=subNumber
-	Data mulnumber=mulNumber
-	Data divnumber=divNumber
-	Data andnumber=andNumber
-	Data ornumber=orNumber
-	Data xornumber=xorNumber
-	Data pownumber=powNumber
+	Chars pow=asciidollar
 
 	Data false=FALSE
 	Data true=TRUE
 
 	If byte==plus
-		Set outval# addnumber
+		Set outval# (addNumber)
 		Return true
 	ElseIf byte==minus
-		Set outval# subnumber
+		Set outval# (subNumber)
 		Return true
 	ElseIf byte==mult
-		Set outval# mulnumber
+		Set outval# (mulNumber)
 		Return true
 	ElseIf byte==div
-		Set outval# divnumber
+		Set outval# (divNumber)
 		Return true
 	ElseIf byte==and
-		Set outval# andnumber
+		Set outval# (andNumber)
 		Return true
 	ElseIf byte==or
-		Set outval# ornumber
+		Set outval# (orNumber)
 		Return true
 	ElseIf byte==xor
-		Set outval# xornumber
+		Set outval# (xorNumber)
 		Return true
 	ElseIf byte==pow
-		Set outval# pownumber
+		Set outval# (powNumber)
 		Return true
 	EndElseIf
 	
--- ocompiler-1.orig/src/files/headers/ascii.h
+++ ocompiler-1/src/files/headers/ascii.h
@@ -3,6 +3,7 @@
 #some ascii Constants commonly used
 Const asciiExclamationmark=0x21
 Const asciiNumber=0x23
+Const asciidollar=0x24
 Const asciiand=0x26
 Const asciiparenthesisstart=0x28
 Const asciiast=0x2A
--- ocompiler-1.orig/src/files/headers/asm.h
+++ ocompiler-1/src/files/headers/asm.h
@@ -15,6 +15,7 @@ const REX_R8_15=REX_default|REX_W|REX_R
 #opcodes
 
 Const retcom=0xc3
+const intimm8=0xCD
 Const atedximm=0xba
 
 Const moveatmemtheproc=0x89
@@ -25,10 +26,14 @@ Const moveatregthemodrm=moveatprocthemem
 
 #mods
 Const mod_0=0
-#Const disp8=1
+Const disp8=1
 Const disp32=2
 Const RegReg=3
 
+const disp8mod=disp8*tomod
+const disp32mod=disp32*tomod
+const regregmod=RegReg*tomod
+
 #regopcodes
 Const noregnumber=-1
 Const eaxregnumber=0
@@ -37,11 +42,13 @@ Const edxregnumber=2
 Const ebxregnumber=3
 Const espregnumber=4
 Const ebpregnumber=5
+Const esiregnumber=6
+Const ediregnumber=7
 Const ahregnumber=4
 Const regopcode_mask=0x7
 #mixt
 Const Notregopcode=2
 #
-const bt_reg_imm8=4*toregopcode|0xc0
+const bt_reg_imm8=espregnumber*toregopcode|regregmod
 
 #rms
--- ocompiler-1.orig/src/files/headers/commons.h
+++ ocompiler-1/src/files/headers/commons.h
@@ -50,6 +50,7 @@ Const void=0
 Data bytesize=bsz
 Data wordsize=wsz
 Data dwordsize=dwsz
+Data qwordsize=qwsz
 Data zero=0
 Data one=1
 data two=2
--- ocompiler-1.orig/src/files/headers/header.h
+++ ocompiler-1/src/files/headers/header.h
@@ -312,4 +312,12 @@ Const not_hexenum=0
 Const hexenum=1
 
 
-const microsoft_convention_preset_args=4
+const val64_willbe=2
+
+const ms_convention=4
+const lin_convention=6
+
+const convdata_total=0
+const convdata_call=1
+const convdata_fn=2
+const convdata_init=3
--- ocompiler-1.orig/src/linux/files/prefextra.s
+++ ocompiler-1/src/linux/files/prefextra.s
@@ -1,4 +1,6 @@
 
+const variable_convention=lin_convention
+
 #err
 function prefextra(ss prefpath,sd ptrpreferencessize,sd ptrpreferencescontent)
 	ss homestr="HOME"
--- ocompiler-1.orig/src/linux/files/xgetfile.s
+++ ocompiler-1/src/linux/files/xgetfile.s
@@ -29,8 +29,6 @@ Data argumentssize#1
 Data ptrscript^script
 Data ptrargumentssize^argumentssize
 
-Data qwordsize=qwsz
-
 Call memset(ptrscript,zero,qwordsize)
 
 Data getdelimreturn#1
--- ocompiler-1.orig/src/windows/files/prefextra.s
+++ ocompiler-1/src/windows/files/prefextra.s
@@ -1,4 +1,6 @@
 
+const variable_convention=first_convention
+
 function prefextra(ss *file,sd *ptrpreferencessize,sd *ptrpreferencescontent)
 	return (noerror)
 endfunction
--- ocompiler-1.orig/src/windows/obj64.s
+++ ocompiler-1/src/windows/obj64.s
@@ -1,7 +1,7 @@
 
 #windows elf rel format, with 64 code
 
-Format ElfObj64Microsoft
+Format ElfObj64
 
 Include "./files/winobj64imports.h"
 Include "./obj.s"
\ No newline at end of file
