Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+61) jammy; urgency=medium
 .
   * signal at commas fix
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2022-11-08

--- ocompiler-1.orig/arh/pub
+++ ocompiler-1/arh/pub
@@ -20,17 +20,26 @@ last=`curl https://api.github.com/repos/
 ~/test/keyring && \
 ~/test/del x ${last} && \
 ~/test/arh2 ${last} && \
+sed -i '1s/jammy/bionic/' debian/changelog && \
+sed -i '1s/)/b)/' debian/changelog && \
+~/test/debuild && \
+~/test/deb && \
+~/test/publp && \
+~/test/publp2 && \
+~/test/lp 0 "focal" && \
+~/test/lp x "focal" && \
+git restore debian/changelog && \
 sed -i '1s/jammy/xenial/' debian/changelog && \
 sed -i '1s/)/x)/' debian/changelog && \
 ~/test/debuild && \
 ~/test/deb && \
 ~/test/publp && \
-git restore debian/changelog && \
 ~/test/publp2 && \
-~/test/lp 0 "bionic focal" && \
-~/test/lp x "bionic focal" && \
+git restore debian/changelog && \
 git diff
 #is something wrong with copy package and rebuild (maybe same with copy-package without -b)
+#restore after last lp where inside publp2 will check version
+#the xenial ostrip is not working (is just a cc)
 
 #plans:
 
--- ocompiler-1.orig/ostrip/Makefile
+++ ocompiler-1/ostrip/Makefile
@@ -9,33 +9,31 @@ FULLOBJS = ${FULLOBJ}.s
 FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 OCOMP=../src/o
+OUNUSED=../ounused/ounused
 
 %.o: ${FULLOBJS}
 	${OCOMP} $< ${OFLAGS}
 
 syms =-s
 ATCCCOM = $(CC) ${syms} -o ${OB}
-#ld build is failing, must do pie at bionic
 
-ostrip: compile strip
-	@echo
-#without this echo will do a strange cc command
+strippy=ostriputil
 
-compile: ${OBJ}
-	../ounused/ounused ${FULLOBJLOG}
+ostrip: ${OBJ}
+	${OUNUSED} ${FULLOBJLOG}
 	@echo
 	${ATCCCOM} ${FULLOBJO}
-
-#xenial do wrong access somehow, bionic and focal do extra code at text and need to extra code at realoffset for .text
-strip:
 	if [ "$(shell lsb_release -cs)" = "jammy" ]; then \
 		${FULLOBJ} ${FULLOBJ} ${FULLOBJLOG} ${FULLOBJO}; \
 		if [ "$$?" = "0" ]; then \
-			python3 strip.py ${FULLOBJ} ${FULLOBJ}; \
+			${strippy} ${FULLOBJ} ${FULLOBJ}; \
 		fi; \
 	fi
+#	@echo
+#without this echo will do a strange cc command
+#xenial do wrong access somehow, bionic and focal do extra code at text and need to extra code at realoffset for .text
 
-install: ostrip
+install: all
 	install -D ostrip \
 		$(DESTDIR)$(prefix)/bin/ostrip
 
--- ocompiler-1.orig/ostrip/strip.py
+++ /dev/null
@@ -1,111 +0,0 @@
-
-
-#wget in Makefile maybe
-
-import subprocess
-import sys
-
-inputfile=sys.argv[1]
-outputfile=sys.argv[2]
-
-txt=subprocess.check_output(['/bin/bash','-c',"printf '%s' $(objdump -h "+inputfile+" | grep ' .data ' | tr -s ' ' | cut -d ' ' -f 4)"])
-unstripped_size=int(txt,base=16)
-#fn="temp"
-#with open(fn,'rb') as f:
-#	unstripped_size=int(f.read(),base=16)
-
-#this is not better than objcopy file --update-section .data=data.bin
-#data.content=bytearray(b"text")
-#ld...-Tdata to put data at trail
-
-import shutil
-
-if inputfile!=outputfile:
-	shutil.copyfile(inputfile,outputfile)
-#after objcopy symtab changes offset -> .symtab_offset before objcopy
-
-import os
-
-s1=".data"
-s2=".text"
-s3=".symtab"
-if (os.path.exists(s3)):
-	#objcopy is not updating symtab
-	with open(s3+"_offset",'rb') as f:
-		value=f.read()
-		x=len(value)
-		y=b""
-		#need to reverse to big
-		for a in range(x,0,-1):
-			y+=(value[a-1]).to_bytes(1,'big')
-		value=y.hex()
-		offset=int(value,base=16)
-		with open(outputfile,'r+b') as f:
-			f.seek(offset)
-			with open(s3,'rb') as s:
-				f.write(s.read())
-s4=".rela.dyn"
-objcopy=["objcopy",outputfile,"--update-section",s1+"="+s1,"--update-section",s2+"="+s2]
-if (os.path.exists(s4)):
-	objcopy.append("--update-section")
-	objcopy.append(s4+"="+s4)
-s5=".dynsym"
-if (os.path.exists(s5)):
-	objcopy.append("--update-section")
-	objcopy.append(s5+"="+s5)
-proc=subprocess.run(objcopy)
-
-if proc.returncode==0:
-	import lief
-	#
-	elffile = lief.parse(outputfile)
-	s=elffile.get_section(s1)
-	h=elffile.segments
-	#
-	found=-1
-	dif=0
-	#
-	for x in h:
-		a=x.sections
-		n=len(a)
-		for i in range(0,n):
-			b=a[i]
-			if found==-1:
-				if b.name==s1:
-					#only with .bss: it looks like objcopy is shrinking file size accordingly and is not touching on mem size in section and segment
-					#so this file was about to go
-					#but when it's at the edge is shrinking mem size
-					#then x.virtual_size+= is a must and a[i].virtual_address+= stays like a guardian
-					found=i+1
-					if (b.virtual_address+unstripped_size)<=(x.virtual_address+x.virtual_size):
-						break
-					size=b.size
-					dif=unstripped_size-size
-			else:
-				#see about alignments
-				#The value of sh_addr must be congruent to 0, modulo the value of sh_addralign
-				#	i think that means   if align is 8 addr can start at 0h/8h only
-				test=b.virtual_address+dif
-				bittest=test&(b.alignment-1)
-				if bittest!=0:
-					dif+=b.alignment-bittest
-		if found!=-1:
-			if dif!=0:
-				#must first increase segment size if not want to lose the section
-				x.virtual_size+=dif
-				for i in range(found,n):
-					a[i].virtual_address+=dif
-					#this is not tested at stdout/stderr that goes into .bss that is after .data
-				elffile.write(outputfile)
-				print("virtual_address modifications")
-			else:
-				print("virtual_address modifications were not required")
-			st = os.stat(outputfile)
-			import stat
-			os.chmod(outputfile, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
-			#
-			#point that this script is not checking the existent virtual trail of .data
-			#remove(fn)
-			#
-			exit(0)
-exit(-1)
--- ocompiler-1.orig/ounused/Makefile
+++ ocompiler-1/ounused/Makefile
@@ -7,8 +7,12 @@ FULLOBJS = ${FULLOBJ}.s
 FULLOBJO = ${FULLOBJ}.o
 FULLOBJLOG = ${FULLOBJS}.log
 
+ifndef OCOMP
+OCOMP=../src/o
+endif
+
 %.o: ${FULLOBJS}
-	../src/o $< exit_end 1
+	${OCOMP} $< exit_end 1
 
 syms =-s
 ATLDCOM = $(LD) ${syms} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc -entry main
@@ -18,7 +22,7 @@ ounused: ${OBJ}
 	./${OB} ${FULLOBJLOG}
 	@echo
 
-install: ounused
+install: all
 	install -D ounused \
 		$(DESTDIR)$(prefix)/bin/ounused
 
--- ocompiler-1.orig/src/Makefile
+++ ocompiler-1/src/Makefile
@@ -15,20 +15,19 @@ endif
 #OFLAGS=
 
 %.o: ${FULLOBJS}
-	if [ -s ${OBT} ];then base64 -d ${OBT} > $@;else ${OCOMP} $< ${OFLAGS};fi
+	if [ -s ${OBT} ];then base64 -d ${OBT} > $@;else ${OCOMP} $< ${OFLAGS};mv ${FULLOBJO} .;fi
 
 syms =-s
 ATLDCOM = $(LD) ${syms} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc -entry main
 
 o: ${OBJ}
-	if [ -f ${OBJ} ];then ${ATLDCOM} $^;else ${ATLDCOM} ${FULLOBJO};fi
+	${ATLDCOM} $^
 
-install: o
+install: all
 	install -D o \
 		$(DESTDIR)$(prefix)/bin/o
 
 clean-compile:
-	-rm -f ${FULLOBJO}
 	-rm -f ${OBJ}
 	-rm -f ${FULLOBJS}.log
 
--- ocompiler-1.orig/src/files/actions/main/index/call.s
+++ ocompiler-1/src/files/actions/main/index/call.s
@@ -1,4 +1,3 @@
 
-
 Data callfn=callfunction
 SetCall errormsg parsefunction(pcontent,pcomsize,callfn,subtype) #there is 1 more argument but is not used
--- ocompiler-1.orig/src/files/functions/actions/enumcomma.s
+++ ocompiler-1/src/files/functions/actions/enumcomma.s
@@ -83,11 +83,11 @@ const fndecandgroup=1
 #er
 Function enumcommas(sv ptrcontent,sd ptrsize,sd sz,sd fndecandgroupOrpush,sd typenumberOrparses,sd punitsizeOrparses,sd hexOrunitsize,sd stack,sd long_mask,sd relocbool)
 	Data zero=0
-	Data argsize#1
+	vstrx argsize#1
 	Chars comma=","
 	Data err#1
 	Data noerr=noerror
-	Data content#1
+	datax content#1
 	Data csv#1
 	Data csvloop=1
 
@@ -176,48 +176,38 @@ Function enumcommas(sv ptrcontent,sd ptr
 			if typenumberOrparses==(pass_calls) #for regs at call   and shadow space
 				call nr_of_args_64need_count()
 			endif
-			sd delim
-			set delim comma
+
 			if sz!=0
-				ss test
-				set test content
-				dec test
+				set argsize content
+				dec argsize
 				chars d_quot=asciidoublequote
-				if test#==d_quot
-					set delim d_quot
+				if argsize#==d_quot
 					#look later at escapes, here only at the margins
-					ss c
-					sd s
-					set c content
-					set s sz
-					set argsize s
-					#case "abc,"
-					dec test
-					if test#==comma
-						sub c 2
-						sub s 2
-					endif
-					#
-					sd len
-					sd loop=1
-					while loop==1
-						#here the sens is backward and ," or (" represents the end of the string
-						SetCall len valinmemsens(c,s,comma,sens)
-						mult len -1
-						Call advancecursors(#c,#s,len)
-						if c#==d_quot
-							set loop 0
+					#here the string ".." is in a good condition when quotes_forward was called at fn(...)
+					sd last;set last content
+					sub last sz
+					dec argsize
+					while argsize!=last
+						if argsize#==d_quot
+							dec argsize
+							if argsize!=(asciibs)
+								inc argsize
+								set last argsize
+							else
+								dec argsize
+							endelse
 						else
-							#here the string ".." is in a good condition when quotes_forward was called at fn(...)
-							Call advancecursors(#c,#s,-1)
+							dec argsize
 						endelse
 					endwhile
-					sub argsize s
-				endif
-			endif
-			if delim==comma
-				SetCall argsize valinmemsens(content,sz,comma,sens)
-			endif
+					sub argsize content
+					neg argsize
+				else
+					SetCall argsize valinmemsens(content,sz,comma,sens)
+				endelse
+			else
+				set argsize 0
+			endelse
 
 			Data negvalue#1
 			Set negvalue zero
