Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ocompiler (1-5+50) xenial; urgency=medium
 .
   * fix stack^fn for 64 rels
Author: bc <bc@bc-HP-Pavilion-x360-Convertible>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2022-10-08

--- /dev/null
+++ ocompiler-1/.github/FUNDING.yml
@@ -0,0 +1,13 @@
+# These are supported funding model platforms
+
+github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
+patreon: # Replace with a single Patreon username
+open_collective: # Replace with a single Open Collective username
+ko_fi: # Replace with a single Ko-fi username
+tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
+community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
+liberapay: costin
+issuehunt: # Replace with a single IssueHunt username
+otechie: # Replace with a single Otechie username
+lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
+custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
--- ocompiler-1.orig/Makefile
+++ ocompiler-1/Makefile
@@ -1,6 +1,6 @@
 TOPTARGETS := all install clean distclean uninstall test
 
-SUBDIRS := src srcres
+SUBDIRS := src ounused
 
 $(TOPTARGETS): $(SUBDIRS)
 $(SUBDIRS):
@@ -9,7 +9,7 @@ $(SUBDIRS):
 
 
 all:
-	cd ./srcres; ./ounused ./ounused.s.log
-	if ! [ -f ./src/obj.o ];then cd ./src; ../srcres/ounused ./linux/obj.s.log; fi
+	cd ./ounused; ./ounused ./ounused.s.log
+	if ! [ -f ./src/obj.o ];then cd ./src; ../ounused/ounused ./linux/obj.s.log; fi
 
 .NOTPARALLEL:
--- ocompiler-1.orig/arh/pub
+++ ocompiler-1/arh/pub
@@ -33,3 +33,4 @@ last=`curl https://api.github.com/repos/
 #function in code exes
 #SizeofStackReserve against growramp?
 #at write when there is at 0x80.... or at exes it is a fixed virtual
+#there is 0x66 prefix for words and some movsw/movzw
--- /dev/null
+++ ocompiler-1/ostrip/Makefile
@@ -0,0 +1,41 @@
+all: ostrip
+
+OB = ostrip
+OBJ = ${OB}.o
+FULLOBJ = ./${OB}
+FULLOBJS = ${FULLOBJ}.s
+FULLOBJO = ${FULLOBJ}.o
+FULLOBJLOG = ${FULLOBJS}.log
+
+%.o: ${FULLOBJS}
+	../src/o $< exit_end 1
+
+syms =-s
+ATLDCOM = $(LD) ${syms} --dynamic-linker=/lib64/ld-linux-x86-64.so.2 -o $@ -lc -entry main
+
+ostrip: ${OBJ}
+	../ounused/ounused ${FULLOBJLOG}
+	@echo
+	${ATLDCOM} ${FULLOBJO}
+
+install: ostrip
+	install -D ostrip \
+		$(DESTDIR)$(prefix)/bin/ostrip
+
+clean-compile:
+	-rm -f ${FULLOBJO}
+	-rm -f ${FULLOBJLOG}
+
+clean-link:
+	-rm -f ostrip
+
+clean: clean-compile clean-link
+distclean: clean
+
+uninstall:
+	-rm -f $(DESTDIR)$(prefix)/bin/ostrip
+
+test:
+	echo "Nothing"
+
+.PHONY: all install clean distclean uninstall test
--- ocompiler-1.orig/ostrip/data.s
+++ /dev/null
@@ -1,2 +0,0 @@
-
-format elfobj
--- /dev/null
+++ ocompiler-1/ostrip/file.s
@@ -0,0 +1,161 @@
+
+include "mem.s"
+
+function get_file(sd name,sv p_file,sd sec1,sv p_sec1,sd sec2,sv p_sec2,sd type)
+	setcall p_file# fopen(name,"rb")
+	sd file;set file p_file#
+	if file!=(NULL)
+		#at frees will check next
+		set p_sec1# (NULL)
+
+		chars elf64_ehd_e_ident_sign={asciiDEL,asciiE,asciiL,asciiF}
+#chars *elf64_ehd_e_ident_class={ELFCLASS64}
+#chars *elf64_ehd_e_ident_data={ELFDATA2LSB}
+#chars *elf64_ehd_e_ident_version={EV_CURRENT}
+#chars *elf64_ehd_e_ident_osabi={ELFOSABI_NONE}
+#chars *elf64_ehd_e_ident_abiversion={EI_ABIVERSION}
+#chars *elf64_ehd_e_ident_pad={0,0,0,0,0,0,0}
+		const after_sign_to_type=1+1+1+1+1+7
+#Chars *elf64_ehd_e_type={ET_REL,0}
+		Chars elf64_ehd_e_machine={EM_X86_64,0}
+#data *elf64_ehd_e_version=EV_CURRENT
+#data *elf64_ehd_e_entry={0,0}
+#data *elf64_ehd_e_phoff={0,0}
+		const after_machine_to_shoff=4+8+8
+#data elf64_ehd_e_shoff#1;data *=0
+#data *elf64_ehd_e_flags=0
+#chars *elf64_ehd_e_ehsize={64,0}
+#chars *elf64_ehd_e_phentsize={0,0}
+#chars *elf64_ehd_e_phnum={0,0}
+		const after_shoff_to_shentsize=4+2+2+2
+#chars *elf64_ehd_e_shentsize={64,0}
+#chars elf64_ehd_e_shnum#2
+#chars elf64_ehd_e_shstrndx#2
+#chars *pad={0,0}
+		sd sz=4
+		sd sign;call read(file,#sign,sz)
+		sd c;setcall c memcmp(#sign,#elf64_ehd_e_ident_sign,sz)
+		if c==0
+			call seekc(file,(after_sign_to_type))
+			sd wsz=2
+			sd w;call read(file,#w,wsz)
+			setcall c memcmp(#w,#type,wsz)
+			if c==0
+				call read(file,#w,wsz)
+				setcall c memcmp(#w,#elf64_ehd_e_machine,wsz)
+				if c==0
+					call seekc(file,(after_machine_to_shoff))
+					sd offset;call read(file,#offset,:)
+					call seekc(file,(after_shoff_to_shentsize))
+					data shentsize=0
+					data shnum=0
+					data shstrndx=0
+					call read(file,#shentsize,wsz)
+					call read(file,#shnum,wsz)
+					call read(file,#shstrndx,wsz)
+
+					#alloc for section names table
+					sd nrsec1;sd nrsec2;setcall nrsec1 shnames(file,offset,shentsize,shstrndx,sec1,sec2,#nrsec2)
+
+					#get sections
+					sd end;set end shnum;mult end shentsize;add end offset
+					call get_section_many(file,offset,end,shentsize,nrsec1,p_sec1)
+					if p_sec1#!=(NULL)
+						#next at frees
+						set p_sec2# (NULL)
+						#get second section
+						call get_section_many(file,offset,end,shentsize,nrsec2,p_sec2)
+					endif
+
+					ret
+				endif
+				call erMessages("wrong machine",name)
+			endif
+			call erMessages("bad type",name)
+		endif
+		call erMessages("not an elf",name)
+	endif
+	call fError(name)
+endfunction
+function fError(ss name)
+	call erMessages("fopen error for",name)
+endfunction
+
+function rError()
+	call erMessage("fread error")
+endfunction
+function read(sd file,sd buf,sd size)
+	sd readed;setcall readed fread(buf,1,size,file)
+	if readed!=size
+		call rError()
+	endif
+endfunction
+
+function seekc(sd file,sd offset)
+	call seek(file,offset,(SEEK_CUR))
+endfunction
+function seeks(sd file,sd offset)
+	call seek(file,offset,(SEEK_SET))
+endfunction
+function seek(sd file,sd offset,sd whence)
+	sd return;SetCall return fseek(file,offset,whence)
+	#at lseek:
+	#	beyond seekable device limit is not our concerne, error check at seekc can go if seeks was not
+	#	at section headers offset, error can be demonstrated (bad offset)
+	if return!=0
+		call erMessage("fseek error")
+	endif
+endfunction
+
+#nrsec1
+function shnames(sd file,sd offset,sd shentsize,sd shstrndx,ss sec1,ss sec2,sd pnrsec2)  #nrsec is int
+	mult shstrndx shentsize
+	add offset shstrndx
+
+	sd mem;sd end;setcall end get_section(file,offset,#mem)
+	add end mem
+	#old remark:   count strings? safer than say it is the number of sections
+	sd nrsec1
+	setcall nrsec1 shnames_find(mem,end,sec1)
+	setcall pnrsec2# shnames_find(mem,end,sec2)
+	call free(mem)
+	return nrsec1
+endfunction
+
+function get_section_many(sd file,sd offset,sd end,sd shentsize,sd nrsec,sv p_sec)
+	while offset!=end
+		#the sh64_name is first
+		if offset#==nrsec
+			call get_section(file,offset,p_sec)
+			ret
+		endif
+		add offset shentsize
+	endwhile
+endfunction
+
+#fread
+function get_section(sd file,sd offset,sv pmem)
+#Data sh64_name#1
+#Data sh64_type#1
+#Data sh64_flags#1;data *=0
+#Data sh64_addr#1;data *=0
+#Data sh64_offset#1;data *=0
+#Data sh64_size#1;data *=0
+#Data sh64_link#1
+#Data sh64_info#1
+#Data sh64_addralign#1;data *=0
+#Data sh64_entsize#1;data *=0
+	add offset (4+4+:+:)  #flags :?on 32 is ok
+	call seeks(file,offset)
+	call read(file,#offset,:)
+	sd size;call read(file,#size,:)
+	call seeks(file,offset)
+	sd mem;setcall mem alloc(size)
+	sd readed;setcall readed fread(file,mem,size)
+	if readed==size
+		set pmem# mem
+		return size
+	endif
+	call free(mem)
+	call rError()
+endfunction
--- /dev/null
+++ ocompiler-1/ostrip/header.h
@@ -0,0 +1,33 @@
+
+const EXIT_SUCCESS=0
+const EXIT_FAILURE=1
+const NULL=0
+
+const asciiE=0x45
+const asciiF=0x46
+const asciiL=0x4C
+const asciiDEL=0x7F
+
+Const SEEK_SET=0
+Const SEEK_CUR=1
+Const SEEK_END=2
+
+const ET_EXEC=2
+const EM_X86_64=62
+
+Importx "stderr" stderr
+
+Importx "fprintf" fprintf
+Importx "fopen" fopen
+Importx "fread" fread
+importx "fclose" fclose
+Importx "fseek" fseek
+Importx "ftell" ftell
+
+Importx "memcmp" memcmp
+importx "malloc" malloc
+importx "free" free
+
+importx "strcmp" strcmp
+importx "strlen" strlen
+importx "sscanf" sscanf
--- /dev/null
+++ ocompiler-1/ostrip/leaf.py
@@ -0,0 +1,75 @@
+
+
+#wget in Makefile maybe
+
+import subprocess
+import sys
+
+inputfile=sys.argv[1]
+
+txt=subprocess.check_output(['/bin/bash','-c',"printf '%s' $(objdump -h "+inputfile+" | grep ' .data ' | tr -s ' ' | cut -d ' ' -f 4)"])
+unstripped_size=int(txt,base=16)
+#fn="temp"
+#with open(fn,'rb') as f:
+#	unstripped_size=int(f.read(),base=16)
+
+#this is not better than objcopy file --update-section .data=data.bin
+#data.content=bytearray(b"text")
+
+import os
+
+r="rela.bin"
+if (not os.path.exists(r)):
+	subprocess.run(["objcopy",inputfile,"--update-section",".text=text.bin","--update-section",".data=data.bin"])
+else:
+	subprocess.run(["objcopy",inputfile,"--update-section",".text=text.bin","--update-section",".data=data.bin","--update-section",".rela.dyn="+r])
+
+import lief
+
+elffile = lief.parse(inputfile)
+
+c=".data"
+
+s=elffile.get_section(c)
+
+h=elffile.segments
+
+found=-1
+
+for x in h:
+	a=x.sections
+	n=len(a)
+	for i in range(0,n):
+		b=a[i]
+		if found==-1:
+			if c==b.name:
+				#only with .bss: it looks like objcopy is shrinking file size accordingly and is not touching on mem size in section and segment
+				#so this file was about to go
+				#but when it's at the edge is shrinking mem size
+				#then x.virtual_size+= is a must and a[i].virtual_address+= stays like a guardian
+				if (b.virtual_address+unstripped_size)<=(x.virtual_address+x.virtual_size):
+					exit(0)
+				found=i+1
+				size=b.size
+				dif=unstripped_size-size
+		else:
+			#see about alignments
+			#The value of sh_addr must be congruent to 0, modulo the value of sh_addralign
+			#	i think that means   if align is 8 addr can start at 0h/8h only
+			test=b.virtual_address+dif
+			bittest=test&(b.alignment-1)
+			if bittest!=0:
+				dif+=b.alignment-bittest
+	if found!=-1:
+		#must first increase segment size if not want to lose the section
+		x.virtual_size+=dif
+		for i in range(found,n):
+			a[i].virtual_address+=dif
+		elffile.write(sys.argv[1])
+		#
+		#point that this script is not checking the existent virtual trail of .data
+		#remove(fn)
+		#
+		exit(0)
+
+exit(-1)
--- /dev/null
+++ ocompiler-1/ostrip/mem.s
@@ -0,0 +1,12 @@
+
+#mem
+function alloc(sd size)
+	sd mem;setcall mem malloc(size)
+	if mem!=(NULL)
+		return mem
+	endif
+#	call mError()
+	call erMessage("malloc error")
+endfunction
+#function mError()
+#endfunction
--- ocompiler-1.orig/ostrip/ostrip.s
+++ ocompiler-1/ostrip/ostrip.s
@@ -1,2 +1,73 @@
 
-format elfobj
+#must do a stripped data.bin and resolved text.bin
+
+#input: exec o1 log1 ... oN logN
+
+format elfobj64
+#modify debian/control exec depends,appimage.yml,debian/control arh order
+
+#at exec
+#there is a rare case with rela.dyn but it is not important here (resolved stderr to object)
+#these are not position independent code and inplace relocs add better with obj64 but at obj32 use addend>=0 or sum<0 error check
+
+#both exec and shared:
+#	pointers to dataind at text/data
+#	aftercall has a copy at .symtab
+
+#only exec:
+#	pointers to aftercall
+
+#only at shared:
+#	.rela.dyn:
+#		addends from pointers to data section (this and the previous are saying the same thing but maybe is compatibility)
+#		data section offsets (direct:^printf, pointers to text/data sections)
+#	aftercall value at .dynsym
+
+#pin about .data align at objects that ld respects when concatenating
+
+include "header.h"
+
+include "throwless.s"
+
+function messagedelim()
+	sv st^stderr
+	Chars visiblemessage={0x0a,0}
+	Call fprintf(st#,#visiblemessage)
+endfunction
+Function Message(ss text)
+	sv st^stderr
+	Call fprintf(st#,text)
+	call messagedelim()
+EndFunction
+function erMessage(ss text)
+	call Message(text)
+	call erEnd()
+endfunction
+function erMessages(ss m1,ss m2)
+	call Message(m1)
+	call Message(m2)
+	call erEnd()
+endfunction
+function erEnd()
+	call frees()
+	aftercall er
+	set er (~0)
+	return (EXIT_FAILURE)
+endfunction
+
+include "file.s"
+include "size.s"
+
+entrylinux main(sd argc,ss *argv0,ss exec,ss obj1,ss *log1)   #... objN logN
+
+if argc>(1+3)  #0 is all the time
+	sv pfile%pexefile
+	sv pexedata%pexedata
+	sv pexetext%pexetext
+	call get_file(exec,pfile,".data",pexedata,".text",pexetext,(ET_EXEC))
+	sub argc 2
+	sd stripped_data_size;setcall stripped_data_size get_offset(#obj1,argc)
+	call frees()
+	return (EXIT_SUCCESS)
+endif
+return (EXIT_FAILURE)
--- /dev/null
+++ ocompiler-1/ostrip/size.s
@@ -0,0 +1,33 @@
+
+function get_offset(sd args,sd end)
+	mult end :
+	add end args
+	sd offset=0
+	while args!=end
+		add args :
+		addcall offset get_offset_item(args)
+		add args :
+	endwhile
+	return offset
+endfunction
+
+function get_offset_item(sd fname)
+	sd file;setcall file fopen(fname,"rb")
+	if file!=(NULL)
+		#at the first 3 documentations there is no info about errno errors for fseek ftell
+		#it is implementation specific, many judgements can be made
+		call seek(file,0,(SEEK_END))
+		sd off;setcall off ftell(file)
+		if off!=-1
+			sub off (2+8)  #knowing \r\n same as ounused that is not headering with src. and 8 is copy-paste
+			call seeks(file,off)
+			chars buf={0,0,0,0, 0,0,0,0, 0}
+			call read(file,#buf,8) #copy-paste
+			datax nr#1
+			call sscanf(#buf,"%08x",#nr) #copy-paste
+			return nr
+		endif
+		call erMessages("ftell error at",fname)
+	endif
+	call fError(fname)
+endfunction
--- /dev/null
+++ ocompiler-1/ostrip/throwless.s
@@ -0,0 +1,36 @@
+
+function frees()
+	valuex exefile#1
+	const pexefile^exefile
+	if exefile!=(NULL)
+		call fclose(exefile)
+		valuex exedata#1
+		const pexedata^exedata
+		if exedata!=(NULL)
+			call free(exedata)
+			valuex exetext#1
+			const pexetext^exetext
+			if exetext!=(NULL)
+				call free(exetext)
+			endif
+		endif
+	endif
+endfunction
+
+
+#file
+
+#pos/-1
+function shnames_find(ss mem,sd end,sd str)
+	sd pos=0
+	while mem!=end
+		sd cmp;setcall cmp strcmp(mem,str)
+		if cmp==0
+			return pos
+		endif
+		addcall mem strlen(mem)
+		inc mem
+		inc pos
+	endwhile
+	return -1
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/Makefile
@@ -0,0 +1,38 @@
+all: ounused
+
+OB = ounused
+OBJ = ${OB}.o
+FULLOBJ = ./${OB}
+FULLOBJS = ${FULLOBJ}.s
+FULLOBJO = ${FULLOBJ}.o
+
+%.o: ${FULLOBJS}
+	../src/o $< exit_end 1
+
+syms =-s
+ATLDCOM = $(LD) ${syms} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc -entry main
+
+ounused: ${OBJ}
+	${ATLDCOM} ${FULLOBJO}
+
+install: ounused
+	install -D ounused \
+		$(DESTDIR)$(prefix)/bin/ounused
+
+clean-compile:
+	-rm -f ${FULLOBJO}
+	-rm -f ${FULLOBJS}.log
+
+clean-link:
+	-rm -f ounused
+
+clean: clean-compile clean-link
+distclean: clean
+
+uninstall:
+	-rm -f $(DESTDIR)$(prefix)/bin/ounused
+
+test:
+	echo "Nothing"
+
+.PHONY: all install clean distclean uninstall test
--- /dev/null
+++ ocompiler-1/ounused/const.s
@@ -0,0 +1,29 @@
+
+function constant_add(sd s,sd sz)
+	sv p
+	setcall p working_file()
+	call addtocont(p,s,sz)
+endfunction
+
+#previous file
+function incrementfiles()
+	sd cursor%levels_dp
+	set cursor cursor#
+	sd pf
+	if cursor==0
+		set pf (NULL)
+	else
+		setcall pf working_file()
+	endelse
+	sv lvs%levels_p
+	call ralloc(lvs,(dword))
+	add cursor lvs#
+	#sd cursor;set cursor lvs#d^;call ralloc(lvs,(dword));add lvs (dword);add cursor lvs#
+	setcall cursor# filessize()
+	return pf
+endfunction
+
+function decrementfiles()
+	sd lvs%levels_p
+	call ralloc(lvs,(-dword))
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/files.s
@@ -0,0 +1,95 @@
+
+const FALSE=0
+const TRUE=1
+
+#const size_cont=dword+:
+const size_cont=:+dword
+const size_conts=5*size_cont
+
+function fileentry_add(sd full,sd len)
+	sd er
+	sd size=size_conts+dword
+	sd ent
+	add size len
+	setcall er malloc_throwless(#ent,size)
+	if er==(NULL)
+		sd init
+		set init ent
+		#
+		setcall er fileentry_init(ent)
+		if er==(NULL)
+			add ent (size_conts)
+			set ent# len
+			add ent (dword)
+			call memcpy(ent,full,len)
+			#
+			sv fls%files_p
+			sd previous_file
+			setcall previous_file incrementfiles()
+			setcall er ralloc_throwless(fls,:)
+			if er==(NULL)
+				sd offset=-:
+				sd mem%files_dp
+				add offset mem#
+				set fls fls#
+				add fls offset
+				#sd mem;set mem fls#d^;call incrementfiles();setcall er ralloc_throwless(fls,:);if er==(NULL);sv cursor;add fls (dword);set cursor fls#;add cursor mem
+				set fls# init
+				if previous_file!=(NULL)
+					add previous_file (2*size_cont)
+					call adddwordtocont(previous_file,offset)
+				endif
+				return (void)
+			endif
+			call fileentry_uninit(init)
+			call free(init)
+			call free(full)
+			call erExit(er)
+		endif
+		call free(init)
+		call free(full)
+		call erExit(er)
+	endif
+	call free(full)
+	call erExit(er)
+endfunction
+
+function fileentry(sd s,sd sz)
+	call nullend(s,sz)
+	sd temp
+	setcall temp realpath(s,(NULL))
+	if temp!=(NULL)
+		call fileentry_exists(temp)
+		call free(temp)
+		return (void)
+	endif
+	call erExit("realpath error")
+endfunction
+
+function fileentry_exists(sd s)
+	sd sz
+	setcall sz strlen(s)
+	sv fls%files_p
+	sd init;set init fls#
+	sv p
+	set p init
+	add fls :
+	set fls fls#d^
+	add fls p
+	while p!=fls
+		sd b
+		setcall b fileentry_compare(p#,s,sz)
+		if b==0
+			call skip_set()
+			#add to previous declared
+			sd wf;setcall wf working_file()
+			sub p init
+			add wf (size_cont)
+			call adddwordtocont(wf,p)
+			return (void)
+		endif
+		incst p
+	#set p fls#d^;add fls (dword);set fls fls#;add p fls;while fls!=p;sd b;setcall b fileentry_compare(fls#,s,sz);if b==0;call skip_set();return (void);endif;incst fls
+	endwhile
+	call fileentry_add(s,sz)
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/header.h
@@ -0,0 +1,32 @@
+
+const EXIT_SUCCESS=0
+const EXIT_FAILURE=1
+
+Importx "stderr" stderr
+Importx "fprintf" fprintf
+
+#resolve
+importx "fwrite" fwrite
+importx "fflush" fflush
+
+#inits
+importx "get_current_dir_name" get_current_dir_name
+importx "strlen" strlen
+
+#files
+importx "realpath" realpath
+
+#mem
+importx "malloc" malloc
+importx "realloc" realloc
+importx "memcpy" memcpy
+importx "memcmp" memcmp
+
+#loop
+importx "fopen" fopen
+importx "fclose" fclose
+importx "getline" getline
+importx "feof" feof
+importx "free" free
+importx "chdir" chdir
+importx "stdout" stdout
--- /dev/null
+++ ocompiler-1/ounused/inits.s
@@ -0,0 +1,30 @@
+
+include "./mem.s"
+
+function allocs()
+	sv ip%imp_mem_p
+	call alloc(ip)
+	sv fp%fn_mem_p
+	call alloc(fp)
+	#
+	sv cwd%cwd_p
+	setcall cwd# get_current_dir_name()
+	if cwd#==(NULL)
+		call erExit("get_current_dir_name error")
+	endif
+	sd size=:
+	add size cwd
+	sd sz
+	setcall sz strlen(cwd#)
+	inc sz
+	set size# sz
+	call ralloc(cwd,(dword))
+	set cwd cwd#
+	add cwd sz
+	set cwd#d^ sz
+	#sv cursor=dword;add cursor cwd;setcall cursor# get_current_dir_name();if cursor#==(NULL);call erExit("get_current_dir_name error");endif;sd size;setcall size strlen(cursor#);inc size;set cwd#d^ size;call ralloc(cwd,(dword));set cursor cursor#;add cursor size;set cursor#d^ size
+	sv fls%files_p
+	call alloc(fls)
+	sv lvs%levels_p
+	call alloc(lvs)
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/loop.s
@@ -0,0 +1,182 @@
+
+const NULL=0
+const void=0
+const asciiperiod=0x2E
+const asciio=0x6F
+
+include "../src/files/headers/log.h"
+
+include "inits.s"
+include "files.s"
+include "const.s"
+include "uconst.s"
+
+function log_file(ss file)
+	sd f
+	setcall f fopen(file,"r")
+	if f!=(NULL)
+		sv fp%logf_p
+		set fp# f
+		sv p%logf_mem_p
+		sd sz=0
+		sd link=TRUE
+		while sz!=-1
+			sd bsz
+			setcall sz getline(p,#bsz,f)
+			if sz!=-1
+				#knowing line\r\n from ocompiler
+				sub sz 2
+				call log_line(p#,sz,#link)
+			else
+				sd e
+				setcall e feof(f)
+				if e==0
+					call erExit("get line error")
+				endif
+			endelse
+		endwhile
+		call uconst_miniresolve()
+		call logclose()
+		if link==(TRUE)
+			call printlink(file)
+		endif
+		return (void)
+	endif
+	call erExit("fopen error")
+endfunction
+
+function log_line(ss s,sd sz,sd plink)
+#i all, f all; at end every f not i, failure. constants are with all includes two types of children declared/already and at every log unused/still unused
+	sd type
+	set type s#
+	inc s;dec sz
+	sd skip
+	if plink#==(TRUE)
+		if type==(log_declare)
+			setcall skip skip_test()
+			if skip==(FALSE)
+				call constant_add(s,sz)
+			endif
+			return (void)
+		elseif type==(log_import)
+			setcall skip skip_test()
+			if skip==(FALSE)
+				call import_add(s,sz)
+			endif
+			return (void)
+		elseif type==(log_constant)
+			call uconst_add(s,sz)
+			return (void)
+		elseif type==(log_function)
+			sv fns%fn_mem_p
+			call addtocont(fns,s,sz)
+			return (void)
+		endelseif
+	endif
+	if type==(log_pathname)
+		call filesplus()
+		setcall skip skip_test()
+		if skip==(FALSE)
+			call fileentry(s,sz)
+		endif
+	elseif type==(log_pathfolder)
+		setcall skip skip_test()
+		if skip==(FALSE)
+			call incrementdir(s,sz)
+		endif
+	elseif type==(log_fileend)
+		setcall skip filesminus()
+		if skip<=0
+			call decrementdir()
+			if skip<0
+				call decrementfiles()
+			endif
+		endif
+	elseif type==(log_fileend_old)
+		setcall skip filesminus()
+		if skip<0
+			call decrementfiles()
+		endif
+	elseif type==(log_reusable)
+		set plink# (FALSE)
+	endelseif
+endfunction
+
+function import_add(sd s,sd sz)
+	sv imps%imp_mem_p
+	sd p
+	setcall p pos_in_cont(imps,s,sz)
+	if p==-1
+		call addtocont(imps,s,sz)
+	endif
+endfunction
+
+function changedir(ss s)
+	if s#!=0 #it's extern chdir error
+		sd d
+		setcall d chdir(s)
+		if d!=0
+			Call erExit("chdir error")
+		endif
+	endif
+endfunction
+function incrementdir(ss s,sd sz)
+	call nullend(s,sz);inc sz
+	sv cwd%cwd_p
+	call addtocont_rev(cwd,s,sz)
+	call changedir(s)
+endfunction
+function decrementdir()
+	sv cwd%cwd_p
+	sd mem=:
+	add mem cwd
+	set mem mem#v^
+	add mem cwd#
+	#sd cwd%cwd_p;sd mem=dword;add mem cwd;set mem mem#v^;add mem cwd#
+	sub mem (dword)
+	#
+	sd sz=dword
+	add sz mem#
+	#
+	sub mem sz
+	sub mem mem#
+	call changedir(mem)
+	neg sz
+	call ralloc(cwd,sz)
+endfunction
+
+function printlink(sd file)
+	ss back
+	set back file
+	addcall back strlen(file)
+	vstr ers="printlink problems with log file name extension."
+	while back!=file
+		dec back
+		if back#==(asciiperiod)
+			while back!=file
+				dec back
+				if back#==(asciiperiod)
+					inc back
+					if back#!=(NULL)
+						set back# (asciio)
+						inc back
+						set back# (NULL)
+						sv st^stdout
+						sd len
+						setCall len fprintf(st#," ")
+						if len==1
+							setCall len fprintf(st#,file)
+							sub back file
+							if len==back
+								return (void)
+							endif
+						endif
+						call erExit("fprintf error.")
+					endif
+					call erExit(ers)
+				endif
+			endwhile
+		endif
+	endwhile
+	call erExit(ers)
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/mem.s
@@ -0,0 +1,58 @@
+
+const dword=4
+
+function alloc(sd p)
+	sd er
+	setcall er alloc_throwless(p)
+	if er==(NULL)
+		return (void)
+	endif
+	call erExit(er)
+endfunction
+
+function ralloc(sv p,sd sz)
+	sd er
+	setcall er ralloc_throwless(p,sz)
+	if er==(NULL)
+		return (void)
+	endif
+	call erExit(er)
+endfunction
+
+function addtocont(sv cont,ss s,sd sz)
+	#knowing ocompiler maxvaluecheck
+	sd size=dword
+	add size sz
+	call ralloc(cont,size)
+	sd mem
+	set mem cont#
+	add cont :
+	add mem cont#d^
+	sub mem sz
+	call memcpy(mem,s,sz)
+	sub mem (dword)
+	set mem# sz
+	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;set oldsize# sz;add oldsize (dword);call memcpy(oldsize,s,sz)
+endfunction
+function addtocont_rev(sv cont,ss s,sd sz)
+	sd size=dword
+	add size sz
+	call ralloc(cont,size)
+	sd mem
+	set mem cont#
+	add cont :
+	add mem cont#d^
+	sub mem (dword)
+	set mem# sz
+	sub mem sz
+	call memcpy(mem,s,sz)
+	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;call memcpy(oldsize,s,sz);add oldsize sz;set oldsize# sz
+endfunction
+function adddwordtocont(sv cont,sd the_dword)
+	call ralloc(cont,(dword))
+	sd pos=-dword
+	add pos cont#
+	add cont :
+	add pos cont#d^
+	set pos# the_dword
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/ounused.s
@@ -0,0 +1,57 @@
+
+#every time this first file has timestamp greater than Makefile, Makefile is deleted
+#or make -B
+
+format elfobj
+
+include "header.h"
+
+include "./throwless.s"
+
+function messagedelim()
+	sv st^stderr
+	Chars visiblemessage={0x0a,0}
+	Call fprintf(st#,#visiblemessage)
+endfunction
+Function Message(ss text)
+	sv st^stderr
+	Call fprintf(st#,text)
+	call messagedelim()
+EndFunction
+function erMessage(ss text)
+	call Message(text)
+	aftercall er
+	set er (~0)
+	return (EXIT_FAILURE)
+endfunction
+function erExit(ss text)
+	call freeall()
+	call erMessage(text)
+endfunction
+
+include "./loop.s"
+include "./resolve.s"
+
+entrylinux main(sd argc,ss *argv0,ss argv1)
+
+if argc>1
+	call inits()
+	call allocs()
+	call filesreset()
+	dec argc
+	sd i
+	set i argc
+	mult argc :
+	sv argv;set argv #argv1
+	add argc argv
+	while argv!=argc
+		call log_file(argv#)
+		call decrementdir()
+		incst argv
+	endwhile
+	call resolve(i)
+	call freeall()
+	return (EXIT_SUCCESS)
+endif
+
+return (EXIT_FAILURE)
--- /dev/null
+++ ocompiler-1/ounused/resolve.s
@@ -0,0 +1,52 @@
+
+function resolve(sd j)
+	sv cont%fn_mem_p
+	sd p
+	sd mem
+	set p cont#
+	add cont :
+	set mem cont#d^
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	sv imps%imp_mem_p
+	sd i=0
+	str f="function"
+	while p!=mem
+		sd len
+		set len p#
+		add p (dword)
+		sd pos
+		setcall pos pos_in_cont(imps,p,len)
+		if pos==-1
+			call wrongExit(f,p,len)
+		endif
+		add p len
+		inc i
+	endwhile
+	str c="constant"
+	call uconst_resolve(c)
+	sd k
+	setcall k uconst_resolved(2)
+	#
+	sv st^stderr
+	sd fls
+	setcall fls filessize()
+	div fls :
+	sd imps_sz
+	setcall imps_sz importssize()
+	sd const_sz
+	setcall const_sz constssize()
+	Call fprintf(st#,"%u logs, %u files, %u unique imports, %u %s, %u %s resolved, %u %s resolved.",j,fls,imps_sz,const_sz,c,i,f,k,c)
+	call messagedelim()
+
+	sv so^stdout
+	call fflush(so#) #there is no line end at stdout, then flush is required
+endfunction
+
+function wrongExit(ss x,ss n,sd len)
+	sv st^stderr
+	set st st#
+	Call fprintf(st,"Unused %s: ",x)
+	call fwrite(n,len,1,st)
+	call erExit("")
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/skip.s
@@ -0,0 +1,48 @@
+
+function filesreset()
+	data f#1
+	const files_nr_p^f
+	set f 0
+	call skip_reset()
+endfunction
+function skip_reset()
+	data s#1
+	const skip_nr_p^s
+	set s 0x7fFFffFF #files pointer array not reaching here
+endfunction
+
+function filesplus()
+	sd f%files_nr_p
+	inc f#
+endfunction
+
+#cmp
+function filesminus()
+	sd f%files_nr_p
+	sd s%skip_nr_p
+	sd nr
+	set nr f#
+	dec f#
+	if nr==s#
+		call skip_reset()
+		return 0
+	elseif nr<s#
+		return -1
+	endelseif
+	return 1
+endfunction
+
+function skip_test()
+	sd s%skip_nr_p
+	sd f%files_nr_p
+	if f#>=s#
+		return (TRUE)
+	endif
+	return (FALSE)
+endfunction
+
+function skip_set()
+	sd s%skip_nr_p
+	sd f%files_nr_p
+	set s# f#
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/throwless.s
@@ -0,0 +1,298 @@
+
+#mem
+
+function malloc_throwless(sv p,sd sz)
+	setcall p# malloc(sz)
+	if p#!=(NULL)
+		return (NULL)
+	endif
+	return "malloc error"
+endfunction
+function alloc_throwless(sd p)
+	sd er
+	setcall er malloc_throwless(p,0)
+	if er==(NULL)
+		add p :
+		set p# 0
+		return (NULL)
+	endif
+	return er
+	#set p# 0;add p (dword);sd er;setcall er malloc_throwless(p,0);return er
+endfunction
+#function ralloc_throwless(sd p,sd sz);add sz p#;if sz>0;sv cursor=dword;add cursor p;setcall cursor# realloc(cursor#,sz);if cursor#!=(NULL);set p# sz
+function ralloc_throwless(sv p,sd sz)
+	sd cursor=:
+	add cursor p
+	add sz cursor#
+	if sz>0
+		setcall p# realloc(p#,sz)
+		if p#!=(NULL)
+			set cursor# sz
+			return (NULL)
+		endif
+		return "realloc error"
+	elseif sz==0  #equal 0 discovered at decrementfiles, since C23 the behaviour is undefined
+	#using this quirk, lvs[0] will be used at constants at end, when size is 0
+		#set p# 0
+		set cursor# 0
+		return (NULL)
+	endelseif
+	return "realloc must stay in 31 bits"
+endfunction
+
+#-1/offset
+function pos_in_cont(sv cont,ss s,sd sz)
+	sd p
+	sd mem=:
+	set p cont#
+	add mem cont
+	set mem mem#
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	while p!=mem
+		sd len
+		set len p#
+		add p (dword)
+		if len==sz
+			sd c
+			setcall c memcmp(s,p,sz)
+			if c==0
+				sub p cont#
+				sub p (dword)
+				return p
+			endif
+		endif
+		add p len
+	endwhile
+	return -1
+endfunction
+
+#inits
+
+function inits()
+	value logf#1
+	const logf_p^logf
+	set logf (NULL)
+	value logf_mem#1
+	const logf_mem_p^logf_mem
+	set logf_mem (NULL)
+	value imp_mem#1;data *#1
+	const imp_mem_p^imp_mem
+	set imp_mem (NULL)
+	value fn_mem#1;data *#1
+	const fn_mem_p^fn_mem
+	set fn_mem (NULL)
+	value cwd#1;data *#1
+	const cwd_p^cwd
+	set cwd (NULL)
+	value files#1;data files_d#1
+	const files_p^files
+	const files_dp^files_d
+	set files (NULL)
+	value levels#1;data levels_d#1
+	const levels_p^levels
+	const levels_dp^levels_d
+	set levels (NULL)
+	call uconst_resolved(0)
+endfunction
+
+function uconst_resolved(sd t,sd size)
+	data nr#1
+	if t==0
+		set nr 0
+	elseif t==1
+		div size (dword)
+		add nr size
+	else
+		return nr
+	endelse
+endfunction
+
+function freeall()
+	sv ip%imp_mem_p
+	if ip#!=(NULL)
+		call free(ip#)
+		sv fp%fn_mem_p
+		if fp#!=(NULL)
+			call free(fp#)
+			sv cwd%cwd_p
+			if cwd#!=(NULL)
+				call free(cwd#)
+				sv fls%files_p
+				if fls#!=(NULL)
+					call freefiles()
+					sv lvs%levels_p
+					if lvs#!=(NULL)
+						call free(lvs#)
+						call logclose()
+					endif
+				endif
+			endif
+		endif
+	endif
+endfunction
+
+function logclose()
+	sv fp%logf_p
+	if fp#!=(NULL)
+		call fclose(fp#)
+		set fp# (NULL)
+		sv p%logf_mem_p
+		if p#!=(NULL)
+			call free(p#)
+			set p# (NULL)
+		endif
+	endif
+endfunction
+
+#files
+
+function freefiles()
+	#sv container%files_p;sv cursor;set cursor container#d^;add container (dword);set container container#;add cursor container;while container!=cursor;decst cursor;sv consts=dword;add consts cursor#;call free(consts#);call free(cursor#);endwhile;call free(cursor)
+	sv container%files_p
+	sv start
+	set start container#
+	add container :
+	set container container#d^
+	add container start
+	while start!=container
+		decst container
+		call fileentry_uninit(container#)
+		call free(container#)
+	endwhile
+	call free(container)
+endfunction
+function fileentry_uninit(sd cont)
+	sd b;set b cont;add b (size_conts)
+	call fileentry_uninit_base(cont,b)
+endfunction
+function fileentry_uninit_base(sd cont,sv cursor)
+	while cont!=cursor
+		sub cursor (size_cont)
+		call free(cursor#)
+	endwhile
+endfunction
+
+#er
+function fileentry_init(sd cont)
+	sd a;set a cont
+	sd b;set b cont;add b (size_conts)
+	while cont!=b
+		sd er
+		setcall er alloc_throwless(cont)
+		if er!=(NULL)
+			call fileentry_uninit_base(a,cont)
+			return er
+		endif
+		add cont (size_cont)
+	endwhile
+	return (NULL)
+endfunction
+
+#cmp
+function fileentry_compare(sd existent,sd new,sd sz)
+	add existent (size_conts)
+	if existent#!=sz
+		return (~0)
+	endif
+	add existent (dword)
+	sd c
+	setcall c memcmp(existent,new,sz)
+	return c
+endfunction
+
+include "skip.s"
+
+#const
+
+#cont
+function working_file()
+	sv lvs%levels_p
+	sd lvsd%levels_dp
+	sv p=-dword
+	add p lvsd#
+	add p lvs#
+	set p p#d^
+	sv fls%files_p
+	add p fls#
+	#sv lvs%levels_p;sv p=-dword;add p lvs#d^;add lvs (dword);add p lvs#;set p p#d^;sv fls%files_vp;add p fls#
+	return p#
+endfunction
+
+#sz
+function filessize()
+	sd fls%files_dp
+	return fls#
+	#sd fls%files_p;set fls fls#;return fls
+endfunction
+
+#sz
+function constssize()
+	sv end%files_p
+	sv cursor
+	set cursor end#
+	add end :
+	set end end#d^
+	add end cursor
+	#sv cursor%files_p;sd end;set end cursor#d^;add cursor (dword);set cursor cursor#;add end cursor
+	sd sz=0
+	while cursor!=end
+		addcall sz constssize_file(cursor#)
+		incst cursor
+	endwhile
+	return sz
+endfunction
+#sz
+#function constssize_file(sd cursor);sd end;set end cursor#;add cursor (dword);set cursor cursor#v^;add end cursor
+function constssize_file(sv end)
+	sd cursor
+	set cursor end#
+	add end :
+	set end end#d^
+	add end cursor
+	sd sz=0
+	while cursor!=end
+		add cursor cursor#
+		add cursor (dword)
+		inc sz
+	endwhile
+	return sz
+endfunction
+
+#uconst
+
+function root_file()
+	sd lvs%levels_p
+	set lvs lvs#v^
+	set lvs lvs#
+	sv fls%files_p
+	set fls fls#
+	add fls lvs
+	return fls#
+endfunction
+
+#loop
+
+function nullend(ss s,sd sz)
+	add s sz;set s# 0 #this is on carriage return
+endfunction
+
+#resolve
+
+function importssize()
+	sv cont%imp_mem_p
+	sd p
+	sd mem
+	set p cont#
+	add cont :
+	set mem cont#d^
+	add mem p
+	#set mem cont#d^;add cont (dword);set p cont#;add mem p
+	sd i=0
+	while p!=mem
+		add p p#
+		add p (dword)
+		inc i
+	endwhile
+	return i
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/uconst.s
@@ -0,0 +1,95 @@
+
+include "uconstres.s"
+
+function uconst_add(sd s,sd sz)
+	sd f
+	setcall f root_file()
+	call uconst_spin(f,s,sz,(TRUE))
+endfunction
+
+#b
+function uconst_spin(sd f,sd s,sd sz,sd is_new)
+	sd const_cont
+	set const_cont f
+	sd found
+	#search in includes declared in other logs
+	add f (size_cont)
+	setcall found uconst_search(f,s,sz,(FALSE))
+	if found==(FALSE)
+		#search in includes declared this log
+		add f (size_cont)
+		setcall found uconst_search(f,s,sz,is_new)
+		if found==(FALSE)
+			#search in constants declared in this file, with respect to is_new
+			sd ofs
+			setcall ofs pos_in_cont(const_cont,s,sz)
+			if ofs!=-1
+				add f (size_cont)
+				if is_new==(FALSE)
+					#if is in unused move it to doubleunused
+					call uconst_unused(f,ofs)
+				else
+					call adddwordtocont(f,ofs)
+				endelse
+				return (TRUE)
+			endif
+		endif
+	endif
+	return (FALSE)
+endfunction
+
+#b
+function uconst_search(sv fs,sd s,sd sz,sd is_new)
+	sd cursor
+	set cursor fs#
+	add fs :
+	set fs fs#d^
+	add fs cursor
+	sv fls%files_p
+	set fls fls#
+	while cursor!=fs
+		sv pointer;set pointer fls
+		add pointer cursor#
+		sd found
+		setcall found uconst_spin(pointer#,s,sz,is_new)
+		if found==(TRUE)
+			return (TRUE)
+		endif
+		add cursor (dword)
+	endwhile
+	return (FALSE)
+endfunction
+
+function uconst_unused(sv cont,sd ofs)
+	sd uns
+	set uns cont
+	sd cursor
+	set cursor cont#
+	add cont :
+	sd end
+	set end cont#d^
+	add end cursor
+	add cont (dword)
+	while cursor!=end
+		sd offset
+		set offset cursor#
+		if offset<=ofs
+			if offset==ofs
+				#move to doubleunused
+				call adddwordtocont(cont,offset)
+				sub end (dword)
+				sd pointer;set pointer cursor
+				while cursor!=end
+					add cursor (dword)
+					set pointer# cursor#
+					add pointer (dword)
+				endwhile
+				call ralloc(uns,(-dword))
+				return (void)
+			endif
+			add cursor (dword)
+		else
+			return (void)
+		endelse
+	endwhile
+endfunction
--- /dev/null
+++ ocompiler-1/ounused/uconstres.s
@@ -0,0 +1,83 @@
+
+function uconst_miniresolve()
+	sd f
+	setcall f root_file()
+	#spin through old declared
+	call uconstres_spin(f,(TRUE))
+endfunction
+
+function uconstres_spin(sd f,sd is_new)
+	sd cont
+	set cont f
+	add f (size_cont)
+	call uconstres_search(f,(FALSE))
+	add f (size_cont)
+	call uconstres_search(f,is_new)
+	#
+	if is_new==(FALSE)
+		#resolve doubleunuseds
+		add f (size_cont)
+		sd double
+		set double f
+		add double (size_cont+:)
+		if double#!=0
+			sub double :
+			value aux#1;data *#1
+			call memcpy(#aux,f,(size_cont))
+			call memcpy(f,double,(size_cont))
+			call memcpy(double,#aux,(size_cont))
+			set f double
+		endif
+		add f :
+		sd size
+		set size f#
+		if size!=0
+			sub f :
+			call uconst_resolved(1,size)
+			neg size
+			call ralloc(f,size)
+		endif
+	endif
+endfunction
+
+function uconstres_search(sv f,sd is_new)
+#there is a segmentation if from a random (not log) file like "format elfobjso", TO DO when wanted
+	sd cursor
+	set cursor f#
+	add f :
+	set f f#d^
+	add f cursor
+	sv fls%files_p
+	set fls fls#
+	while cursor!=f
+		sv pointer;set pointer fls
+		add pointer cursor#
+		call uconstres_spin(pointer#,is_new)
+		add cursor (dword)
+	endwhile
+endfunction
+
+function uconst_resolve(ss const_str)
+	sv fls%files_p
+	sv cursor
+	set cursor fls#
+	add fls :
+	set fls fls#d^
+	add fls cursor
+	while cursor!=fls
+		sd pointer=3*size_cont+:
+		add pointer cursor#
+		if pointer#!=0
+			sub pointer :
+			set pointer pointer#v^
+			set cursor cursor#
+			set cursor cursor#
+			add cursor pointer#
+			sd offset
+			set offset cursor#d^
+			add cursor (dword)
+			call wrongExit(const_str,cursor,offset)
+		endif
+		add cursor :
+	endwhile
+endfunction
--- ocompiler-1.orig/src/files/actions/resolve.s
+++ ocompiler-1/src/files/actions/resolve.s
@@ -40,5 +40,3 @@ While unresptr!=unresptrlastpoint
 
 	Add unresptr dwordsize
 EndWhile
-
-
--- ocompiler-1.orig/src/files/functions/dataassign.s
+++ ocompiler-1/src/files/functions/dataassign.s
@@ -321,7 +321,9 @@ Function dataassign(sd ptrcontent,sd ptr
 					if stack==false
 						setcall err unresLc(0,ptrdatasec,0)
 					else
-						setcall err unresLc((rampadd_value_off),ptrcodesec,0)
+						#it's only an imm to reg
+						sd stack_off;setcall stack_off reloc64_offset((rampadd_value_off))
+						setcall err unresLc(stack_off,ptrcodesec,0)
 					endelse
 					if err!=(noerror)
 						return err
--- ocompiler-1.orig/src/files/functions/elf/elf.s
+++ ocompiler-1/src/files/functions/elf/elf.s
@@ -236,9 +236,6 @@ Function addrel_base(sd offset,sd symbol
 	#const R_X86_64_PC32=R_386_PC32
 	#const R_X86_64_PC64=24
 
-	Data elf_rel#1
-	Data elf_rel_sz#1
-
 	sd err
 	sd x;setcall x is_for_64()
 	if x==(TRUE)
@@ -256,8 +253,7 @@ Function addrel_base(sd offset,sd symbol
 		set elf64_r_info_symbolindex symbolindex
 		set elf64_r_addend addend
 
-		set elf_rel #elf64_r_offset
-		set elf_rel_sz (elf64_dyn_d_val_relent)
+		SetCall err addtosec(#elf64_r_offset,(elf64_dyn_d_val_relent),struct)
 	else
 		#offset
 		Data elf_r_offset#1
@@ -272,11 +268,8 @@ Function addrel_base(sd offset,sd symbol
 		Call memtomem(#elf_r_info_symbolindex,#symbolindex,3)
 		set elf_r_addend addend
 
-		set elf_rel #elf_r_offset
-		set elf_rel_sz (elf32_dyn_d_val_relent)
+		SetCall err addtosec(#elf_r_offset,(elf32_dyn_d_val_relent),struct)
 	endelse
-
-	SetCall err addtosec(elf_rel,elf_rel_sz,struct)
 	Return err
 EndFunction
 
--- ocompiler-1.orig/srcres/Makefile
+++ /dev/null
@@ -1,38 +0,0 @@
-all: ounused
-
-OB = ounused
-OBJ = ${OB}.o
-FULLOBJ = ./${OB}
-FULLOBJS = ${FULLOBJ}.s
-FULLOBJO = ${FULLOBJ}.o
-
-%.o: ${FULLOBJS}
-	../src/o $< exit_end 1
-
-syms =-s
-ATLDCOM = $(LD) ${syms} -melf_i386 --dynamic-linker=/lib/ld-linux.so.2 -o $@ -lc -entry main
-
-ounused: ${OBJ}
-	${ATLDCOM} ${FULLOBJO}
-
-install: ounused
-	install -D ounused \
-		$(DESTDIR)$(prefix)/bin/ounused
-
-clean-compile:
-	-rm -f ${FULLOBJO}
-	-rm -f ${FULLOBJS}.log
-
-clean-link:
-	-rm -f ounused
-
-clean: clean-compile clean-link
-distclean: clean
-
-uninstall:
-	-rm -f $(DESTDIR)$(prefix)/bin/ounused
-
-test:
-	echo "Nothing"
-
-.PHONY: all install clean distclean uninstall test
--- ocompiler-1.orig/srcres/const.s
+++ /dev/null
@@ -1,83 +0,0 @@
-
-#cont
-function working_file()
-	sv lvs%levels_p
-	sd lvsd%levels_dp
-	sv p=-dword
-	add p lvsd#
-	add p lvs#
-	set p p#d^
-	sv fls%files_p
-	add p fls#
-	#sv lvs%levels_p;sv p=-dword;add p lvs#d^;add lvs (dword);add p lvs#;set p p#d^;sv fls%files_vp;add p fls#
-	return p#
-endfunction
-
-function constant_add(sd s,sd sz)
-	sv p
-	setcall p working_file()
-	call addtocont(p,s,sz)
-endfunction
-
-#previous file
-function incrementfiles()
-	sd cursor%levels_dp
-	set cursor cursor#
-	sd pf
-	if cursor==0
-		set pf (NULL)
-	else
-		setcall pf working_file()
-	endelse
-	sv lvs%levels_p
-	call ralloc(lvs,(dword))
-	add cursor lvs#
-	#sd cursor;set cursor lvs#d^;call ralloc(lvs,(dword));add lvs (dword);add cursor lvs#
-	setcall cursor# filessize()
-	return pf
-endfunction
-
-function decrementfiles()
-	sd lvs%levels_p
-	call ralloc(lvs,(-dword))
-endfunction
-
-#sz
-function filessize()
-	sd fls%files_dp
-	return fls#
-	#sd fls%files_p;set fls fls#;return fls
-endfunction
-
-#sz
-function constssize()
-	sv end%files_p
-	sv cursor
-	set cursor end#
-	add end :
-	set end end#d^
-	add end cursor
-	#sv cursor%files_p;sd end;set end cursor#d^;add cursor (dword);set cursor cursor#;add end cursor
-	sd sz=0
-	while cursor!=end
-		addcall sz constssize_file(cursor#)
-		incst cursor
-	endwhile
-	return sz
-endfunction
-#sz
-#function constssize_file(sd cursor);sd end;set end cursor#;add cursor (dword);set cursor cursor#v^;add end cursor
-function constssize_file(sv end)
-	sd cursor
-	set cursor end#
-	add end :
-	set end end#d^
-	add end cursor
-	sd sz=0
-	while cursor!=end
-		add cursor cursor#
-		add cursor (dword)
-		inc sz
-	endwhile
-	return sz
-endfunction
--- ocompiler-1.orig/srcres/files.s
+++ /dev/null
@@ -1,135 +0,0 @@
-
-const FALSE=0
-const TRUE=1
-
-importx "realpath" realpath
-
-#const size_cont=dword+:
-const size_cont=:+dword
-const size_conts=5*size_cont
-
-function fileentry_add(sd full,sd len)
-	sd er
-	sd size=size_conts+dword
-	sd ent
-	add size len
-	setcall er malloc_throwless(#ent,size)
-	if er==(NULL)
-		sd init
-		set init ent
-		#
-		setcall er fileentry_init(ent)
-		if er==(NULL)
-			add ent (size_conts)
-			set ent# len
-			add ent (dword)
-			call memcpy(ent,full,len)
-			#
-			sv fls%files_p
-			sd previous_file
-			setcall previous_file incrementfiles()
-			setcall er ralloc_throwless(fls,:)
-			if er==(NULL)
-				sd offset=-:
-				sd mem%files_dp
-				add offset mem#
-				set fls fls#
-				add fls offset
-				#sd mem;set mem fls#d^;call incrementfiles();setcall er ralloc_throwless(fls,:);if er==(NULL);sv cursor;add fls (dword);set cursor fls#;add cursor mem
-				set fls# init
-				if previous_file!=(NULL)
-					add previous_file (2*size_cont)
-					call adddwordtocont(previous_file,offset)
-				endif
-				return (void)
-			endif
-			call fileentry_uninit(init)
-			call free(init)
-			call free(full)
-			call erExit(er)
-		endif
-		call free(init)
-		call free(full)
-		call erExit(er)
-	endif
-	call free(full)
-	call erExit(er)
-endfunction
-
-#er
-function fileentry_init(sd cont)
-	sd a;set a cont
-	sd b;set b cont;add b (size_conts)
-	while cont!=b
-		sd er
-		setcall er alloc_throwless(cont)
-		if er!=(NULL)
-			call fileentry_uninit_base(a,cont)
-			return er
-		endif
-		add cont (size_cont)
-	endwhile
-	return (NULL)
-endfunction
-function fileentry_uninit(sd cont)
-	sd b;set b cont;add b (size_conts)
-	call fileentry_uninit_base(cont,b)
-endfunction
-function fileentry_uninit_base(sd cont,sv cursor)
-	while cont!=cursor
-		sub cursor (size_cont)
-		call free(cursor#)
-	endwhile
-endfunction
-
-function fileentry(sd s,sd sz)
-	call nullend(s,sz)
-	sd temp
-	setcall temp realpath(s,(NULL))
-	if temp!=(NULL)
-		call fileentry_exists(temp)
-		call free(temp)
-		return (void)
-	endif
-	call erExit("realpath error")
-endfunction
-
-function fileentry_exists(sd s)
-	sd sz
-	setcall sz strlen(s)
-	sv fls%files_p
-	sd init;set init fls#
-	sv p
-	set p init
-	add fls :
-	set fls fls#d^
-	add fls p
-	while p!=fls
-		sd b
-		setcall b fileentry_compare(p#,s,sz)
-		if b==0
-			call skip_set()
-			#add to previous declared
-			sd wf;setcall wf working_file()
-			sub p init
-			add wf (size_cont)
-			call adddwordtocont(wf,p)
-			return (void)
-		endif
-		incst p
-	#set p fls#d^;add fls (dword);set fls fls#;add p fls;while fls!=p;sd b;setcall b fileentry_compare(fls#,s,sz);if b==0;call skip_set();return (void);endif;incst fls
-	endwhile
-	call fileentry_add(s,sz)
-endfunction
-
-#cmp
-function fileentry_compare(sd existent,sd new,sd sz)
-	add existent (size_conts)
-	if existent#!=sz
-		return (~0)
-	endif
-	add existent (dword)
-	sd c
-	setcall c memcmp(existent,new,sz)
-	return c
-endfunction
--- ocompiler-1.orig/srcres/inits.s
+++ /dev/null
@@ -1,113 +0,0 @@
-
-importx "get_current_dir_name" get_current_dir_name
-importx "strlen" strlen
-
-include "./mem.s"
-
-function inits()
-	value logf#1
-	const logf_p^logf
-	set logf (NULL)
-	value logf_mem#1
-	const logf_mem_p^logf_mem
-	set logf_mem (NULL)
-	value imp_mem#1;data *#1
-	const imp_mem_p^imp_mem
-	set imp_mem (NULL)
-	value fn_mem#1;data *#1
-	const fn_mem_p^fn_mem
-	set fn_mem (NULL)
-	value cwd#1;data *#1
-	const cwd_p^cwd
-	set cwd (NULL)
-	value files#1;data files_d#1
-	const files_p^files
-	const files_dp^files_d
-	set files (NULL)
-	value levels#1;data levels_d#1
-	const levels_p^levels
-	const levels_dp^levels_d
-	set levels (NULL)
-	call uconst_resolved(0)
-endfunction
-
-function allocs()
-	sv ip%imp_mem_p
-	call alloc(ip)
-	sv fp%fn_mem_p
-	call alloc(fp)
-	#
-	sv cwd%cwd_p
-	setcall cwd# get_current_dir_name()
-	if cwd#==(NULL)
-		call erExit("get_current_dir_name error")
-	endif
-	sd size=:
-	add size cwd
-	sd sz
-	setcall sz strlen(cwd#)
-	inc sz
-	set size# sz
-	call ralloc(cwd,(dword))
-	set cwd cwd#
-	add cwd sz
-	set cwd#d^ sz
-	#sv cursor=dword;add cursor cwd;setcall cursor# get_current_dir_name();if cursor#==(NULL);call erExit("get_current_dir_name error");endif;sd size;setcall size strlen(cursor#);inc size;set cwd#d^ size;call ralloc(cwd,(dword));set cursor cursor#;add cursor size;set cursor#d^ size
-	sv fls%files_p
-	call alloc(fls)
-	sv lvs%levels_p
-	call alloc(lvs)
-endfunction
-
-function freeall()
-	sv ip%imp_mem_p
-	if ip#!=(NULL)
-		call free(ip#)
-		sv fp%fn_mem_p
-		if fp#!=(NULL)
-			call free(fp#)
-			sv cwd%cwd_p
-			if cwd#!=(NULL)
-				call free(cwd#)
-				sv fls%files_p
-				if fls#!=(NULL)
-					call freefiles()
-					sv lvs%levels_p
-					if lvs#!=(NULL)
-						call free(lvs#)
-						call logclose()
-					endif
-				endif
-			endif
-		endif
-	endif
-endfunction
-
-function logclose()
-	sv fp%logf_p
-	if fp#!=(NULL)
-		call fclose(fp#)
-		set fp# (NULL)
-		sv p%logf_mem_p
-		if p#!=(NULL)
-			call free(p#)
-			set p# (NULL)
-		endif
-	endif
-endfunction
-
-function freefiles()
-	#sv container%files_p;sv cursor;set cursor container#d^;add container (dword);set container container#;add cursor container;while container!=cursor;decst cursor;sv consts=dword;add consts cursor#;call free(consts#);call free(cursor#);endwhile;call free(cursor)
-	sv container%files_p
-	sv start
-	set start container#
-	add container :
-	set container container#d^
-	add container start
-	while start!=container
-		decst container
-		call fileentry_uninit(container#)
-		call free(container#)
-	endwhile
-	call free(container)
-endfunction
--- ocompiler-1.orig/srcres/loop.s
+++ /dev/null
@@ -1,195 +0,0 @@
-
-const NULL=0
-const void=0
-const asciiperiod=0x2E
-const asciio=0x6F
-
-importx "fopen" fopen
-importx "fclose" fclose
-importx "getline" getline
-importx "feof" feof
-importx "free" free
-importx "chdir" chdir
-importx "stdout" stdout
-
-include "../src/files/headers/log.h"
-
-include "inits.s"
-include "files.s"
-include "skip.s"
-include "const.s"
-include "uconst.s"
-
-function log_file(ss file)
-	sd f
-	setcall f fopen(file,"r")
-	if f!=(NULL)
-		sv fp%logf_p
-		set fp# f
-		sv p%logf_mem_p
-		sd sz=0
-		sd link=TRUE
-		while sz!=-1
-			sd bsz
-			setcall sz getline(p,#bsz,f)
-			if sz!=-1
-				#knowing line\r\n from ocompiler
-				sub sz 2
-				call log_line(p#,sz,#link)
-			else
-				sd e
-				setcall e feof(f)
-				if e==0
-					call erExit("get line error")
-				endif
-			endelse
-		endwhile
-		call uconst_miniresolve()
-		call logclose()
-		if link==(TRUE)
-			call printlink(file)
-		endif
-		return (void)
-	endif
-	call erExit("fopen error")
-endfunction
-
-function log_line(ss s,sd sz,sd plink)
-#i all, f all; at end every f not i, failure. constants are with all includes two types of children declared/already and at every log unused/still unused
-	sd type
-	set type s#
-	inc s;dec sz
-	sd skip
-	if plink#==(TRUE)
-		if type==(log_declare)
-			setcall skip skip_test()
-			if skip==(FALSE)
-				call constant_add(s,sz)
-			endif
-			return (void)
-		elseif type==(log_import)
-			setcall skip skip_test()
-			if skip==(FALSE)
-				call import_add(s,sz)
-			endif
-			return (void)
-		elseif type==(log_constant)
-			call uconst_add(s,sz)
-			return (void)
-		elseif type==(log_function)
-			sv fns%fn_mem_p
-			call addtocont(fns,s,sz)
-			return (void)
-		endelseif
-	endif
-	if type==(log_pathname)
-		call filesplus()
-		setcall skip skip_test()
-		if skip==(FALSE)
-			call fileentry(s,sz)
-		endif
-	elseif type==(log_pathfolder)
-		setcall skip skip_test()
-		if skip==(FALSE)
-			call incrementdir(s,sz)
-		endif
-	elseif type==(log_fileend)
-		setcall skip filesminus()
-		if skip<=0
-			call decrementdir()
-			if skip<0
-				call decrementfiles()
-			endif
-		endif
-	elseif type==(log_fileend_old)
-		setcall skip filesminus()
-		if skip<0
-			call decrementfiles()
-		endif
-	elseif type==(log_reusable)
-		set plink# (FALSE)
-	endelseif
-endfunction
-
-function import_add(sd s,sd sz)
-	sv imps%imp_mem_p
-	sd p
-	setcall p pos_in_cont(imps,s,sz)
-	if p==-1
-		call addtocont(imps,s,sz)
-	endif
-endfunction
-
-function nullend(ss s,sd sz)
-	add s sz;set s# 0 #this is on carriage return
-endfunction
-
-function changedir(ss s)
-	if s#!=0 #it's extern chdir error
-		sd d
-		setcall d chdir(s)
-		if d!=0
-			Call erExit("chdir error")
-		endif
-	endif
-endfunction
-function incrementdir(ss s,sd sz)
-	call nullend(s,sz);inc sz
-	sv cwd%cwd_p
-	call addtocont_rev(cwd,s,sz)
-	call changedir(s)
-endfunction
-function decrementdir()
-	sv cwd%cwd_p
-	sd mem=:
-	add mem cwd
-	set mem mem#v^
-	add mem cwd#
-	#sd cwd%cwd_p;sd mem=dword;add mem cwd;set mem mem#v^;add mem cwd#
-	sub mem (dword)
-	#
-	sd sz=dword
-	add sz mem#
-	#
-	sub mem sz
-	sub mem mem#
-	call changedir(mem)
-	neg sz
-	call ralloc(cwd,sz)
-endfunction
-
-function printlink(sd file)
-	ss back
-	set back file
-	addcall back strlen(file)
-	vstr ers="printlink problems with log file name extension."
-	while back!=file
-		dec back
-		if back#==(asciiperiod)
-			while back!=file
-				dec back
-				if back#==(asciiperiod)
-					inc back
-					if back#!=(NULL)
-						set back# (asciio)
-						inc back
-						set back# (NULL)
-						sv st^stdout
-						sd len
-						setCall len fprintf(st#," ")
-						if len==1
-							setCall len fprintf(st#,file)
-							sub back file
-							if len==back
-								return (void)
-							endif
-						endif
-						call erExit("fprintf error.")
-					endif
-					call erExit(ers)
-				endif
-			endwhile
-		endif
-	endwhile
-	call erExit(ers)
-endfunction
--- ocompiler-1.orig/srcres/mem.s
+++ /dev/null
@@ -1,128 +0,0 @@
-
-const dword=4
-
-importx "malloc" malloc
-importx "realloc" realloc
-importx "memcpy" memcpy
-importx "memcmp" memcmp
-
-function malloc_throwless(sv p,sd sz)
-	setcall p# malloc(sz)
-	if p#!=(NULL)
-		return (NULL)
-	endif
-	return "malloc error"
-endfunction
-function alloc(sd p)
-	sd er
-	setcall er alloc_throwless(p)
-	if er==(NULL)
-		return (void)
-	endif
-	call erExit(er)
-endfunction
-function alloc_throwless(sd p)
-	sd er
-	setcall er malloc_throwless(p,0)
-	if er==(NULL)
-		add p :
-		set p# 0
-		return (NULL)
-	endif
-	return er
-	#set p# 0;add p (dword);sd er;setcall er malloc_throwless(p,0);return er
-endfunction
-
-#function ralloc_throwless(sd p,sd sz);add sz p#;if sz>0;sv cursor=dword;add cursor p;setcall cursor# realloc(cursor#,sz);if cursor#!=(NULL);set p# sz
-function ralloc_throwless(sv p,sd sz)
-	sd cursor=:
-	add cursor p
-	add sz cursor#
-	if sz>0
-		setcall p# realloc(p#,sz)
-		if p#!=(NULL)
-			set cursor# sz
-			return (NULL)
-		endif
-		return "realloc error"
-	elseif sz==0  #equal 0 discovered at decrementfiles, since C23 the behaviour is undefined
-	#using this quirk, lvs[0] will be used at constants at end, when size is 0
-		#set p# 0
-		set cursor# 0
-		return (NULL)
-	endelseif
-	return "realloc must stay in 31 bits"
-endfunction
-function ralloc(sv p,sd sz)
-	sd er
-	setcall er ralloc_throwless(p,sz)
-	if er==(NULL)
-		return (void)
-	endif
-	call erExit(er)
-endfunction
-
-function addtocont(sv cont,ss s,sd sz)
-	#knowing ocompiler maxvaluecheck
-	sd size=dword
-	add size sz
-	call ralloc(cont,size)
-	sd mem
-	set mem cont#
-	add cont :
-	add mem cont#d^
-	sub mem sz
-	call memcpy(mem,s,sz)
-	sub mem (dword)
-	set mem# sz
-	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;set oldsize# sz;add oldsize (dword);call memcpy(oldsize,s,sz)
-endfunction
-function addtocont_rev(sv cont,ss s,sd sz)
-	sd size=dword
-	add size sz
-	call ralloc(cont,size)
-	sd mem
-	set mem cont#
-	add cont :
-	add mem cont#d^
-	sub mem (dword)
-	set mem# sz
-	sub mem sz
-	call memcpy(mem,s,sz)
-	#sd oldsize;set oldsize cont#d^;sd size=dword;add size sz;call ralloc(cont,size);add cont (dword);add oldsize cont#;call memcpy(oldsize,s,sz);add oldsize sz;set oldsize# sz
-endfunction
-function adddwordtocont(sv cont,sd the_dword)
-	call ralloc(cont,(dword))
-	sd pos=-dword
-	add pos cont#
-	add cont :
-	add pos cont#d^
-	set pos# the_dword
-endfunction
-
-#-1/offset
-function pos_in_cont(sv cont,ss s,sd sz)
-	sd p
-	sd mem=:
-	set p cont#
-	add mem cont
-	set mem mem#
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	while p!=mem
-		sd len
-		set len p#
-		add p (dword)
-		if len==sz
-			sd c
-			setcall c memcmp(s,p,sz)
-			if c==0
-				sub p cont#
-				sub p (dword)
-				return p
-			endif
-		endif
-		add p len
-	endwhile
-	return -1
-endfunction
--- ocompiler-1.orig/srcres/ounused.s
+++ /dev/null
@@ -1,59 +0,0 @@
-
-#every time this first file has timestamp greater than Makefile, Makefile is deleted
-#or make -B
-
-format elfobj
-
-const EXIT_SUCCESS=0
-const EXIT_FAILURE=1
-
-Importx "stderr" stderr
-Importx "fprintf" fprintf
-
-function messagedelim()
-	sv st^stderr
-	Chars visiblemessage={0x0a,0}
-	Call fprintf(st#,#visiblemessage)
-endfunction
-Function Message(ss text)
-	sv st^stderr
-	Call fprintf(st#,text)
-	call messagedelim()
-EndFunction
-function erMessage(ss text)
-	call Message(text)
-	aftercall er
-	set er (~0)
-	return (EXIT_FAILURE)
-endfunction
-function erExit(ss text)
-	call freeall()
-	call erMessage(text)
-endfunction
-
-include "./loop.s"
-include "./resolve.s"
-
-entrylinux main(sd argc,ss *argv0,ss argv1)
-
-if argc>1
-	call inits()
-	call allocs()
-	call filesreset()
-	dec argc
-	sd i
-	set i argc
-	mult argc :
-	sv argv;set argv #argv1
-	add argc argv
-	while argv!=argc
-		call log_file(argv#)
-		call decrementdir()
-		incst argv
-	endwhile
-	call resolve(i)
-	call freeall()
-	return (EXIT_SUCCESS)
-endif
-
-return (EXIT_FAILURE)
--- ocompiler-1.orig/srcres/resolve.s
+++ /dev/null
@@ -1,73 +0,0 @@
-
-importx "fwrite" fwrite
-importx "fflush" fflush
-
-function resolve(sd j)
-	sv cont%fn_mem_p
-	sd p
-	sd mem
-	set p cont#
-	add cont :
-	set mem cont#d^
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	sv imps%imp_mem_p
-	sd i=0
-	str f="function"
-	while p!=mem
-		sd len
-		set len p#
-		add p (dword)
-		sd pos
-		setcall pos pos_in_cont(imps,p,len)
-		if pos==-1
-			call wrongExit(f,p,len)
-		endif
-		add p len
-		inc i
-	endwhile
-	str c="constant"
-	call uconst_resolve(c)
-	sd k
-	setcall k uconst_resolved(2)
-	#
-	sv st^stderr
-	sd fls
-	setcall fls filessize()
-	div fls :
-	sd imps_sz
-	setcall imps_sz importssize()
-	sd const_sz
-	setcall const_sz constssize()
-	Call fprintf(st#,"%u logs, %u files, %u unique imports, %u %s, %u %s resolved, %u %s resolved.",j,fls,imps_sz,const_sz,c,i,f,k,c)
-	call messagedelim()
-
-	sv so^stdout
-	call fflush(so#) #there is no line end at stdout, then flush is required
-endfunction
-
-function wrongExit(ss x,ss n,sd len)
-	sv st^stderr
-	set st st#
-	Call fprintf(st,"Unused %s: ",x)
-	call fwrite(n,len,1,st)
-	call erExit("")
-endfunction
-
-function importssize()
-	sv cont%imp_mem_p
-	sd p
-	sd mem
-	set p cont#
-	add cont :
-	set mem cont#d^
-	add mem p
-	#set mem cont#d^;add cont (dword);set p cont#;add mem p
-	sd i=0
-	while p!=mem
-		add p p#
-		add p (dword)
-		inc i
-	endwhile
-	return i
-endfunction
--- ocompiler-1.orig/srcres/skip.s
+++ /dev/null
@@ -1,48 +0,0 @@
-
-function filesreset()
-	data f#1
-	const files_nr_p^f
-	set f 0
-	call skip_reset()
-endfunction
-function skip_reset()
-	data s#1
-	const skip_nr_p^s
-	set s 0x7fFFffFF #files pointer array not reaching here
-endfunction
-
-function filesplus()
-	sd f%files_nr_p
-	inc f#
-endfunction
-
-#cmp
-function filesminus()
-	sd f%files_nr_p
-	sd s%skip_nr_p
-	sd nr
-	set nr f#
-	dec f#
-	if nr==s#
-		call skip_reset()
-		return 0
-	elseif nr<s#
-		return -1
-	endelseif
-	return 1
-endfunction
-
-function skip_test()
-	sd s%skip_nr_p
-	sd f%files_nr_p
-	if f#>=s#
-		return (TRUE)
-	endif
-	return (FALSE)
-endfunction
-
-function skip_set()
-	sd s%skip_nr_p
-	sd f%files_nr_p
-	set s# f#
-endfunction
--- ocompiler-1.orig/srcres/uconst.s
+++ /dev/null
@@ -1,105 +0,0 @@
-
-include "uconstres.s"
-
-function root_file()
-	sd lvs%levels_p
-	set lvs lvs#v^
-	set lvs lvs#
-	sv fls%files_p
-	set fls fls#
-	add fls lvs
-	return fls#
-endfunction
-
-function uconst_add(sd s,sd sz)
-	sd f
-	setcall f root_file()
-	call uconst_spin(f,s,sz,(TRUE))
-endfunction
-
-#b
-function uconst_spin(sd f,sd s,sd sz,sd is_new)
-	sd const_cont
-	set const_cont f
-	sd found
-	#search in includes declared in other logs
-	add f (size_cont)
-	setcall found uconst_search(f,s,sz,(FALSE))
-	if found==(FALSE)
-		#search in includes declared this log
-		add f (size_cont)
-		setcall found uconst_search(f,s,sz,is_new)
-		if found==(FALSE)
-			#search in constants declared in this file, with respect to is_new
-			sd ofs
-			setcall ofs pos_in_cont(const_cont,s,sz)
-			if ofs!=-1
-				add f (size_cont)
-				if is_new==(FALSE)
-					#if is in unused move it to doubleunused
-					call uconst_unused(f,ofs)
-				else
-					call adddwordtocont(f,ofs)
-				endelse
-				return (TRUE)
-			endif
-		endif
-	endif
-	return (FALSE)
-endfunction
-
-#b
-function uconst_search(sv fs,sd s,sd sz,sd is_new)
-	sd cursor
-	set cursor fs#
-	add fs :
-	set fs fs#d^
-	add fs cursor
-	sv fls%files_p
-	set fls fls#
-	while cursor!=fs
-		sv pointer;set pointer fls
-		add pointer cursor#
-		sd found
-		setcall found uconst_spin(pointer#,s,sz,is_new)
-		if found==(TRUE)
-			return (TRUE)
-		endif
-		add cursor (dword)
-	endwhile
-	return (FALSE)
-endfunction
-
-function uconst_unused(sv cont,sd ofs)
-	sd uns
-	set uns cont
-	sd cursor
-	set cursor cont#
-	add cont :
-	sd end
-	set end cont#d^
-	add end cursor
-	add cont (dword)
-	while cursor!=end
-		sd offset
-		set offset cursor#
-		if offset<=ofs
-			if offset==ofs
-				#move to doubleunused
-				call adddwordtocont(cont,offset)
-				sub end (dword)
-				sd pointer;set pointer cursor
-				while cursor!=end
-					add cursor (dword)
-					set pointer# cursor#
-					add pointer (dword)
-				endwhile
-				call ralloc(uns,(-dword))
-				return (void)
-			endif
-			add cursor (dword)
-		else
-			return (void)
-		endelse
-	endwhile
-endfunction
--- ocompiler-1.orig/srcres/uconstres.s
+++ /dev/null
@@ -1,95 +0,0 @@
-
-function uconst_miniresolve()
-	sd f
-	setcall f root_file()
-	#spin through old declared
-	call uconstres_spin(f,(TRUE))
-endfunction
-
-function uconstres_spin(sd f,sd is_new)
-	sd cont
-	set cont f
-	add f (size_cont)
-	call uconstres_search(f,(FALSE))
-	add f (size_cont)
-	call uconstres_search(f,is_new)
-	#
-	if is_new==(FALSE)
-		#resolve doubleunuseds
-		add f (size_cont)
-		sd double
-		set double f
-		add double (size_cont+:)
-		if double#!=0
-			sub double :
-			value aux#1;data *#1
-			call memcpy(#aux,f,(size_cont))
-			call memcpy(f,double,(size_cont))
-			call memcpy(double,#aux,(size_cont))
-			set f double
-		endif
-		add f :
-		sd size
-		set size f#
-		if size!=0
-			sub f :
-			call uconst_resolved(1,size)
-			neg size
-			call ralloc(f,size)
-		endif
-	endif
-endfunction
-
-function uconstres_search(sv f,sd is_new)
-#there is a segmentation if from a random (not log) file like "format elfobjso", TO DO when wanted
-	sd cursor
-	set cursor f#
-	add f :
-	set f f#d^
-	add f cursor
-	sv fls%files_p
-	set fls fls#
-	while cursor!=f
-		sv pointer;set pointer fls
-		add pointer cursor#
-		call uconstres_spin(pointer#,is_new)
-		add cursor (dword)
-	endwhile
-endfunction
-
-function uconst_resolve(ss const_str)
-	sv fls%files_p
-	sv cursor
-	set cursor fls#
-	add fls :
-	set fls fls#d^
-	add fls cursor
-	while cursor!=fls
-		sd pointer=3*size_cont+:
-		add pointer cursor#
-		if pointer#!=0
-			sub pointer :
-			set pointer pointer#v^
-			set cursor cursor#
-			set cursor cursor#
-			add cursor pointer#
-			sd offset
-			set offset cursor#d^
-			add cursor (dword)
-			call wrongExit(const_str,cursor,offset)
-		endif
-		add cursor :
-	endwhile
-endfunction
-
-function uconst_resolved(sd t,sd size)
-	data nr#1
-	if t==0
-		set nr 0
-	elseif t==1
-		div size (dword)
-		add nr size
-	else
-		return nr
-	endelse
-endfunction
