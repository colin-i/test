

<style>
	.code
	{
		font-family:'courier';
		font-style:italic;
		display:block;
		margin-top:10px;
		margin-bottom:10px;
	}
</style>

<h2>O Language Documentation</h2>

<h3><a href="#introduction">I. Introduction</a></h3>

<h3><a href="#declaringdata">II. Declaring data</a></h3>

<h3><a href="#basicoperations">III. Basic operations</a></h3>

<h3><a href="#arithmeticoperations">IV. Arithmetic operations</a></h3>

<h3><a href="#bitwiseoperations">V. Bitwise operations</a></h3>

<h3><a href="#usingpointers">VI. Using pointers</a></h3>

<h3><a href="#usingfunctions">VII. Using functions</a></h3>

<h3><a href="#importinglibraries">VIII. Importing from libraries</a></h3>

<h3><a href="#usingconditions">IX. Using conditions</a></h3>

<h3><a href="#looping">X. Looping</a></h3>

<h3><a href="#includingfiles">XI. Including files</a></h3>

<h3><a href="#exec">XII. Creating executable files</a></h3>

<h3><a href="#object">XIII. Creating object files</a></h3>

<h3><a href="#otheroperations">XIV. Other operations</a></h3>






<h3><a name="introduction">I. Introduction</a></h3>
<p>
	The O language use constants, variables, pointers that are decimal integers or hexadecimal numbers.
	<br>
	Exe files for Windows and Elf executable files for Linux-based systems can be created.
	<br>
	Object files that have elf relocatable format can be created.
	<br>
	The language commands are case INsensitive.
	<br>
	At the beginning data can be declared with diverse methods.
	<br>
	The language has basic, arithmetic, bitwise operations.
	<br>
	The pointer mechanism is used to handle the variables more easily.
	<br>
	Functions can be declared and called.
	<br>
	External libraries can be imported.
	<br>
	Code conditions are if-elseif-else.
	<br>
	Files can be included to form complex programs.
	<br>
	There are 2 scopes: the global scope and the function scope.
	<br>
	The commands are from i386 with extension for x86-64 (but with the HEX macro anything can be wrote to code section).
	<br>
	All 4/8 bytes variables are sign extended. 1 byte variables are zero extended.
</p>

<h3><a name="declaringdata">II. Declaring data</a></h3>
<p>
	The language has 7 names for data declaration (1 for constants and 6 for variables).

	<p>
	1. Constants
	<br>
	Language command: <b>Const</b>
	<br>
	Is a 32 bit value. It's content is declared into the memory(variables are declared into the file) therefore it is used at header files.
	<br>
	Constants have a separate declaration scope.
	<br>
	Constants(like ordinary integers) can be used at operations, but to avoid same names these are introduced with parenthesis (); without parenthesis only one integer can be used 
	<br>
	Example:
	<br>
	<a class="code">
	Const TRUE=1<br>
	if 20==(ConstantValue+11)<br>
&emsp;		set	x	20<br>
	endif<br>
	Const x=3$2<br>
    #is 3 pow 2 = 9</a>
	</p>

	<p>
	2. Data
	<br>
	Language command: <b>Data</b>
	<br>
	Is a 32 bit value. It is used for operations, pointer operations.
	<br>
	Example:
	<br>
	<a class="code">Data variable=100</a>
	</p>

	<p>
	3. Strings
	<br>
	Language command: <b>Str</b>
	<br>
	Is a 32 bit value. It is used for pointer operations.
	<br>
	Example:
	<br>
	<a class="code">
    Chars charsdata="Text"<br>
    Str string^charsdata<br>
    Str text="Text data"</a>
	</p>

	<p>
	4. Characters
	<br>
	Language command: <b>Chars</b>
	<br>
	Is a 8 bit value. It is used for operations.
	<br>
	Example:
	<br>
	<a class="code">
    Chars value={1}<br>
    Chars value=1<br>
    Chars value="Add text here"</a>
	</p>

	<p>
	5 - 7. Stack variables
	<br>
	Language command: <b>SD</b> = Stack Data
	<br>
	Language command: <b>SS</b> = Stack String
	<br>
	Language command: <b>SV</b> = Stack Value
	<br>
	At 64bit code all stack variables are 8 bytes. 4 bytes at 32.
	<br>
	Stack Value differentiates at 64bit code. It will point at 8 bytes ('sv#').
	At 32bit code sd and sv are the same.
	Sd is pointing at 4 and ss at 1.
	<br>
	These variables are located on the stack. The methods for declaring SD/SS/SV are the same as for Data/String.
	<br>
	Stack variables can be declared without a sign. The implicit method in this case is '#1' (reserve one unit).
	<br>
	Example:
	<br>
	<a class="code">
    Chars charsdata="Text"<br>
    function recursive(sd stackdata)<br>
    endfunction<br>
    ss string="Text"<br>
    sd reserve<br>
    sd another_reserve#1</a>
	</p>

	<p>
	8 - 10. Value variables
	<br>
	Language command: <b>VDATA</b>
	<br>
	Language command: <b>VSTR</b>
	<br>
	Language command: <b>VALUE</b>
	<br>
	They will declare 8 bytes for a unit on 64 bit format file.
	<br>
	The pointer is like for stack variables; vdata 4, vstr 1, value 4/8.
	</p>

	<p>
	11 - 16. Virtual variables
	<br>
	Language command: <b>DATAX</b>
	<br>
	Language command: <b>STRX</b>
	<br>
	Language command: <b>CHARSX</b>
	<br>
	Language command: <b>VDATAX</b>
	<br>
	Language command: <b>VSTRX</b>
	<br>
	Language command: <b>VALUEX</b>
	<br>
	These will be in a nobits section at object. Set nobits_virtual preference to 0 for old behavior:
	these will be physically placed after the counterparts and the starting offset will be logged
	so ostrip can remove them after ld linked the objects.
	</p>

	<br>

	<p>
	Data can be declared using the following methods:
	</p>

	<p>
	1. Equal sign ('=')
	<p>
	First method.
	<br>
	Example:
	<br>
	<a class="code">
        Const fruits=20<br>
        Data value=-70<br>
        Chars text="The quick brown fox jumps over the laxy dog."<br>
        Str stringASM=0x401000</a>
	</p>
	<p>
	Second method is with '{}' signs.
	<br>
	Example:
	<br>
	<a class="code">
        Data values={1,3,900}<br>
        Chars bytes={1,4,100}<br>
        Str pointers={0x401010,0x401020}</a>
	</p>
	</p>

	<p>
	2. Reservation sign ('#')
	<br>
	Example:
	<br>
	<a class="code">
        Data reserveDATA#10<br>
        #the data section will have 40 bytes reserved<br>
        Chars reserveCHARS#10<br>
        #the data section will have 10 bytes reserved<br>
        Str reservePointers#10<br>
        #the data section will have 40 bytes reserved</a>
	</p>

	<p>
	3. Pointer sign ('^')
	<br>
	Right side can have variables and at object format, when left side is not constant, can have functions.
	Variables that point to a function can be called like a function. At the executables format (ex: not elfobj), when pointing to an import function the supported manner is with double pointer(^^); all cases, except this one, use the normal pointer(^).
	<br>
	Example:
	<br>
	<a class="code">
        Data value=1<br>
        Data pointervalue^value<br>
        Chars bytes="Raw text data declaration."<br>
        Str text^bytes</a>
	</p>

	<p>
	4. Relocation sign ('%')
	<br>
	Used at the object format. It acts like equal sign and then the offset is added to the REL section.
	At executables it translated to '='. At Str and quotations declaration the equal sign adds at object to Rel and this sign cannot be used here. At Chars the sign cannot be used.
	<br>
	Add another '%' sign to point to .dtnb section instead of .data if applicable.
	<br>
	Example:
	<br>
	<a class="code">
        Format ElfObj<br>
        Data global=100<br>
        Const ptrglobal^global<br>
        Function test()<br>
&emsp;			Data local=200<br>
&emsp;			Data reference%ptrglobal<br>
&emsp;			Add local reference#<br>
&emsp;			#200+100<br>
&emsp;			Return local<br>
        EndFunction<br>
        Entry main()<br>
&emsp;		Data item#1<br>
&emsp;		SetCall item test()<br>
&emsp;		Data addmore=300<br>
&emsp;		Data apointer^addmore<br>
&emsp;		Add item apointer#<br>
&emsp;		#300+300<br>
&emsp;		Return item</a>
	</p>
<br>
	<p>
	Operations can be performed at declarations with arithmetic (+,-,*,/,%,$), bitwise (&,|,^,~,&lt;&lt;,&gt;&gt;) and logical (&lt;,&gt;) signs. - and ~ can prefix a number/constant.
	<br>
	Example:
	<br>
	<table class="code">
	<tr><td>const a=1</td></tr>
	<tr><td>#</td>                <td>add</td> <td>sub</td> <td>mul</td> <td>div</td>   <td>rem</td>   <td>pow</td> <td>and</td> <td>or</td>  <td>xor</td> <td>shl</td> <td>sar</td> <td>less</td><td>greater</td><td>neg</td><td>not</td></tr>
	<tr><td>chars *examples={</td><td>3+2,</td><td>6-4.</td><td>5*5,</td><td>32/10,</td><td>32/10,</td><td>3$2,</td><td>7&2,</td><td>5|2,</td><td>7^2,</td><td>2<2,</td><td>8>3,</td><td>2<3,</td><td>2>3,</td>   <td>-a</td> <td>~0}</td></tr>
	<tr><td>#</td>                <td>5</td>   <td>2</td>   <td>25</td>  <td>3</td>     <td>2</td>     <td>9</td>   <td>2</td>   <td>7</td>   <td>5</td>   <td>8</td>   <td>1</td>   <td>1</td>   <td>0</td>      <td>-1</td> <td>0xff</td></tr>
	</table>
	<a class="code">
	 const a=3*(1+2)<br>
	 return (a) #9</a>
	</p>

	<p>
	If a variable is not used at code operations a warning will be displayed for that variable name.
	To create unreferenced values use the * sign.
	<br>
	Example:
	<br>
	<a class="code">
        Data struct=3<br>
        Data *structValue=1000<br>
        Data structures^struct<br>
        #the "structures" variable can be used in the program as a pointer<br>
        Entry event(data *widget,data signal)<br>
        return signal<br>
        #only the signal value is checked for unreferences</a>
	</p>

	<p>
	To disable the unreferenced warning or to set options at symbols see '.ocompiler.txt' file.
	<br>
	<br>
	The data declarations can be made in the global scope or in the function scope.
	All the constants are in the global scope.
	When a function is declared all the variables declared in the function can not be used outside that function because they are in the function scope.
	<br>
	The "!" character represents the data section cursor and can be used in place of a number. "!X" represents the nobits data section cursor if applicable.
	<br>
	The ":" character represents the size of an integer and can be used in the place of a number. Returns 4B on 32-bits, 8B on 64-bits.
	<br>
	The <b>AfterCall</b> set a value to be tested with zero at the every call and to return if it is not zero.
	<br>
	<b>ImportAfterCall</b> is used in objects to import an extern defined AfterCall.
	<br>
	<b>^</b> sign will create throwless variables.
	<br>
	<a class="code">
	function pre_test()<br>
		return 3<br>
	endfunction<br>
	aftercall interrupt<br>
	function test()<br>
		return 3<br>
	endfunction<br>
	entry main()<br>
	set interrupt 1<br>
	call pre_test()<br>
	#it is still going on<br>
	value ^throwless^test<br>
	call throwless()<br>
	#it is still going on<br>
	call test()<br>
	#here is the end, the program last return was 3<br>
	return 5</a>
	</p>
</p>

<h3><a name="basicoperations">III. Basic operations</a></h3>
<p>
	<p>
	1. Return
	<br>
	Language command: <b>Return</b> <b>Ret</b> <b>Exit</b>
	<br>
	The return command is used to terminate the program or a function.
	<br>
	The asm value termination is <i>ret</i> (0xc3). To return <i>int 0x80</i>(0xcd,0x80;linux sys_exit;eax=1,ebx=return value) use <b>Exit</b>.
	<br>
	To return without a value use <b>Ret</b>.
	<br>
	To return like <b>Exit</b> at main scope but using returns set exit_end preference to 1.
	<br>
	Example:
	<br>
	<a class="code">
        Data true=1<br>
        Return true<br>
        #the program exit code will be 1</a>
	</p>
	<p>
	2. Set
	<br>
	Language command: <b>Set</b>
	<br>
	The set command is used to set one value to another.
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=20<br>
        Data valueB=30<br>
        Set valueA valueB<br>
        #the valueA will be 30<br>
        sd string<br>
        set string "text test"<br>
        #string will point to "text test"</a>
	</p>
</p>


<h3><a name="arithmeticoperations">IV. Arithmetic operations</a></h3>
<p>
	<p>
	1. Addition
	<br>
	Language command: <b>Add</b>
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=20<br>
        Data valueB=30<br>
        Add valueA valueB<br>
        #the valueA will be 50</a>
	</p>
	<p>
	2. Subtraction
	<br>
	Language command: <b>Sub</b>
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=20<br>
        Data valueB=30<br>
        Sub valueA valueB<br>
        #the valueA will be -10</a>
	</p>
	<p>
	3. Multiplication
	<br>
	Language command: <b>Mult</b>
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=20<br>
        Data valueB=30<br>
        Mult valueA valueB<br>
        #the valueA will be 600</a>
	</p>
	<p>
	4. Division (signed 4/8, unsigned 1)
	<br>
	Language command: <b>Div</b> <b>Rem</b>
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=465<br>
        Data valueB=20<br>
        Div valueA valueB<br>
        #the valueA will be 23<br>
        Rem valueA valueB<br>
        #the valueA will be 3</a>
	</p>
	<p>
	5. Incrementation
	<br>
	Language command: <b>Inc</b> <b>IncSt</b>
	<br>
	The incrementation command adds one to the value.
	<br>
	Example:
	<br>
	<a class="code">
        Data value=30<br>
        Inc value<br>
        #the value will be 31</a>
	<b>IncSt</b> adds 4 bytes to the argument or 8 bytes when building for 64-bit application.
	<br>
	Example:
	<br>
	<a class="code">
        sd x#2;sd z^x<br>
        set z# 1;incst z;set z# 2<br>
        add z# x<br>
        #at z# will be 3</a>
	</p>
	<p>
	6. Decrementation
	<br>
	Language command: <b>Dec</b>
	<br>
	The decrementation command subtracts one from the value.
	<br>
	Example:
	<br>
	<a class="code">
        Data value=30<br>
        Dec value<br>
        #the value will be 29</a>
	<b>DecSt</b> subtracts 4 bytes from the argument or 8 bytes when building for 64-bit application.
	</p>
	<p>
	7. Negation
	<br>
	Language command: <b>Neg</b>
	<br>
	Subtract the operand from 0.
	<br>
	Example:
	<br>
	<a class="code">
        Data value=30<br>
        Neg value<br>
        #the value will be -30</a>
	</p>
</p>
<h3><a name="bitwiseoperations">V. Bitwise operations</a></h3>
<p>
	<p>
	1. And
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=0x0101<br>
        Data valueB=0x0001<br>
        And valueA valueB<br>
        #the valueA will be 0x0001</a>
	</p>
	<p>
	2. Or
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=0x0101<br>
        Data valueB=0x0011<br>
        Or valueA valueB<br>
        #the valueA will be 0x0111</a>
	</p>
	<p>
	3. Xor
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=0x0101<br>
        Data valueB=0x0011<br>
        Xor valueA valueB<br>
        #the valueA will be 0x0110</a>
	</p>
	<p>
	4. Not
	<br>
	Example:
	<br>
	<a class="code">
        Data valueA=0x0f0F0f0F<br>
        Not valueA<br>
        #the valueA will be 0xF0f0F0f0</a>
	</p>
	<p>
	5. ShL
	<br>
	Example:
	<br>
	<a class="code">
        sd shift_left_once=2<br>
        shl shift_left_once<br>
        #the value will be 4</a>
	</p>
	<p>
	6. ShR SaR
	<br>
	Example:
	<br>
	<a class="code">
        sd shift_right_once=0x10<br>
        SHR shift_right_once<br>
        #the value will be 8</a>
        sd shift_right_signed_once=-2<br>
        SaR shift_right_signed_once<br>
        #the value will be -1</a>
	</p>
</p>
<h3><a name="usingpointers">VI. Using pointers</a></h3>
<p>
	Pointers can be used for manipulating the data. The pointer sign at code operations is '#'.
    <br>
	Example:
    <br>
	<a class="code">
	<p>
        Data valueA=1<br>
        Data valueB=2<br>
        Data pointerA^valueA<br>
        Data pointerB^valueB<br>
        Add pointerA# pointerB#<br>
        #the valueA will be 3</p>

	<p>
        Chars data="ABC"<br>
        Str string^data<br>
        Chars c1#1<br>
        Set c1 string#<br>
        #the c1 will be A</p>

	<p>
        Inc string<br>
        Set c2 string#<br>
        #the c2 will be B</p>
	</a>

	<a class="code">
	<p>
        function test()<br>
            data bits_per_sample=16<br>
            return #bits_per_sample<br>
        endfunction<br>
        #the function call will return the pointer, and the variable can be modified<br>
        sd a<br>
        setcall a test()<br>
        set a# 8</p>
	</a>

	More can be done with the cast notations:

	<table class="code">
	<tr><td>format elfobj64</td></tr>
	<tr><td>sd a</td></tr>
	<tr><td>ss b</td></tr>
	<tr><td>hex 144;set a a#s^</td><td>#cast data to string</td></tr>
	<tr><td>Hex 144;set a a#v^</td><td>#cast data to value</td></tr>
	<tr><td>hEx 144;set b b#D^</td><td>#cast string to data</td></tr>
	<tr><td>heX 144;inc b#V^</td><td>#and a one arg cast</td></tr>
	</table>

	Static variables can be used in all scopes:

	<a class="code">
        Format Elf<br>
        Data a=3<br>
        Function test()<br>
&emsp;	Data b=3<br>
&emsp;	Add b main.a<br>
        EndFunction<br>
        Entry main()<br>
&emsp;	Call test()<br>
&emsp;	Add a test.b<br>
&emsp;	Exit a #9<br></a>
</p>
<h3><a name="usingfunctions">VII. Using functions</a></h3>
<p>
	<b>Function</b> can be declared and called later in the program. Functions must be closed with <b>EndFunction</b> command.
	To call a function use the <b>Call</b> command. To call a function and store the return value into a variable use the <b>SetCall</b> comand.
	The functions must be declared before the main scope.
	For example, at the first operation within the main scope (ex. basic Set command, or arithmetic Add command) the Entry Point is placed there and the Function statement it is no longer available.
	<br>
	The <b>Entry</b> command acts like a <b>Function</b> command but with some differences: 1. the scope is not changed to a local scope; 2. the function is not added to the unreferences list; 3. the <b>endfunction</b> command is not used at this function.
	<br>
	<b>EntryRaw</b> is an <b>Entry</b> command which is acting like it does not have a value for <b>Ret</b> at the top of the stack and without a calling convention.
	<br>
	<b>FunctionX</b> is described at objects. <b>FunctionXX</b> and <b>EntryX</b> will handle the input arguments as if they don't know how many there are (varargs).
	<br>
	All functions can be used in combinations like AddCall, OrCall, XorCall, etc.
	<br>
	<b>CallEx</b> is for prepared calls. This is a 3 argument operation. The first argument is the function name, the second argument is the arguments pointer and the third argument is the number of arguments. The arguments are passed forward respecting the size of the integer(4 bytes on 32-bits app, 8 on 64). One usage can be when there is a call with a number of arguments detected at run-time and want to pass them all to another call.
	A "SetCallEx" trick is to wrap <b>CallEx</b> in a function and to <b>SetCall</b> that function.
	<br>
	<b>CallX</b>, <b>...CallX</b>, <b>CallExX</b> will call like a <b>FunctionX</b>/<b>ImportX</b>.
	<p>
	Example:
	<a class="code">
	<p>
        Function numbers_inter(Data a)<br>
&emsp;			sd value<br>
&emsp;			setcall value numbers(a)<br>
&emsp;			return value<br>
        EndFunction<br>
        Function numbers(Data a)<br>
&emsp;			Data addmore=10<br>
&emsp;			Data outvalue#1<br>
&emsp;			Set outvalue a<br>
&emsp;			Add outvalue addmore<br>
&emsp;			Return outvalue<br>
        EndFunction<br>
        Data value=20<br>
        Call numbers(value)<br>
        #the return will be 30</p>
	<p>
        SetCall value numbers_inter(value)<br>
        #the value will store 30</p>
	<p>
        chars format="%i %i"<br>
        sd args^format;sd *={100,200}<br>
        CallEx printf #args 3</p>
	</a>
	</p>
</p>
<h3><a name="importinglibraries">VIII. Importing from libraries</a></h3>
<p>
	The functions can be imported from an extern library and used like in the previous chapter.
	To declare a library use the <b>Library</b> and to import a function use the <b>Import</b> command and provide the program function name.
	<p>
	Example:
	<br>
	<a class="code">
        #A Hello World program<br>
        #the default format is Format Exe<br>
        Library "user32.dll"<br>
        Import "MessageBoxA" Message<br>
        Chars program="Program"<br>
        Str title^program<br>
        Chars data="Hello World"<br>
        Str text^data<br>
        Data null=0<br>
        Call Message(null,text,title,null)<br>
        #a message will be displayed with the "Hello World" text and the title "Program"<br>
        Return null</a>
	</p>
</p>
<h3><a name="usingconditions">IX. Using conditions</a></h3>
<p>
	The language has <b>if-elseif-else</b> conditions that must by closed with <b>endif-endelseif-endelse</b> commands.
	The condition operators are:
	<br>
	Equal: ==
	<br>
	Not Equal: !=
	<br>
	Less: &#60;
	<br>
	Greater: &#62;
	<br>
	Less or Equal: &#60;=
	<br>
	Greater or Equal:&#62;=
	<br>
	Unsigned Less: &#60;^
	<br>
	Unsigned Greater: &#62;^
	<br>
	Unsigned Less or Equal: &#60;=^
	<br>
	Unsigned Greater or Equal:&#62;=^
	<p>
	Example:
	<a class="code">
	<p>
        Data a=3<br>
        Data b=10<br>
        Data c#1</p>
	<p>
        If a&#62;=b<br>
&emsp;			Set c a<br>
&emsp;			#This will not be executed<br>
        ElseIf a==b<br>
&emsp;			Set c a<br>
&emsp;			#This will not be executed<br>
        Else<br>
&emsp;			Set c a<br>
&emsp;			#This will be executed<br>
        EndElse</p>
	<p>
        If a&#60;b<br>
&emsp;			Set c a<br>
&emsp;			#This will be executed<br>
        EndIf</p>
	<p>
        If a&#62;b<br>
&emsp;			Set c a<br>
&emsp;			#This will not be executed<br>
        ElseIf a&#60;=b<br>
&emsp;			Set c a<br>
&emsp;			#This will be executed<br>
        EndElseIf</a>
	</p>
</p>
<h3><a name="looping">X. Looping</a></h3>
<p>
	<a class="code">
	sd a=5<br>
	sd b=0<br>
	while b&lt;a<br>
&emsp;	inc b<br>
&emsp;	if b==1<br>
&emsp;&emsp;	continue<br>
&emsp;	endif<br>
&emsp;	break<br>
	endwhile</a>
</p>
<h3><a name="includingfiles">XI. Including files</a></h3>
<p>
	The program can be formed with multiple files using the <b>Include</b> command.
	If compiling for multiple oses add a second path at <b>INCLUDE</b>;
		the preference include_sec 0 will take the first path, 1 will take the second path.
	<p>
	Example:
	<br>
	<a class="code">
        Include "files\\headers.h"<br>
        Include "files\\headers_win.h" "files\\headers_lin.h"</a>
	</p>
</p>
<h3><a name="exec">XII. Creating executable files</a></h3>
<p>
	Exe files for windows will be created by default. Executable and Linking Format (ELF) files can be created for Unix - System V, operable on linux platforms. <i>format elf</i> will override the default <i>format exe</i>.
	<p>
	Example:
	<br>
	<a class="code">
        #linux example<br>
        Format Elf<br>
        Library "libc.so.6"<br>
        #at first library, the interpretor is created: "lib/ld-linux.so.2"<br>
        Import "printf" printf<br>
        chars newlinedata={0xa,0}<br>
        str newline^newlinedata<br>
        call printf(newline)<br>
        chars hello="Hello World!"<br>
        str helloworld^hello<br>
        call printf(helloworld)<br>
        call printf(newline)<br>
        data one=1;return one<br>
        #linux sys_exit with the argument 1</a>
	</p>
</p>
<h3><a name="object">XIII. Creating object files</a></h3>
<p>
  <div>
	Object files can be created that have elf relocatable format. The format is <b>ElfObj</b>.
	The relocations are created automatically.
	There is the possibility to use the relocation sign ('%') when declaring a data that acts like equal sign but it also creates a relocation symbol to that address.
	<p>
	Example:
	<br>
	<a class="code">
        Format ElfObj<br>
        Data value#1<br>
        Data pointervalue^value<br>
        Entry main(data argc,data argv)<br>
        Set value argc<br>
        Data example#1<br>
        Set example argv<br>
        Return pointervalue#</a>
	</p>
  </div>
  <div>
	64-bit objects with 64-bit stack data and Microsoft/Linux calling convention can be created by adding <b>64</b> at <i>Format ElfObj</i>.<br>
	To mark a function for 64-bit convention convention import with <b>ImportX</b> or declare with <b>FunctionX</b>.
	<b>FunctionX</b> is also treated as an extern function that can be called from another program (no log for ounused and no warn).
	<p>
	Example:
	<br>
	<a class="code">
        Format ElfObj64<br>
        Entry main(data *argc,data *argv)<br>
        importx "printf" printf<br>
        if :!=8<br>
          call printf("Not at 64 bits")<br>
          return 1<br>
        endif<br>
        sd returnvalue<br>
        setcall returnvalue printf("Test: ")<br>
        call printf("long %lx,returnvalue)<br>
        Return 0</a>
	</p>
	64-bit can be ignored from preferences. Cross-compiles can be made at the same option from preferences.
  </div>
  <div>
	<p>
	Append <b>SO</b> at format to inform the log parser (ounused) to skip input/output functions and constants.
	This is a debugging option.
	<br>Example: Format elfobj64so
	</p>
  </div>
</p>
<h3><a name="otheroperations">XIV. Other operations</a></h3>
<p>
	Other commands that comes with the language.
	<br>
	1. Comments
	<br>
	To comment the code use the sign <b>#</b> before any text.
	<br>
	2. Interrupts
	<br>
	To place software breakpoints use the <b>I3</b> command.
	<br>
	3. Hex
	<br>
	Write bytes in the code section.
	<br>
	4. Warning
	<br>
	Turn on or off the warnings.
	<br>
	5. Override
	<br>
	Override preference. Note that preference order is default < preference_file < command_line_argument < override.
	<p>
	Example:
	<br>
	<a class="code">
        #This is a comment and it will not be executed<br>
        I3 #a line ending comment<br>
        #this will pause the program into a debugger<br>
        HEX 0x33,0xc0,0xC3<br>
        #this will write 3 bytes in the code section<br>
        warning off<br>
        import "common_function" common<br>
        warning on<br>
        #useful when having a header in multiple objects<br>
	  override underscore_pref 0<br>
	  importx "__errno_location" errno<br>
	  #if uderscore_pref is 1 the symbol is _errno_location, that can be wrong
	</a>
	</p>
	<p>
	When the option function_name from the .ocompiler.txt file is set to Yes(1), the name is wrote in the code section above the function, for debugging asm code.<br>
	The preferences file can be placed in HOME folder on linux.<br>
	Lines are ended with new line(0xa),carriage return and new line(0xd,0xa) or semicolon(0x3B).<br>
	The command line options are detailed at some point on the linux console std. On windows there some dialogs instead of console std.
	</p>
</p>
